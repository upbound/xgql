// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/upbound/xgql/internal/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	CompositeResource() CompositeResourceResolver
	CompositeResourceClaim() CompositeResourceClaimResolver
	CompositeResourceClaimSpec() CompositeResourceClaimSpecResolver
	CompositeResourceDefinition() CompositeResourceDefinitionResolver
	CompositeResourceDefinitionSpec() CompositeResourceDefinitionSpecResolver
	CompositeResourceSpec() CompositeResourceSpecResolver
	Composition() CompositionResolver
	ConfigMap() ConfigMapResolver
	Configuration() ConfigurationResolver
	ConfigurationRevision() ConfigurationRevisionResolver
	ConfigurationRevisionStatus() ConfigurationRevisionStatusResolver
	CustomResourceDefinition() CustomResourceDefinitionResolver
	Event() EventResolver
	GenericResource() GenericResourceResolver
	ManagedResource() ManagedResourceResolver
	ManagedResourceSpec() ManagedResourceSpecResolver
	Mutation() MutationResolver
	ObjectMeta() ObjectMetaResolver
	Provider() ProviderResolver
	ProviderConfig() ProviderConfigResolver
	ProviderRevision() ProviderRevisionResolver
	ProviderRevisionStatus() ProviderRevisionStatusResolver
	Query() QueryResolver
	Secret() SecretResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	CompositeResource struct {
		APIVersion   func(childComplexity int) int
		Definition   func(childComplexity int) int
		Events       func(childComplexity int) int
		FieldPath    func(childComplexity int, path *string) int
		ID           func(childComplexity int) int
		Kind         func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Spec         func(childComplexity int) int
		Status       func(childComplexity int) int
		Unstructured func(childComplexity int) int
	}

	CompositeResourceClaim struct {
		APIVersion   func(childComplexity int) int
		Definition   func(childComplexity int) int
		Events       func(childComplexity int) int
		FieldPath    func(childComplexity int, path *string) int
		ID           func(childComplexity int) int
		Kind         func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Spec         func(childComplexity int) int
		Status       func(childComplexity int) int
		Unstructured func(childComplexity int) int
	}

	CompositeResourceClaimConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CompositeResourceClaimConnectionDetails struct {
		LastPublishedTime func(childComplexity int) int
	}

	CompositeResourceClaimSpec struct {
		Composition                      func(childComplexity int) int
		CompositionRef                   func(childComplexity int) int
		CompositionSelector              func(childComplexity int) int
		ConnectionSecret                 func(childComplexity int) int
		Resource                         func(childComplexity int) int
		ResourceRef                      func(childComplexity int) int
		WriteConnectionSecretToReference func(childComplexity int) int
	}

	CompositeResourceClaimStatus struct {
		Conditions        func(childComplexity int) int
		ConnectionDetails func(childComplexity int) int
	}

	CompositeResourceConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CompositeResourceConnectionDetails struct {
		LastPublishedTime func(childComplexity int) int
	}

	CompositeResourceDefinition struct {
		APIVersion                     func(childComplexity int) int
		CompositeResourceClaimCrd      func(childComplexity int) int
		CompositeResourceCrd           func(childComplexity int) int
		DefinedCompositeResourceClaims func(childComplexity int, version *string, namespace *string, options *model.DefinedCompositeResourceClaimOptionsInput) int
		DefinedCompositeResources      func(childComplexity int, version *string, options *model.DefinedCompositeResourceOptionsInput) int
		Events                         func(childComplexity int) int
		FieldPath                      func(childComplexity int, path *string) int
		ID                             func(childComplexity int) int
		Kind                           func(childComplexity int) int
		Metadata                       func(childComplexity int) int
		Spec                           func(childComplexity int) int
		Status                         func(childComplexity int) int
		Unstructured                   func(childComplexity int) int
	}

	CompositeResourceDefinitionConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CompositeResourceDefinitionControllerStatus struct {
		CompositeResourceClaimType func(childComplexity int) int
		CompositeResourceType      func(childComplexity int) int
	}

	CompositeResourceDefinitionNames struct {
		Categories func(childComplexity int) int
		Kind       func(childComplexity int) int
		ListKind   func(childComplexity int) int
		Plural     func(childComplexity int) int
		ShortNames func(childComplexity int) int
		Singular   func(childComplexity int) int
	}

	CompositeResourceDefinitionSpec struct {
		ClaimNames           func(childComplexity int) int
		ConnectionSecretKeys func(childComplexity int) int
		DefaultComposition   func(childComplexity int) int
		EnforcedComposition  func(childComplexity int) int
		Group                func(childComplexity int) int
		Names                func(childComplexity int) int
		Versions             func(childComplexity int) int
	}

	CompositeResourceDefinitionStatus struct {
		Conditions  func(childComplexity int) int
		Controllers func(childComplexity int) int
	}

	CompositeResourceDefinitionVersion struct {
		Name          func(childComplexity int) int
		Referenceable func(childComplexity int) int
		Schema        func(childComplexity int) int
		Served        func(childComplexity int) int
	}

	CompositeResourceSpec struct {
		Claim                            func(childComplexity int) int
		ClaimRef                         func(childComplexity int) int
		Composition                      func(childComplexity int) int
		CompositionRef                   func(childComplexity int) int
		CompositionSelector              func(childComplexity int) int
		ConnectionSecret                 func(childComplexity int) int
		ResourceRefs                     func(childComplexity int) int
		Resources                        func(childComplexity int) int
		WriteConnectionSecretToReference func(childComplexity int) int
	}

	CompositeResourceStatus struct {
		Conditions        func(childComplexity int) int
		ConnectionDetails func(childComplexity int) int
	}

	CompositeResourceValidation struct {
		OpenAPIV3Schema func(childComplexity int) int
	}

	Composition struct {
		APIVersion   func(childComplexity int) int
		Events       func(childComplexity int) int
		FieldPath    func(childComplexity int, path *string) int
		ID           func(childComplexity int) int
		Kind         func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Spec         func(childComplexity int) int
		Status       func(childComplexity int) int
		Unstructured func(childComplexity int) int
	}

	CompositionConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CompositionSpec struct {
		CompositeTypeRef                  func(childComplexity int) int
		WriteConnectionSecretsToNamespace func(childComplexity int) int
	}

	CompositionStatus struct {
		Conditions func(childComplexity int) int
	}

	Condition struct {
		LastTransitionTime func(childComplexity int) int
		Message            func(childComplexity int) int
		Reason             func(childComplexity int) int
		Status             func(childComplexity int) int
		Type               func(childComplexity int) int
	}

	ConfigMap struct {
		APIVersion   func(childComplexity int) int
		Data         func(childComplexity int, keys []string) int
		Events       func(childComplexity int) int
		FieldPath    func(childComplexity int, path *string) int
		ID           func(childComplexity int) int
		Kind         func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Unstructured func(childComplexity int) int
	}

	Configuration struct {
		APIVersion     func(childComplexity int) int
		ActiveRevision func(childComplexity int) int
		Events         func(childComplexity int) int
		FieldPath      func(childComplexity int, path *string) int
		ID             func(childComplexity int) int
		Kind           func(childComplexity int) int
		Metadata       func(childComplexity int) int
		Revisions      func(childComplexity int) int
		Spec           func(childComplexity int) int
		Status         func(childComplexity int) int
		Unstructured   func(childComplexity int) int
	}

	ConfigurationConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ConfigurationRevision struct {
		APIVersion   func(childComplexity int) int
		Events       func(childComplexity int) int
		FieldPath    func(childComplexity int, path *string) int
		ID           func(childComplexity int) int
		Kind         func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Spec         func(childComplexity int) int
		Status       func(childComplexity int) int
		Unstructured func(childComplexity int) int
	}

	ConfigurationRevisionConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ConfigurationRevisionSpec struct {
		DesiredState                func(childComplexity int) int
		IgnoreCrossplaneConstraints func(childComplexity int) int
		Package                     func(childComplexity int) int
		PackagePullPolicy           func(childComplexity int) int
		Revision                    func(childComplexity int) int
		SkipDependencyResolution    func(childComplexity int) int
	}

	ConfigurationRevisionStatus struct {
		Conditions            func(childComplexity int) int
		FoundDependencies     func(childComplexity int) int
		InstalledDependencies func(childComplexity int) int
		InvalidDependencies   func(childComplexity int) int
		Objects               func(childComplexity int) int
		PermissionRequests    func(childComplexity int) int
	}

	ConfigurationSpec struct {
		IgnoreCrossplaneConstraints func(childComplexity int) int
		Package                     func(childComplexity int) int
		PackagePullPolicy           func(childComplexity int) int
		RevisionActivationPolicy    func(childComplexity int) int
		RevisionHistoryLimit        func(childComplexity int) int
		SkipDependencyResolution    func(childComplexity int) int
	}

	ConfigurationStatus struct {
		Conditions        func(childComplexity int) int
		CurrentIdentifier func(childComplexity int) int
		CurrentRevision   func(childComplexity int) int
	}

	CreateKubernetesResourcePayload struct {
		Resource func(childComplexity int) int
	}

	CrossplaneResourceTreeConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CrossplaneResourceTreeNode struct {
		ParentID func(childComplexity int) int
		Resource func(childComplexity int) int
	}

	CustomResourceDefinition struct {
		APIVersion       func(childComplexity int) int
		DefinedResources func(childComplexity int, version *string) int
		Events           func(childComplexity int) int
		FieldPath        func(childComplexity int, path *string) int
		ID               func(childComplexity int) int
		Kind             func(childComplexity int) int
		Metadata         func(childComplexity int) int
		Spec             func(childComplexity int) int
		Status           func(childComplexity int) int
		Unstructured     func(childComplexity int) int
	}

	CustomResourceDefinitionConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CustomResourceDefinitionNames struct {
		Categories func(childComplexity int) int
		Kind       func(childComplexity int) int
		ListKind   func(childComplexity int) int
		Plural     func(childComplexity int) int
		ShortNames func(childComplexity int) int
		Singular   func(childComplexity int) int
	}

	CustomResourceDefinitionSpec struct {
		Group    func(childComplexity int) int
		Names    func(childComplexity int) int
		Scope    func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	CustomResourceDefinitionStatus struct {
		Conditions func(childComplexity int) int
	}

	CustomResourceDefinitionVersion struct {
		Name   func(childComplexity int) int
		Schema func(childComplexity int) int
		Served func(childComplexity int) int
	}

	CustomResourceValidation struct {
		OpenAPIV3Schema func(childComplexity int) int
	}

	DeleteKubernetesResourcePayload struct {
		Resource func(childComplexity int) int
	}

	Event struct {
		APIVersion     func(childComplexity int) int
		Count          func(childComplexity int) int
		FieldPath      func(childComplexity int, path *string) int
		FirstTime      func(childComplexity int) int
		ID             func(childComplexity int) int
		InvolvedObject func(childComplexity int) int
		Kind           func(childComplexity int) int
		LastTime       func(childComplexity int) int
		Message        func(childComplexity int) int
		Metadata       func(childComplexity int) int
		Reason         func(childComplexity int) int
		Source         func(childComplexity int) int
		Type           func(childComplexity int) int
		Unstructured   func(childComplexity int) int
	}

	EventConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	EventSource struct {
		Component func(childComplexity int) int
	}

	GenericResource struct {
		APIVersion   func(childComplexity int) int
		Events       func(childComplexity int) int
		FieldPath    func(childComplexity int, path *string) int
		ID           func(childComplexity int) int
		Kind         func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Unstructured func(childComplexity int) int
	}

	KubernetesResourceConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LabelSelector struct {
		MatchLabels func(childComplexity int) int
	}

	LocalObjectReference struct {
		Name func(childComplexity int) int
	}

	ManagedResource struct {
		APIVersion   func(childComplexity int) int
		Definition   func(childComplexity int) int
		Events       func(childComplexity int) int
		FieldPath    func(childComplexity int, path *string) int
		ID           func(childComplexity int) int
		Kind         func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Spec         func(childComplexity int) int
		Status       func(childComplexity int) int
		Unstructured func(childComplexity int) int
	}

	ManagedResourceSpec struct {
		ConnectionSecret  func(childComplexity int) int
		DeletionPolicy    func(childComplexity int) int
		ProviderConfigRef func(childComplexity int) int
	}

	ManagedResourceStatus struct {
		Conditions func(childComplexity int) int
	}

	Mutation struct {
		CreateKubernetesResource func(childComplexity int, input model.CreateKubernetesResourceInput) int
		DeleteKubernetesResource func(childComplexity int, id model.ReferenceID) int
		UpdateKubernetesResource func(childComplexity int, id model.ReferenceID, input model.UpdateKubernetesResourceInput) int
	}

	ObjectMeta struct {
		Annotations     func(childComplexity int, keys []string) int
		Controller      func(childComplexity int) int
		CreationTime    func(childComplexity int) int
		DeletionTime    func(childComplexity int) int
		GenerateName    func(childComplexity int) int
		Generation      func(childComplexity int) int
		Labels          func(childComplexity int, keys []string) int
		Name            func(childComplexity int) int
		Namespace       func(childComplexity int) int
		Owners          func(childComplexity int) int
		ResourceVersion func(childComplexity int) int
		UID             func(childComplexity int) int
	}

	ObjectReference struct {
		Kind      func(childComplexity int) int
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	Owner struct {
		Controller func(childComplexity int) int
		Resource   func(childComplexity int) int
	}

	OwnerConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PolicyRule struct {
		APIGroups       func(childComplexity int) int
		NonResourceURLs func(childComplexity int) int
		ResourceNames   func(childComplexity int) int
		Resources       func(childComplexity int) int
		Verbs           func(childComplexity int) int
	}

	Provider struct {
		APIVersion     func(childComplexity int) int
		ActiveRevision func(childComplexity int) int
		Events         func(childComplexity int) int
		FieldPath      func(childComplexity int, path *string) int
		ID             func(childComplexity int) int
		Kind           func(childComplexity int) int
		Metadata       func(childComplexity int) int
		Revisions      func(childComplexity int) int
		Spec           func(childComplexity int) int
		Status         func(childComplexity int) int
		Unstructured   func(childComplexity int) int
	}

	ProviderConfig struct {
		APIVersion   func(childComplexity int) int
		Definition   func(childComplexity int) int
		Events       func(childComplexity int) int
		FieldPath    func(childComplexity int, path *string) int
		ID           func(childComplexity int) int
		Kind         func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Status       func(childComplexity int) int
		Unstructured func(childComplexity int) int
	}

	ProviderConfigReference struct {
		Name func(childComplexity int) int
	}

	ProviderConfigStatus struct {
		Conditions func(childComplexity int) int
		Users      func(childComplexity int) int
	}

	ProviderConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ProviderRevision struct {
		APIVersion   func(childComplexity int) int
		Events       func(childComplexity int) int
		FieldPath    func(childComplexity int, path *string) int
		ID           func(childComplexity int) int
		Kind         func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Spec         func(childComplexity int) int
		Status       func(childComplexity int) int
		Unstructured func(childComplexity int) int
	}

	ProviderRevisionConnection struct {
		Nodes      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ProviderRevisionSpec struct {
		DesiredState                func(childComplexity int) int
		IgnoreCrossplaneConstraints func(childComplexity int) int
		Package                     func(childComplexity int) int
		PackagePullPolicy           func(childComplexity int) int
		Revision                    func(childComplexity int) int
		SkipDependencyResolution    func(childComplexity int) int
	}

	ProviderRevisionStatus struct {
		Conditions            func(childComplexity int) int
		FoundDependencies     func(childComplexity int) int
		InstalledDependencies func(childComplexity int) int
		InvalidDependencies   func(childComplexity int) int
		Objects               func(childComplexity int) int
		PermissionRequests    func(childComplexity int) int
	}

	ProviderSpec struct {
		IgnoreCrossplaneConstraints func(childComplexity int) int
		Package                     func(childComplexity int) int
		PackagePullPolicy           func(childComplexity int) int
		RevisionActivationPolicy    func(childComplexity int) int
		RevisionHistoryLimit        func(childComplexity int) int
		SkipDependencyResolution    func(childComplexity int) int
	}

	ProviderStatus struct {
		Conditions        func(childComplexity int) int
		CurrentIdentifier func(childComplexity int) int
		CurrentRevision   func(childComplexity int) int
	}

	Query struct {
		CompositeResourceDefinitions func(childComplexity int, revision *model.ReferenceID, dangling *bool) int
		Compositions                 func(childComplexity int, revision *model.ReferenceID, dangling *bool) int
		ConfigMap                    func(childComplexity int, namespace string, name string) int
		ConfigurationRevisions       func(childComplexity int, configuration *model.ReferenceID, active *bool) int
		Configurations               func(childComplexity int) int
		CrossplaneResourceTree       func(childComplexity int, id model.ReferenceID) int
		CustomResourceDefinitions    func(childComplexity int, revision *model.ReferenceID) int
		Events                       func(childComplexity int, involved *model.ReferenceID) int
		KubernetesResource           func(childComplexity int, id model.ReferenceID) int
		KubernetesResources          func(childComplexity int, apiVersion string, kind string, listKind *string, namespace *string) int
		ProviderRevisions            func(childComplexity int, provider *model.ReferenceID, active *bool) int
		Providers                    func(childComplexity int) int
		Secret                       func(childComplexity int, namespace string, name string) int
	}

	Secret struct {
		APIVersion   func(childComplexity int) int
		Data         func(childComplexity int, keys []string) int
		Events       func(childComplexity int) int
		FieldPath    func(childComplexity int, path *string) int
		ID           func(childComplexity int) int
		Kind         func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Type         func(childComplexity int) int
		Unstructured func(childComplexity int) int
	}

	SecretReference struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	Subscription struct {
	}

	TypeReference struct {
		APIVersion func(childComplexity int) int
		Kind       func(childComplexity int) int
	}

	UpdateKubernetesResourcePayload struct {
		Resource func(childComplexity int) int
	}
}

type CompositeResourceResolver interface {
	Events(ctx context.Context, obj *model.CompositeResource) (model.EventConnection, error)
	Definition(ctx context.Context, obj *model.CompositeResource) (*model.CompositeResourceDefinition, error)
}
type CompositeResourceClaimResolver interface {
	Events(ctx context.Context, obj *model.CompositeResourceClaim) (model.EventConnection, error)
	Definition(ctx context.Context, obj *model.CompositeResourceClaim) (*model.CompositeResourceDefinition, error)
}
type CompositeResourceClaimSpecResolver interface {
	Composition(ctx context.Context, obj *model.CompositeResourceClaimSpec) (*model.Composition, error)
	CompositionRef(ctx context.Context, obj *model.CompositeResourceClaimSpec) (*model.LocalObjectReference, error)

	Resource(ctx context.Context, obj *model.CompositeResourceClaimSpec) (*model.CompositeResource, error)
	ResourceRef(ctx context.Context, obj *model.CompositeResourceClaimSpec) (*model.ObjectReference, error)
	ConnectionSecret(ctx context.Context, obj *model.CompositeResourceClaimSpec) (*model.Secret, error)
	WriteConnectionSecretToReference(ctx context.Context, obj *model.CompositeResourceClaimSpec) (*model.SecretReference, error)
}
type CompositeResourceDefinitionResolver interface {
	Events(ctx context.Context, obj *model.CompositeResourceDefinition) (model.EventConnection, error)
	CompositeResourceCrd(ctx context.Context, obj *model.CompositeResourceDefinition) (*model.CustomResourceDefinition, error)
	CompositeResourceClaimCrd(ctx context.Context, obj *model.CompositeResourceDefinition) (*model.CustomResourceDefinition, error)
	DefinedCompositeResources(ctx context.Context, obj *model.CompositeResourceDefinition, version *string, options *model.DefinedCompositeResourceOptionsInput) (model.CompositeResourceConnection, error)
	DefinedCompositeResourceClaims(ctx context.Context, obj *model.CompositeResourceDefinition, version *string, namespace *string, options *model.DefinedCompositeResourceClaimOptionsInput) (model.CompositeResourceClaimConnection, error)
}
type CompositeResourceDefinitionSpecResolver interface {
	DefaultComposition(ctx context.Context, obj *model.CompositeResourceDefinitionSpec) (*model.Composition, error)
	EnforcedComposition(ctx context.Context, obj *model.CompositeResourceDefinitionSpec) (*model.Composition, error)
}
type CompositeResourceSpecResolver interface {
	Composition(ctx context.Context, obj *model.CompositeResourceSpec) (*model.Composition, error)
	CompositionRef(ctx context.Context, obj *model.CompositeResourceSpec) (*model.LocalObjectReference, error)

	Claim(ctx context.Context, obj *model.CompositeResourceSpec) (*model.CompositeResourceClaim, error)
	ClaimRef(ctx context.Context, obj *model.CompositeResourceSpec) (*model.ObjectReference, error)
	ConnectionSecret(ctx context.Context, obj *model.CompositeResourceSpec) (*model.Secret, error)
	ResourceRefs(ctx context.Context, obj *model.CompositeResourceSpec) ([]model.ObjectReference, error)
	Resources(ctx context.Context, obj *model.CompositeResourceSpec) (model.KubernetesResourceConnection, error)
	WriteConnectionSecretToReference(ctx context.Context, obj *model.CompositeResourceSpec) (*model.SecretReference, error)
}
type CompositionResolver interface {
	Events(ctx context.Context, obj *model.Composition) (model.EventConnection, error)
}
type ConfigMapResolver interface {
	Events(ctx context.Context, obj *model.ConfigMap) (model.EventConnection, error)
}
type ConfigurationResolver interface {
	Events(ctx context.Context, obj *model.Configuration) (model.EventConnection, error)
	Revisions(ctx context.Context, obj *model.Configuration) (model.ConfigurationRevisionConnection, error)
	ActiveRevision(ctx context.Context, obj *model.Configuration) (*model.ConfigurationRevision, error)
}
type ConfigurationRevisionResolver interface {
	Events(ctx context.Context, obj *model.ConfigurationRevision) (model.EventConnection, error)
}
type ConfigurationRevisionStatusResolver interface {
	Objects(ctx context.Context, obj *model.ConfigurationRevisionStatus) (model.KubernetesResourceConnection, error)
}
type CustomResourceDefinitionResolver interface {
	Events(ctx context.Context, obj *model.CustomResourceDefinition) (model.EventConnection, error)
	DefinedResources(ctx context.Context, obj *model.CustomResourceDefinition, version *string) (model.KubernetesResourceConnection, error)
}
type EventResolver interface {
	InvolvedObject(ctx context.Context, obj *model.Event) (model.KubernetesResource, error)
}
type GenericResourceResolver interface {
	Events(ctx context.Context, obj *model.GenericResource) (model.EventConnection, error)
}
type ManagedResourceResolver interface {
	Events(ctx context.Context, obj *model.ManagedResource) (model.EventConnection, error)
	Definition(ctx context.Context, obj *model.ManagedResource) (model.ManagedResourceDefinition, error)
}
type ManagedResourceSpecResolver interface {
	ConnectionSecret(ctx context.Context, obj *model.ManagedResourceSpec) (*model.Secret, error)
}
type MutationResolver interface {
	CreateKubernetesResource(ctx context.Context, input model.CreateKubernetesResourceInput) (model.CreateKubernetesResourcePayload, error)
	UpdateKubernetesResource(ctx context.Context, id model.ReferenceID, input model.UpdateKubernetesResourceInput) (model.UpdateKubernetesResourcePayload, error)
	DeleteKubernetesResource(ctx context.Context, id model.ReferenceID) (model.DeleteKubernetesResourcePayload, error)
}
type ObjectMetaResolver interface {
	Owners(ctx context.Context, obj *model.ObjectMeta) (model.OwnerConnection, error)
	Controller(ctx context.Context, obj *model.ObjectMeta) (model.KubernetesResource, error)
}
type ProviderResolver interface {
	Events(ctx context.Context, obj *model.Provider) (model.EventConnection, error)
	Revisions(ctx context.Context, obj *model.Provider) (model.ProviderRevisionConnection, error)
	ActiveRevision(ctx context.Context, obj *model.Provider) (*model.ProviderRevision, error)
}
type ProviderConfigResolver interface {
	Events(ctx context.Context, obj *model.ProviderConfig) (model.EventConnection, error)
	Definition(ctx context.Context, obj *model.ProviderConfig) (model.ProviderConfigDefinition, error)
}
type ProviderRevisionResolver interface {
	Events(ctx context.Context, obj *model.ProviderRevision) (model.EventConnection, error)
}
type ProviderRevisionStatusResolver interface {
	Objects(ctx context.Context, obj *model.ProviderRevisionStatus) (model.KubernetesResourceConnection, error)
}
type QueryResolver interface {
	KubernetesResource(ctx context.Context, id model.ReferenceID) (model.KubernetesResource, error)
	KubernetesResources(ctx context.Context, apiVersion string, kind string, listKind *string, namespace *string) (model.KubernetesResourceConnection, error)
	Events(ctx context.Context, involved *model.ReferenceID) (model.EventConnection, error)
	Secret(ctx context.Context, namespace string, name string) (*model.Secret, error)
	ConfigMap(ctx context.Context, namespace string, name string) (*model.ConfigMap, error)
	Providers(ctx context.Context) (model.ProviderConnection, error)
	ProviderRevisions(ctx context.Context, provider *model.ReferenceID, active *bool) (model.ProviderRevisionConnection, error)
	CustomResourceDefinitions(ctx context.Context, revision *model.ReferenceID) (model.CustomResourceDefinitionConnection, error)
	Configurations(ctx context.Context) (model.ConfigurationConnection, error)
	ConfigurationRevisions(ctx context.Context, configuration *model.ReferenceID, active *bool) (model.ConfigurationRevisionConnection, error)
	CompositeResourceDefinitions(ctx context.Context, revision *model.ReferenceID, dangling *bool) (model.CompositeResourceDefinitionConnection, error)
	Compositions(ctx context.Context, revision *model.ReferenceID, dangling *bool) (model.CompositionConnection, error)
	CrossplaneResourceTree(ctx context.Context, id model.ReferenceID) (model.CrossplaneResourceTreeConnection, error)
}
type SecretResolver interface {
	Events(ctx context.Context, obj *model.Secret) (model.EventConnection, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "CompositeResource.apiVersion":
		if e.complexity.CompositeResource.APIVersion == nil {
			break
		}

		return e.complexity.CompositeResource.APIVersion(childComplexity), true

	case "CompositeResource.definition":
		if e.complexity.CompositeResource.Definition == nil {
			break
		}

		return e.complexity.CompositeResource.Definition(childComplexity), true

	case "CompositeResource.events":
		if e.complexity.CompositeResource.Events == nil {
			break
		}

		return e.complexity.CompositeResource.Events(childComplexity), true

	case "CompositeResource.fieldPath":
		if e.complexity.CompositeResource.FieldPath == nil {
			break
		}

		args, err := ec.field_CompositeResource_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CompositeResource.FieldPath(childComplexity, args["path"].(*string)), true

	case "CompositeResource.id":
		if e.complexity.CompositeResource.ID == nil {
			break
		}

		return e.complexity.CompositeResource.ID(childComplexity), true

	case "CompositeResource.kind":
		if e.complexity.CompositeResource.Kind == nil {
			break
		}

		return e.complexity.CompositeResource.Kind(childComplexity), true

	case "CompositeResource.metadata":
		if e.complexity.CompositeResource.Metadata == nil {
			break
		}

		return e.complexity.CompositeResource.Metadata(childComplexity), true

	case "CompositeResource.spec":
		if e.complexity.CompositeResource.Spec == nil {
			break
		}

		return e.complexity.CompositeResource.Spec(childComplexity), true

	case "CompositeResource.status":
		if e.complexity.CompositeResource.Status == nil {
			break
		}

		return e.complexity.CompositeResource.Status(childComplexity), true

	case "CompositeResource.unstructured":
		if e.complexity.CompositeResource.Unstructured == nil {
			break
		}

		return e.complexity.CompositeResource.Unstructured(childComplexity), true

	case "CompositeResourceClaim.apiVersion":
		if e.complexity.CompositeResourceClaim.APIVersion == nil {
			break
		}

		return e.complexity.CompositeResourceClaim.APIVersion(childComplexity), true

	case "CompositeResourceClaim.definition":
		if e.complexity.CompositeResourceClaim.Definition == nil {
			break
		}

		return e.complexity.CompositeResourceClaim.Definition(childComplexity), true

	case "CompositeResourceClaim.events":
		if e.complexity.CompositeResourceClaim.Events == nil {
			break
		}

		return e.complexity.CompositeResourceClaim.Events(childComplexity), true

	case "CompositeResourceClaim.fieldPath":
		if e.complexity.CompositeResourceClaim.FieldPath == nil {
			break
		}

		args, err := ec.field_CompositeResourceClaim_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CompositeResourceClaim.FieldPath(childComplexity, args["path"].(*string)), true

	case "CompositeResourceClaim.id":
		if e.complexity.CompositeResourceClaim.ID == nil {
			break
		}

		return e.complexity.CompositeResourceClaim.ID(childComplexity), true

	case "CompositeResourceClaim.kind":
		if e.complexity.CompositeResourceClaim.Kind == nil {
			break
		}

		return e.complexity.CompositeResourceClaim.Kind(childComplexity), true

	case "CompositeResourceClaim.metadata":
		if e.complexity.CompositeResourceClaim.Metadata == nil {
			break
		}

		return e.complexity.CompositeResourceClaim.Metadata(childComplexity), true

	case "CompositeResourceClaim.spec":
		if e.complexity.CompositeResourceClaim.Spec == nil {
			break
		}

		return e.complexity.CompositeResourceClaim.Spec(childComplexity), true

	case "CompositeResourceClaim.status":
		if e.complexity.CompositeResourceClaim.Status == nil {
			break
		}

		return e.complexity.CompositeResourceClaim.Status(childComplexity), true

	case "CompositeResourceClaim.unstructured":
		if e.complexity.CompositeResourceClaim.Unstructured == nil {
			break
		}

		return e.complexity.CompositeResourceClaim.Unstructured(childComplexity), true

	case "CompositeResourceClaimConnection.nodes":
		if e.complexity.CompositeResourceClaimConnection.Nodes == nil {
			break
		}

		return e.complexity.CompositeResourceClaimConnection.Nodes(childComplexity), true

	case "CompositeResourceClaimConnection.totalCount":
		if e.complexity.CompositeResourceClaimConnection.TotalCount == nil {
			break
		}

		return e.complexity.CompositeResourceClaimConnection.TotalCount(childComplexity), true

	case "CompositeResourceClaimConnectionDetails.lastPublishedTime":
		if e.complexity.CompositeResourceClaimConnectionDetails.LastPublishedTime == nil {
			break
		}

		return e.complexity.CompositeResourceClaimConnectionDetails.LastPublishedTime(childComplexity), true

	case "CompositeResourceClaimSpec.composition":
		if e.complexity.CompositeResourceClaimSpec.Composition == nil {
			break
		}

		return e.complexity.CompositeResourceClaimSpec.Composition(childComplexity), true

	case "CompositeResourceClaimSpec.compositionRef":
		if e.complexity.CompositeResourceClaimSpec.CompositionRef == nil {
			break
		}

		return e.complexity.CompositeResourceClaimSpec.CompositionRef(childComplexity), true

	case "CompositeResourceClaimSpec.compositionSelector":
		if e.complexity.CompositeResourceClaimSpec.CompositionSelector == nil {
			break
		}

		return e.complexity.CompositeResourceClaimSpec.CompositionSelector(childComplexity), true

	case "CompositeResourceClaimSpec.connectionSecret":
		if e.complexity.CompositeResourceClaimSpec.ConnectionSecret == nil {
			break
		}

		return e.complexity.CompositeResourceClaimSpec.ConnectionSecret(childComplexity), true

	case "CompositeResourceClaimSpec.resource":
		if e.complexity.CompositeResourceClaimSpec.Resource == nil {
			break
		}

		return e.complexity.CompositeResourceClaimSpec.Resource(childComplexity), true

	case "CompositeResourceClaimSpec.resourceRef":
		if e.complexity.CompositeResourceClaimSpec.ResourceRef == nil {
			break
		}

		return e.complexity.CompositeResourceClaimSpec.ResourceRef(childComplexity), true

	case "CompositeResourceClaimSpec.writeConnectionSecretToReference":
		if e.complexity.CompositeResourceClaimSpec.WriteConnectionSecretToReference == nil {
			break
		}

		return e.complexity.CompositeResourceClaimSpec.WriteConnectionSecretToReference(childComplexity), true

	case "CompositeResourceClaimStatus.conditions":
		if e.complexity.CompositeResourceClaimStatus.Conditions == nil {
			break
		}

		return e.complexity.CompositeResourceClaimStatus.Conditions(childComplexity), true

	case "CompositeResourceClaimStatus.connectionDetails":
		if e.complexity.CompositeResourceClaimStatus.ConnectionDetails == nil {
			break
		}

		return e.complexity.CompositeResourceClaimStatus.ConnectionDetails(childComplexity), true

	case "CompositeResourceConnection.nodes":
		if e.complexity.CompositeResourceConnection.Nodes == nil {
			break
		}

		return e.complexity.CompositeResourceConnection.Nodes(childComplexity), true

	case "CompositeResourceConnection.totalCount":
		if e.complexity.CompositeResourceConnection.TotalCount == nil {
			break
		}

		return e.complexity.CompositeResourceConnection.TotalCount(childComplexity), true

	case "CompositeResourceConnectionDetails.lastPublishedTime":
		if e.complexity.CompositeResourceConnectionDetails.LastPublishedTime == nil {
			break
		}

		return e.complexity.CompositeResourceConnectionDetails.LastPublishedTime(childComplexity), true

	case "CompositeResourceDefinition.apiVersion":
		if e.complexity.CompositeResourceDefinition.APIVersion == nil {
			break
		}

		return e.complexity.CompositeResourceDefinition.APIVersion(childComplexity), true

	case "CompositeResourceDefinition.compositeResourceClaimCRD":
		if e.complexity.CompositeResourceDefinition.CompositeResourceClaimCrd == nil {
			break
		}

		return e.complexity.CompositeResourceDefinition.CompositeResourceClaimCrd(childComplexity), true

	case "CompositeResourceDefinition.compositeResourceCRD":
		if e.complexity.CompositeResourceDefinition.CompositeResourceCrd == nil {
			break
		}

		return e.complexity.CompositeResourceDefinition.CompositeResourceCrd(childComplexity), true

	case "CompositeResourceDefinition.definedCompositeResourceClaims":
		if e.complexity.CompositeResourceDefinition.DefinedCompositeResourceClaims == nil {
			break
		}

		args, err := ec.field_CompositeResourceDefinition_definedCompositeResourceClaims_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CompositeResourceDefinition.DefinedCompositeResourceClaims(childComplexity, args["version"].(*string), args["namespace"].(*string), args["options"].(*model.DefinedCompositeResourceClaimOptionsInput)), true

	case "CompositeResourceDefinition.definedCompositeResources":
		if e.complexity.CompositeResourceDefinition.DefinedCompositeResources == nil {
			break
		}

		args, err := ec.field_CompositeResourceDefinition_definedCompositeResources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CompositeResourceDefinition.DefinedCompositeResources(childComplexity, args["version"].(*string), args["options"].(*model.DefinedCompositeResourceOptionsInput)), true

	case "CompositeResourceDefinition.events":
		if e.complexity.CompositeResourceDefinition.Events == nil {
			break
		}

		return e.complexity.CompositeResourceDefinition.Events(childComplexity), true

	case "CompositeResourceDefinition.fieldPath":
		if e.complexity.CompositeResourceDefinition.FieldPath == nil {
			break
		}

		args, err := ec.field_CompositeResourceDefinition_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CompositeResourceDefinition.FieldPath(childComplexity, args["path"].(*string)), true

	case "CompositeResourceDefinition.id":
		if e.complexity.CompositeResourceDefinition.ID == nil {
			break
		}

		return e.complexity.CompositeResourceDefinition.ID(childComplexity), true

	case "CompositeResourceDefinition.kind":
		if e.complexity.CompositeResourceDefinition.Kind == nil {
			break
		}

		return e.complexity.CompositeResourceDefinition.Kind(childComplexity), true

	case "CompositeResourceDefinition.metadata":
		if e.complexity.CompositeResourceDefinition.Metadata == nil {
			break
		}

		return e.complexity.CompositeResourceDefinition.Metadata(childComplexity), true

	case "CompositeResourceDefinition.spec":
		if e.complexity.CompositeResourceDefinition.Spec == nil {
			break
		}

		return e.complexity.CompositeResourceDefinition.Spec(childComplexity), true

	case "CompositeResourceDefinition.status":
		if e.complexity.CompositeResourceDefinition.Status == nil {
			break
		}

		return e.complexity.CompositeResourceDefinition.Status(childComplexity), true

	case "CompositeResourceDefinition.unstructured":
		if e.complexity.CompositeResourceDefinition.Unstructured == nil {
			break
		}

		return e.complexity.CompositeResourceDefinition.Unstructured(childComplexity), true

	case "CompositeResourceDefinitionConnection.nodes":
		if e.complexity.CompositeResourceDefinitionConnection.Nodes == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionConnection.Nodes(childComplexity), true

	case "CompositeResourceDefinitionConnection.totalCount":
		if e.complexity.CompositeResourceDefinitionConnection.TotalCount == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionConnection.TotalCount(childComplexity), true

	case "CompositeResourceDefinitionControllerStatus.compositeResourceClaimType":
		if e.complexity.CompositeResourceDefinitionControllerStatus.CompositeResourceClaimType == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionControllerStatus.CompositeResourceClaimType(childComplexity), true

	case "CompositeResourceDefinitionControllerStatus.compositeResourceType":
		if e.complexity.CompositeResourceDefinitionControllerStatus.CompositeResourceType == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionControllerStatus.CompositeResourceType(childComplexity), true

	case "CompositeResourceDefinitionNames.categories":
		if e.complexity.CompositeResourceDefinitionNames.Categories == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionNames.Categories(childComplexity), true

	case "CompositeResourceDefinitionNames.kind":
		if e.complexity.CompositeResourceDefinitionNames.Kind == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionNames.Kind(childComplexity), true

	case "CompositeResourceDefinitionNames.listKind":
		if e.complexity.CompositeResourceDefinitionNames.ListKind == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionNames.ListKind(childComplexity), true

	case "CompositeResourceDefinitionNames.plural":
		if e.complexity.CompositeResourceDefinitionNames.Plural == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionNames.Plural(childComplexity), true

	case "CompositeResourceDefinitionNames.shortNames":
		if e.complexity.CompositeResourceDefinitionNames.ShortNames == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionNames.ShortNames(childComplexity), true

	case "CompositeResourceDefinitionNames.singular":
		if e.complexity.CompositeResourceDefinitionNames.Singular == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionNames.Singular(childComplexity), true

	case "CompositeResourceDefinitionSpec.claimNames":
		if e.complexity.CompositeResourceDefinitionSpec.ClaimNames == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionSpec.ClaimNames(childComplexity), true

	case "CompositeResourceDefinitionSpec.connectionSecretKeys":
		if e.complexity.CompositeResourceDefinitionSpec.ConnectionSecretKeys == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionSpec.ConnectionSecretKeys(childComplexity), true

	case "CompositeResourceDefinitionSpec.defaultComposition":
		if e.complexity.CompositeResourceDefinitionSpec.DefaultComposition == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionSpec.DefaultComposition(childComplexity), true

	case "CompositeResourceDefinitionSpec.enforcedComposition":
		if e.complexity.CompositeResourceDefinitionSpec.EnforcedComposition == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionSpec.EnforcedComposition(childComplexity), true

	case "CompositeResourceDefinitionSpec.group":
		if e.complexity.CompositeResourceDefinitionSpec.Group == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionSpec.Group(childComplexity), true

	case "CompositeResourceDefinitionSpec.names":
		if e.complexity.CompositeResourceDefinitionSpec.Names == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionSpec.Names(childComplexity), true

	case "CompositeResourceDefinitionSpec.versions":
		if e.complexity.CompositeResourceDefinitionSpec.Versions == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionSpec.Versions(childComplexity), true

	case "CompositeResourceDefinitionStatus.conditions":
		if e.complexity.CompositeResourceDefinitionStatus.Conditions == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionStatus.Conditions(childComplexity), true

	case "CompositeResourceDefinitionStatus.controllers":
		if e.complexity.CompositeResourceDefinitionStatus.Controllers == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionStatus.Controllers(childComplexity), true

	case "CompositeResourceDefinitionVersion.name":
		if e.complexity.CompositeResourceDefinitionVersion.Name == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionVersion.Name(childComplexity), true

	case "CompositeResourceDefinitionVersion.referenceable":
		if e.complexity.CompositeResourceDefinitionVersion.Referenceable == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionVersion.Referenceable(childComplexity), true

	case "CompositeResourceDefinitionVersion.schema":
		if e.complexity.CompositeResourceDefinitionVersion.Schema == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionVersion.Schema(childComplexity), true

	case "CompositeResourceDefinitionVersion.served":
		if e.complexity.CompositeResourceDefinitionVersion.Served == nil {
			break
		}

		return e.complexity.CompositeResourceDefinitionVersion.Served(childComplexity), true

	case "CompositeResourceSpec.claim":
		if e.complexity.CompositeResourceSpec.Claim == nil {
			break
		}

		return e.complexity.CompositeResourceSpec.Claim(childComplexity), true

	case "CompositeResourceSpec.claimRef":
		if e.complexity.CompositeResourceSpec.ClaimRef == nil {
			break
		}

		return e.complexity.CompositeResourceSpec.ClaimRef(childComplexity), true

	case "CompositeResourceSpec.composition":
		if e.complexity.CompositeResourceSpec.Composition == nil {
			break
		}

		return e.complexity.CompositeResourceSpec.Composition(childComplexity), true

	case "CompositeResourceSpec.compositionRef":
		if e.complexity.CompositeResourceSpec.CompositionRef == nil {
			break
		}

		return e.complexity.CompositeResourceSpec.CompositionRef(childComplexity), true

	case "CompositeResourceSpec.compositionSelector":
		if e.complexity.CompositeResourceSpec.CompositionSelector == nil {
			break
		}

		return e.complexity.CompositeResourceSpec.CompositionSelector(childComplexity), true

	case "CompositeResourceSpec.connectionSecret":
		if e.complexity.CompositeResourceSpec.ConnectionSecret == nil {
			break
		}

		return e.complexity.CompositeResourceSpec.ConnectionSecret(childComplexity), true

	case "CompositeResourceSpec.resourceRefs":
		if e.complexity.CompositeResourceSpec.ResourceRefs == nil {
			break
		}

		return e.complexity.CompositeResourceSpec.ResourceRefs(childComplexity), true

	case "CompositeResourceSpec.resources":
		if e.complexity.CompositeResourceSpec.Resources == nil {
			break
		}

		return e.complexity.CompositeResourceSpec.Resources(childComplexity), true

	case "CompositeResourceSpec.writeConnectionSecretToReference":
		if e.complexity.CompositeResourceSpec.WriteConnectionSecretToReference == nil {
			break
		}

		return e.complexity.CompositeResourceSpec.WriteConnectionSecretToReference(childComplexity), true

	case "CompositeResourceStatus.conditions":
		if e.complexity.CompositeResourceStatus.Conditions == nil {
			break
		}

		return e.complexity.CompositeResourceStatus.Conditions(childComplexity), true

	case "CompositeResourceStatus.connectionDetails":
		if e.complexity.CompositeResourceStatus.ConnectionDetails == nil {
			break
		}

		return e.complexity.CompositeResourceStatus.ConnectionDetails(childComplexity), true

	case "CompositeResourceValidation.openAPIV3Schema":
		if e.complexity.CompositeResourceValidation.OpenAPIV3Schema == nil {
			break
		}

		return e.complexity.CompositeResourceValidation.OpenAPIV3Schema(childComplexity), true

	case "Composition.apiVersion":
		if e.complexity.Composition.APIVersion == nil {
			break
		}

		return e.complexity.Composition.APIVersion(childComplexity), true

	case "Composition.events":
		if e.complexity.Composition.Events == nil {
			break
		}

		return e.complexity.Composition.Events(childComplexity), true

	case "Composition.fieldPath":
		if e.complexity.Composition.FieldPath == nil {
			break
		}

		args, err := ec.field_Composition_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Composition.FieldPath(childComplexity, args["path"].(*string)), true

	case "Composition.id":
		if e.complexity.Composition.ID == nil {
			break
		}

		return e.complexity.Composition.ID(childComplexity), true

	case "Composition.kind":
		if e.complexity.Composition.Kind == nil {
			break
		}

		return e.complexity.Composition.Kind(childComplexity), true

	case "Composition.metadata":
		if e.complexity.Composition.Metadata == nil {
			break
		}

		return e.complexity.Composition.Metadata(childComplexity), true

	case "Composition.spec":
		if e.complexity.Composition.Spec == nil {
			break
		}

		return e.complexity.Composition.Spec(childComplexity), true

	case "Composition.status":
		if e.complexity.Composition.Status == nil {
			break
		}

		return e.complexity.Composition.Status(childComplexity), true

	case "Composition.unstructured":
		if e.complexity.Composition.Unstructured == nil {
			break
		}

		return e.complexity.Composition.Unstructured(childComplexity), true

	case "CompositionConnection.nodes":
		if e.complexity.CompositionConnection.Nodes == nil {
			break
		}

		return e.complexity.CompositionConnection.Nodes(childComplexity), true

	case "CompositionConnection.totalCount":
		if e.complexity.CompositionConnection.TotalCount == nil {
			break
		}

		return e.complexity.CompositionConnection.TotalCount(childComplexity), true

	case "CompositionSpec.compositeTypeRef":
		if e.complexity.CompositionSpec.CompositeTypeRef == nil {
			break
		}

		return e.complexity.CompositionSpec.CompositeTypeRef(childComplexity), true

	case "CompositionSpec.writeConnectionSecretsToNamespace":
		if e.complexity.CompositionSpec.WriteConnectionSecretsToNamespace == nil {
			break
		}

		return e.complexity.CompositionSpec.WriteConnectionSecretsToNamespace(childComplexity), true

	case "CompositionStatus.conditions":
		if e.complexity.CompositionStatus.Conditions == nil {
			break
		}

		return e.complexity.CompositionStatus.Conditions(childComplexity), true

	case "Condition.lastTransitionTime":
		if e.complexity.Condition.LastTransitionTime == nil {
			break
		}

		return e.complexity.Condition.LastTransitionTime(childComplexity), true

	case "Condition.message":
		if e.complexity.Condition.Message == nil {
			break
		}

		return e.complexity.Condition.Message(childComplexity), true

	case "Condition.reason":
		if e.complexity.Condition.Reason == nil {
			break
		}

		return e.complexity.Condition.Reason(childComplexity), true

	case "Condition.status":
		if e.complexity.Condition.Status == nil {
			break
		}

		return e.complexity.Condition.Status(childComplexity), true

	case "Condition.type":
		if e.complexity.Condition.Type == nil {
			break
		}

		return e.complexity.Condition.Type(childComplexity), true

	case "ConfigMap.apiVersion":
		if e.complexity.ConfigMap.APIVersion == nil {
			break
		}

		return e.complexity.ConfigMap.APIVersion(childComplexity), true

	case "ConfigMap.data":
		if e.complexity.ConfigMap.Data == nil {
			break
		}

		args, err := ec.field_ConfigMap_data_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ConfigMap.Data(childComplexity, args["keys"].([]string)), true

	case "ConfigMap.events":
		if e.complexity.ConfigMap.Events == nil {
			break
		}

		return e.complexity.ConfigMap.Events(childComplexity), true

	case "ConfigMap.fieldPath":
		if e.complexity.ConfigMap.FieldPath == nil {
			break
		}

		args, err := ec.field_ConfigMap_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ConfigMap.FieldPath(childComplexity, args["path"].(*string)), true

	case "ConfigMap.id":
		if e.complexity.ConfigMap.ID == nil {
			break
		}

		return e.complexity.ConfigMap.ID(childComplexity), true

	case "ConfigMap.kind":
		if e.complexity.ConfigMap.Kind == nil {
			break
		}

		return e.complexity.ConfigMap.Kind(childComplexity), true

	case "ConfigMap.metadata":
		if e.complexity.ConfigMap.Metadata == nil {
			break
		}

		return e.complexity.ConfigMap.Metadata(childComplexity), true

	case "ConfigMap.unstructured":
		if e.complexity.ConfigMap.Unstructured == nil {
			break
		}

		return e.complexity.ConfigMap.Unstructured(childComplexity), true

	case "Configuration.apiVersion":
		if e.complexity.Configuration.APIVersion == nil {
			break
		}

		return e.complexity.Configuration.APIVersion(childComplexity), true

	case "Configuration.activeRevision":
		if e.complexity.Configuration.ActiveRevision == nil {
			break
		}

		return e.complexity.Configuration.ActiveRevision(childComplexity), true

	case "Configuration.events":
		if e.complexity.Configuration.Events == nil {
			break
		}

		return e.complexity.Configuration.Events(childComplexity), true

	case "Configuration.fieldPath":
		if e.complexity.Configuration.FieldPath == nil {
			break
		}

		args, err := ec.field_Configuration_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Configuration.FieldPath(childComplexity, args["path"].(*string)), true

	case "Configuration.id":
		if e.complexity.Configuration.ID == nil {
			break
		}

		return e.complexity.Configuration.ID(childComplexity), true

	case "Configuration.kind":
		if e.complexity.Configuration.Kind == nil {
			break
		}

		return e.complexity.Configuration.Kind(childComplexity), true

	case "Configuration.metadata":
		if e.complexity.Configuration.Metadata == nil {
			break
		}

		return e.complexity.Configuration.Metadata(childComplexity), true

	case "Configuration.revisions":
		if e.complexity.Configuration.Revisions == nil {
			break
		}

		return e.complexity.Configuration.Revisions(childComplexity), true

	case "Configuration.spec":
		if e.complexity.Configuration.Spec == nil {
			break
		}

		return e.complexity.Configuration.Spec(childComplexity), true

	case "Configuration.status":
		if e.complexity.Configuration.Status == nil {
			break
		}

		return e.complexity.Configuration.Status(childComplexity), true

	case "Configuration.unstructured":
		if e.complexity.Configuration.Unstructured == nil {
			break
		}

		return e.complexity.Configuration.Unstructured(childComplexity), true

	case "ConfigurationConnection.nodes":
		if e.complexity.ConfigurationConnection.Nodes == nil {
			break
		}

		return e.complexity.ConfigurationConnection.Nodes(childComplexity), true

	case "ConfigurationConnection.totalCount":
		if e.complexity.ConfigurationConnection.TotalCount == nil {
			break
		}

		return e.complexity.ConfigurationConnection.TotalCount(childComplexity), true

	case "ConfigurationRevision.apiVersion":
		if e.complexity.ConfigurationRevision.APIVersion == nil {
			break
		}

		return e.complexity.ConfigurationRevision.APIVersion(childComplexity), true

	case "ConfigurationRevision.events":
		if e.complexity.ConfigurationRevision.Events == nil {
			break
		}

		return e.complexity.ConfigurationRevision.Events(childComplexity), true

	case "ConfigurationRevision.fieldPath":
		if e.complexity.ConfigurationRevision.FieldPath == nil {
			break
		}

		args, err := ec.field_ConfigurationRevision_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ConfigurationRevision.FieldPath(childComplexity, args["path"].(*string)), true

	case "ConfigurationRevision.id":
		if e.complexity.ConfigurationRevision.ID == nil {
			break
		}

		return e.complexity.ConfigurationRevision.ID(childComplexity), true

	case "ConfigurationRevision.kind":
		if e.complexity.ConfigurationRevision.Kind == nil {
			break
		}

		return e.complexity.ConfigurationRevision.Kind(childComplexity), true

	case "ConfigurationRevision.metadata":
		if e.complexity.ConfigurationRevision.Metadata == nil {
			break
		}

		return e.complexity.ConfigurationRevision.Metadata(childComplexity), true

	case "ConfigurationRevision.spec":
		if e.complexity.ConfigurationRevision.Spec == nil {
			break
		}

		return e.complexity.ConfigurationRevision.Spec(childComplexity), true

	case "ConfigurationRevision.status":
		if e.complexity.ConfigurationRevision.Status == nil {
			break
		}

		return e.complexity.ConfigurationRevision.Status(childComplexity), true

	case "ConfigurationRevision.unstructured":
		if e.complexity.ConfigurationRevision.Unstructured == nil {
			break
		}

		return e.complexity.ConfigurationRevision.Unstructured(childComplexity), true

	case "ConfigurationRevisionConnection.nodes":
		if e.complexity.ConfigurationRevisionConnection.Nodes == nil {
			break
		}

		return e.complexity.ConfigurationRevisionConnection.Nodes(childComplexity), true

	case "ConfigurationRevisionConnection.totalCount":
		if e.complexity.ConfigurationRevisionConnection.TotalCount == nil {
			break
		}

		return e.complexity.ConfigurationRevisionConnection.TotalCount(childComplexity), true

	case "ConfigurationRevisionSpec.desiredState":
		if e.complexity.ConfigurationRevisionSpec.DesiredState == nil {
			break
		}

		return e.complexity.ConfigurationRevisionSpec.DesiredState(childComplexity), true

	case "ConfigurationRevisionSpec.ignoreCrossplaneConstraints":
		if e.complexity.ConfigurationRevisionSpec.IgnoreCrossplaneConstraints == nil {
			break
		}

		return e.complexity.ConfigurationRevisionSpec.IgnoreCrossplaneConstraints(childComplexity), true

	case "ConfigurationRevisionSpec.package":
		if e.complexity.ConfigurationRevisionSpec.Package == nil {
			break
		}

		return e.complexity.ConfigurationRevisionSpec.Package(childComplexity), true

	case "ConfigurationRevisionSpec.packagePullPolicy":
		if e.complexity.ConfigurationRevisionSpec.PackagePullPolicy == nil {
			break
		}

		return e.complexity.ConfigurationRevisionSpec.PackagePullPolicy(childComplexity), true

	case "ConfigurationRevisionSpec.revision":
		if e.complexity.ConfigurationRevisionSpec.Revision == nil {
			break
		}

		return e.complexity.ConfigurationRevisionSpec.Revision(childComplexity), true

	case "ConfigurationRevisionSpec.skipDependencyResolution":
		if e.complexity.ConfigurationRevisionSpec.SkipDependencyResolution == nil {
			break
		}

		return e.complexity.ConfigurationRevisionSpec.SkipDependencyResolution(childComplexity), true

	case "ConfigurationRevisionStatus.conditions":
		if e.complexity.ConfigurationRevisionStatus.Conditions == nil {
			break
		}

		return e.complexity.ConfigurationRevisionStatus.Conditions(childComplexity), true

	case "ConfigurationRevisionStatus.foundDependencies":
		if e.complexity.ConfigurationRevisionStatus.FoundDependencies == nil {
			break
		}

		return e.complexity.ConfigurationRevisionStatus.FoundDependencies(childComplexity), true

	case "ConfigurationRevisionStatus.installedDependencies":
		if e.complexity.ConfigurationRevisionStatus.InstalledDependencies == nil {
			break
		}

		return e.complexity.ConfigurationRevisionStatus.InstalledDependencies(childComplexity), true

	case "ConfigurationRevisionStatus.invalidDependencies":
		if e.complexity.ConfigurationRevisionStatus.InvalidDependencies == nil {
			break
		}

		return e.complexity.ConfigurationRevisionStatus.InvalidDependencies(childComplexity), true

	case "ConfigurationRevisionStatus.objects":
		if e.complexity.ConfigurationRevisionStatus.Objects == nil {
			break
		}

		return e.complexity.ConfigurationRevisionStatus.Objects(childComplexity), true

	case "ConfigurationRevisionStatus.permissionRequests":
		if e.complexity.ConfigurationRevisionStatus.PermissionRequests == nil {
			break
		}

		return e.complexity.ConfigurationRevisionStatus.PermissionRequests(childComplexity), true

	case "ConfigurationSpec.ignoreCrossplaneConstraints":
		if e.complexity.ConfigurationSpec.IgnoreCrossplaneConstraints == nil {
			break
		}

		return e.complexity.ConfigurationSpec.IgnoreCrossplaneConstraints(childComplexity), true

	case "ConfigurationSpec.package":
		if e.complexity.ConfigurationSpec.Package == nil {
			break
		}

		return e.complexity.ConfigurationSpec.Package(childComplexity), true

	case "ConfigurationSpec.packagePullPolicy":
		if e.complexity.ConfigurationSpec.PackagePullPolicy == nil {
			break
		}

		return e.complexity.ConfigurationSpec.PackagePullPolicy(childComplexity), true

	case "ConfigurationSpec.revisionActivationPolicy":
		if e.complexity.ConfigurationSpec.RevisionActivationPolicy == nil {
			break
		}

		return e.complexity.ConfigurationSpec.RevisionActivationPolicy(childComplexity), true

	case "ConfigurationSpec.revisionHistoryLimit":
		if e.complexity.ConfigurationSpec.RevisionHistoryLimit == nil {
			break
		}

		return e.complexity.ConfigurationSpec.RevisionHistoryLimit(childComplexity), true

	case "ConfigurationSpec.skipDependencyResolution":
		if e.complexity.ConfigurationSpec.SkipDependencyResolution == nil {
			break
		}

		return e.complexity.ConfigurationSpec.SkipDependencyResolution(childComplexity), true

	case "ConfigurationStatus.conditions":
		if e.complexity.ConfigurationStatus.Conditions == nil {
			break
		}

		return e.complexity.ConfigurationStatus.Conditions(childComplexity), true

	case "ConfigurationStatus.currentIdentifier":
		if e.complexity.ConfigurationStatus.CurrentIdentifier == nil {
			break
		}

		return e.complexity.ConfigurationStatus.CurrentIdentifier(childComplexity), true

	case "ConfigurationStatus.currentRevision":
		if e.complexity.ConfigurationStatus.CurrentRevision == nil {
			break
		}

		return e.complexity.ConfigurationStatus.CurrentRevision(childComplexity), true

	case "CreateKubernetesResourcePayload.resource":
		if e.complexity.CreateKubernetesResourcePayload.Resource == nil {
			break
		}

		return e.complexity.CreateKubernetesResourcePayload.Resource(childComplexity), true

	case "CrossplaneResourceTreeConnection.nodes":
		if e.complexity.CrossplaneResourceTreeConnection.Nodes == nil {
			break
		}

		return e.complexity.CrossplaneResourceTreeConnection.Nodes(childComplexity), true

	case "CrossplaneResourceTreeConnection.totalCount":
		if e.complexity.CrossplaneResourceTreeConnection.TotalCount == nil {
			break
		}

		return e.complexity.CrossplaneResourceTreeConnection.TotalCount(childComplexity), true

	case "CrossplaneResourceTreeNode.parentId":
		if e.complexity.CrossplaneResourceTreeNode.ParentID == nil {
			break
		}

		return e.complexity.CrossplaneResourceTreeNode.ParentID(childComplexity), true

	case "CrossplaneResourceTreeNode.resource":
		if e.complexity.CrossplaneResourceTreeNode.Resource == nil {
			break
		}

		return e.complexity.CrossplaneResourceTreeNode.Resource(childComplexity), true

	case "CustomResourceDefinition.apiVersion":
		if e.complexity.CustomResourceDefinition.APIVersion == nil {
			break
		}

		return e.complexity.CustomResourceDefinition.APIVersion(childComplexity), true

	case "CustomResourceDefinition.definedResources":
		if e.complexity.CustomResourceDefinition.DefinedResources == nil {
			break
		}

		args, err := ec.field_CustomResourceDefinition_definedResources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CustomResourceDefinition.DefinedResources(childComplexity, args["version"].(*string)), true

	case "CustomResourceDefinition.events":
		if e.complexity.CustomResourceDefinition.Events == nil {
			break
		}

		return e.complexity.CustomResourceDefinition.Events(childComplexity), true

	case "CustomResourceDefinition.fieldPath":
		if e.complexity.CustomResourceDefinition.FieldPath == nil {
			break
		}

		args, err := ec.field_CustomResourceDefinition_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CustomResourceDefinition.FieldPath(childComplexity, args["path"].(*string)), true

	case "CustomResourceDefinition.id":
		if e.complexity.CustomResourceDefinition.ID == nil {
			break
		}

		return e.complexity.CustomResourceDefinition.ID(childComplexity), true

	case "CustomResourceDefinition.kind":
		if e.complexity.CustomResourceDefinition.Kind == nil {
			break
		}

		return e.complexity.CustomResourceDefinition.Kind(childComplexity), true

	case "CustomResourceDefinition.metadata":
		if e.complexity.CustomResourceDefinition.Metadata == nil {
			break
		}

		return e.complexity.CustomResourceDefinition.Metadata(childComplexity), true

	case "CustomResourceDefinition.spec":
		if e.complexity.CustomResourceDefinition.Spec == nil {
			break
		}

		return e.complexity.CustomResourceDefinition.Spec(childComplexity), true

	case "CustomResourceDefinition.status":
		if e.complexity.CustomResourceDefinition.Status == nil {
			break
		}

		return e.complexity.CustomResourceDefinition.Status(childComplexity), true

	case "CustomResourceDefinition.unstructured":
		if e.complexity.CustomResourceDefinition.Unstructured == nil {
			break
		}

		return e.complexity.CustomResourceDefinition.Unstructured(childComplexity), true

	case "CustomResourceDefinitionConnection.nodes":
		if e.complexity.CustomResourceDefinitionConnection.Nodes == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionConnection.Nodes(childComplexity), true

	case "CustomResourceDefinitionConnection.totalCount":
		if e.complexity.CustomResourceDefinitionConnection.TotalCount == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionConnection.TotalCount(childComplexity), true

	case "CustomResourceDefinitionNames.categories":
		if e.complexity.CustomResourceDefinitionNames.Categories == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionNames.Categories(childComplexity), true

	case "CustomResourceDefinitionNames.kind":
		if e.complexity.CustomResourceDefinitionNames.Kind == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionNames.Kind(childComplexity), true

	case "CustomResourceDefinitionNames.listKind":
		if e.complexity.CustomResourceDefinitionNames.ListKind == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionNames.ListKind(childComplexity), true

	case "CustomResourceDefinitionNames.plural":
		if e.complexity.CustomResourceDefinitionNames.Plural == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionNames.Plural(childComplexity), true

	case "CustomResourceDefinitionNames.shortNames":
		if e.complexity.CustomResourceDefinitionNames.ShortNames == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionNames.ShortNames(childComplexity), true

	case "CustomResourceDefinitionNames.singular":
		if e.complexity.CustomResourceDefinitionNames.Singular == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionNames.Singular(childComplexity), true

	case "CustomResourceDefinitionSpec.group":
		if e.complexity.CustomResourceDefinitionSpec.Group == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionSpec.Group(childComplexity), true

	case "CustomResourceDefinitionSpec.names":
		if e.complexity.CustomResourceDefinitionSpec.Names == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionSpec.Names(childComplexity), true

	case "CustomResourceDefinitionSpec.scope":
		if e.complexity.CustomResourceDefinitionSpec.Scope == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionSpec.Scope(childComplexity), true

	case "CustomResourceDefinitionSpec.versions":
		if e.complexity.CustomResourceDefinitionSpec.Versions == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionSpec.Versions(childComplexity), true

	case "CustomResourceDefinitionStatus.conditions":
		if e.complexity.CustomResourceDefinitionStatus.Conditions == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionStatus.Conditions(childComplexity), true

	case "CustomResourceDefinitionVersion.name":
		if e.complexity.CustomResourceDefinitionVersion.Name == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionVersion.Name(childComplexity), true

	case "CustomResourceDefinitionVersion.schema":
		if e.complexity.CustomResourceDefinitionVersion.Schema == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionVersion.Schema(childComplexity), true

	case "CustomResourceDefinitionVersion.served":
		if e.complexity.CustomResourceDefinitionVersion.Served == nil {
			break
		}

		return e.complexity.CustomResourceDefinitionVersion.Served(childComplexity), true

	case "CustomResourceValidation.openAPIV3Schema":
		if e.complexity.CustomResourceValidation.OpenAPIV3Schema == nil {
			break
		}

		return e.complexity.CustomResourceValidation.OpenAPIV3Schema(childComplexity), true

	case "DeleteKubernetesResourcePayload.resource":
		if e.complexity.DeleteKubernetesResourcePayload.Resource == nil {
			break
		}

		return e.complexity.DeleteKubernetesResourcePayload.Resource(childComplexity), true

	case "Event.apiVersion":
		if e.complexity.Event.APIVersion == nil {
			break
		}

		return e.complexity.Event.APIVersion(childComplexity), true

	case "Event.count":
		if e.complexity.Event.Count == nil {
			break
		}

		return e.complexity.Event.Count(childComplexity), true

	case "Event.fieldPath":
		if e.complexity.Event.FieldPath == nil {
			break
		}

		args, err := ec.field_Event_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Event.FieldPath(childComplexity, args["path"].(*string)), true

	case "Event.firstTime":
		if e.complexity.Event.FirstTime == nil {
			break
		}

		return e.complexity.Event.FirstTime(childComplexity), true

	case "Event.id":
		if e.complexity.Event.ID == nil {
			break
		}

		return e.complexity.Event.ID(childComplexity), true

	case "Event.involvedObject":
		if e.complexity.Event.InvolvedObject == nil {
			break
		}

		return e.complexity.Event.InvolvedObject(childComplexity), true

	case "Event.kind":
		if e.complexity.Event.Kind == nil {
			break
		}

		return e.complexity.Event.Kind(childComplexity), true

	case "Event.lastTime":
		if e.complexity.Event.LastTime == nil {
			break
		}

		return e.complexity.Event.LastTime(childComplexity), true

	case "Event.message":
		if e.complexity.Event.Message == nil {
			break
		}

		return e.complexity.Event.Message(childComplexity), true

	case "Event.metadata":
		if e.complexity.Event.Metadata == nil {
			break
		}

		return e.complexity.Event.Metadata(childComplexity), true

	case "Event.reason":
		if e.complexity.Event.Reason == nil {
			break
		}

		return e.complexity.Event.Reason(childComplexity), true

	case "Event.source":
		if e.complexity.Event.Source == nil {
			break
		}

		return e.complexity.Event.Source(childComplexity), true

	case "Event.type":
		if e.complexity.Event.Type == nil {
			break
		}

		return e.complexity.Event.Type(childComplexity), true

	case "Event.unstructured":
		if e.complexity.Event.Unstructured == nil {
			break
		}

		return e.complexity.Event.Unstructured(childComplexity), true

	case "EventConnection.nodes":
		if e.complexity.EventConnection.Nodes == nil {
			break
		}

		return e.complexity.EventConnection.Nodes(childComplexity), true

	case "EventConnection.totalCount":
		if e.complexity.EventConnection.TotalCount == nil {
			break
		}

		return e.complexity.EventConnection.TotalCount(childComplexity), true

	case "EventSource.component":
		if e.complexity.EventSource.Component == nil {
			break
		}

		return e.complexity.EventSource.Component(childComplexity), true

	case "GenericResource.apiVersion":
		if e.complexity.GenericResource.APIVersion == nil {
			break
		}

		return e.complexity.GenericResource.APIVersion(childComplexity), true

	case "GenericResource.events":
		if e.complexity.GenericResource.Events == nil {
			break
		}

		return e.complexity.GenericResource.Events(childComplexity), true

	case "GenericResource.fieldPath":
		if e.complexity.GenericResource.FieldPath == nil {
			break
		}

		args, err := ec.field_GenericResource_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GenericResource.FieldPath(childComplexity, args["path"].(*string)), true

	case "GenericResource.id":
		if e.complexity.GenericResource.ID == nil {
			break
		}

		return e.complexity.GenericResource.ID(childComplexity), true

	case "GenericResource.kind":
		if e.complexity.GenericResource.Kind == nil {
			break
		}

		return e.complexity.GenericResource.Kind(childComplexity), true

	case "GenericResource.metadata":
		if e.complexity.GenericResource.Metadata == nil {
			break
		}

		return e.complexity.GenericResource.Metadata(childComplexity), true

	case "GenericResource.unstructured":
		if e.complexity.GenericResource.Unstructured == nil {
			break
		}

		return e.complexity.GenericResource.Unstructured(childComplexity), true

	case "KubernetesResourceConnection.nodes":
		if e.complexity.KubernetesResourceConnection.Nodes == nil {
			break
		}

		return e.complexity.KubernetesResourceConnection.Nodes(childComplexity), true

	case "KubernetesResourceConnection.totalCount":
		if e.complexity.KubernetesResourceConnection.TotalCount == nil {
			break
		}

		return e.complexity.KubernetesResourceConnection.TotalCount(childComplexity), true

	case "LabelSelector.matchLabels":
		if e.complexity.LabelSelector.MatchLabels == nil {
			break
		}

		return e.complexity.LabelSelector.MatchLabels(childComplexity), true

	case "LocalObjectReference.name":
		if e.complexity.LocalObjectReference.Name == nil {
			break
		}

		return e.complexity.LocalObjectReference.Name(childComplexity), true

	case "ManagedResource.apiVersion":
		if e.complexity.ManagedResource.APIVersion == nil {
			break
		}

		return e.complexity.ManagedResource.APIVersion(childComplexity), true

	case "ManagedResource.definition":
		if e.complexity.ManagedResource.Definition == nil {
			break
		}

		return e.complexity.ManagedResource.Definition(childComplexity), true

	case "ManagedResource.events":
		if e.complexity.ManagedResource.Events == nil {
			break
		}

		return e.complexity.ManagedResource.Events(childComplexity), true

	case "ManagedResource.fieldPath":
		if e.complexity.ManagedResource.FieldPath == nil {
			break
		}

		args, err := ec.field_ManagedResource_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ManagedResource.FieldPath(childComplexity, args["path"].(*string)), true

	case "ManagedResource.id":
		if e.complexity.ManagedResource.ID == nil {
			break
		}

		return e.complexity.ManagedResource.ID(childComplexity), true

	case "ManagedResource.kind":
		if e.complexity.ManagedResource.Kind == nil {
			break
		}

		return e.complexity.ManagedResource.Kind(childComplexity), true

	case "ManagedResource.metadata":
		if e.complexity.ManagedResource.Metadata == nil {
			break
		}

		return e.complexity.ManagedResource.Metadata(childComplexity), true

	case "ManagedResource.spec":
		if e.complexity.ManagedResource.Spec == nil {
			break
		}

		return e.complexity.ManagedResource.Spec(childComplexity), true

	case "ManagedResource.status":
		if e.complexity.ManagedResource.Status == nil {
			break
		}

		return e.complexity.ManagedResource.Status(childComplexity), true

	case "ManagedResource.unstructured":
		if e.complexity.ManagedResource.Unstructured == nil {
			break
		}

		return e.complexity.ManagedResource.Unstructured(childComplexity), true

	case "ManagedResourceSpec.connectionSecret":
		if e.complexity.ManagedResourceSpec.ConnectionSecret == nil {
			break
		}

		return e.complexity.ManagedResourceSpec.ConnectionSecret(childComplexity), true

	case "ManagedResourceSpec.deletionPolicy":
		if e.complexity.ManagedResourceSpec.DeletionPolicy == nil {
			break
		}

		return e.complexity.ManagedResourceSpec.DeletionPolicy(childComplexity), true

	case "ManagedResourceSpec.providerConfigRef":
		if e.complexity.ManagedResourceSpec.ProviderConfigRef == nil {
			break
		}

		return e.complexity.ManagedResourceSpec.ProviderConfigRef(childComplexity), true

	case "ManagedResourceStatus.conditions":
		if e.complexity.ManagedResourceStatus.Conditions == nil {
			break
		}

		return e.complexity.ManagedResourceStatus.Conditions(childComplexity), true

	case "Mutation.createKubernetesResource":
		if e.complexity.Mutation.CreateKubernetesResource == nil {
			break
		}

		args, err := ec.field_Mutation_createKubernetesResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateKubernetesResource(childComplexity, args["input"].(model.CreateKubernetesResourceInput)), true

	case "Mutation.deleteKubernetesResource":
		if e.complexity.Mutation.DeleteKubernetesResource == nil {
			break
		}

		args, err := ec.field_Mutation_deleteKubernetesResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteKubernetesResource(childComplexity, args["id"].(model.ReferenceID)), true

	case "Mutation.updateKubernetesResource":
		if e.complexity.Mutation.UpdateKubernetesResource == nil {
			break
		}

		args, err := ec.field_Mutation_updateKubernetesResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateKubernetesResource(childComplexity, args["id"].(model.ReferenceID), args["input"].(model.UpdateKubernetesResourceInput)), true

	case "ObjectMeta.annotations":
		if e.complexity.ObjectMeta.Annotations == nil {
			break
		}

		args, err := ec.field_ObjectMeta_annotations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ObjectMeta.Annotations(childComplexity, args["keys"].([]string)), true

	case "ObjectMeta.controller":
		if e.complexity.ObjectMeta.Controller == nil {
			break
		}

		return e.complexity.ObjectMeta.Controller(childComplexity), true

	case "ObjectMeta.creationTime":
		if e.complexity.ObjectMeta.CreationTime == nil {
			break
		}

		return e.complexity.ObjectMeta.CreationTime(childComplexity), true

	case "ObjectMeta.deletionTime":
		if e.complexity.ObjectMeta.DeletionTime == nil {
			break
		}

		return e.complexity.ObjectMeta.DeletionTime(childComplexity), true

	case "ObjectMeta.generateName":
		if e.complexity.ObjectMeta.GenerateName == nil {
			break
		}

		return e.complexity.ObjectMeta.GenerateName(childComplexity), true

	case "ObjectMeta.generation":
		if e.complexity.ObjectMeta.Generation == nil {
			break
		}

		return e.complexity.ObjectMeta.Generation(childComplexity), true

	case "ObjectMeta.labels":
		if e.complexity.ObjectMeta.Labels == nil {
			break
		}

		args, err := ec.field_ObjectMeta_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ObjectMeta.Labels(childComplexity, args["keys"].([]string)), true

	case "ObjectMeta.name":
		if e.complexity.ObjectMeta.Name == nil {
			break
		}

		return e.complexity.ObjectMeta.Name(childComplexity), true

	case "ObjectMeta.namespace":
		if e.complexity.ObjectMeta.Namespace == nil {
			break
		}

		return e.complexity.ObjectMeta.Namespace(childComplexity), true

	case "ObjectMeta.owners":
		if e.complexity.ObjectMeta.Owners == nil {
			break
		}

		return e.complexity.ObjectMeta.Owners(childComplexity), true

	case "ObjectMeta.resourceVersion":
		if e.complexity.ObjectMeta.ResourceVersion == nil {
			break
		}

		return e.complexity.ObjectMeta.ResourceVersion(childComplexity), true

	case "ObjectMeta.uid":
		if e.complexity.ObjectMeta.UID == nil {
			break
		}

		return e.complexity.ObjectMeta.UID(childComplexity), true

	case "ObjectReference.kind":
		if e.complexity.ObjectReference.Kind == nil {
			break
		}

		return e.complexity.ObjectReference.Kind(childComplexity), true

	case "ObjectReference.name":
		if e.complexity.ObjectReference.Name == nil {
			break
		}

		return e.complexity.ObjectReference.Name(childComplexity), true

	case "ObjectReference.namespace":
		if e.complexity.ObjectReference.Namespace == nil {
			break
		}

		return e.complexity.ObjectReference.Namespace(childComplexity), true

	case "Owner.controller":
		if e.complexity.Owner.Controller == nil {
			break
		}

		return e.complexity.Owner.Controller(childComplexity), true

	case "Owner.resource":
		if e.complexity.Owner.Resource == nil {
			break
		}

		return e.complexity.Owner.Resource(childComplexity), true

	case "OwnerConnection.nodes":
		if e.complexity.OwnerConnection.Nodes == nil {
			break
		}

		return e.complexity.OwnerConnection.Nodes(childComplexity), true

	case "OwnerConnection.totalCount":
		if e.complexity.OwnerConnection.TotalCount == nil {
			break
		}

		return e.complexity.OwnerConnection.TotalCount(childComplexity), true

	case "PolicyRule.apiGroups":
		if e.complexity.PolicyRule.APIGroups == nil {
			break
		}

		return e.complexity.PolicyRule.APIGroups(childComplexity), true

	case "PolicyRule.nonResourceURLs":
		if e.complexity.PolicyRule.NonResourceURLs == nil {
			break
		}

		return e.complexity.PolicyRule.NonResourceURLs(childComplexity), true

	case "PolicyRule.resourceNames":
		if e.complexity.PolicyRule.ResourceNames == nil {
			break
		}

		return e.complexity.PolicyRule.ResourceNames(childComplexity), true

	case "PolicyRule.resources":
		if e.complexity.PolicyRule.Resources == nil {
			break
		}

		return e.complexity.PolicyRule.Resources(childComplexity), true

	case "PolicyRule.verbs":
		if e.complexity.PolicyRule.Verbs == nil {
			break
		}

		return e.complexity.PolicyRule.Verbs(childComplexity), true

	case "Provider.apiVersion":
		if e.complexity.Provider.APIVersion == nil {
			break
		}

		return e.complexity.Provider.APIVersion(childComplexity), true

	case "Provider.activeRevision":
		if e.complexity.Provider.ActiveRevision == nil {
			break
		}

		return e.complexity.Provider.ActiveRevision(childComplexity), true

	case "Provider.events":
		if e.complexity.Provider.Events == nil {
			break
		}

		return e.complexity.Provider.Events(childComplexity), true

	case "Provider.fieldPath":
		if e.complexity.Provider.FieldPath == nil {
			break
		}

		args, err := ec.field_Provider_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Provider.FieldPath(childComplexity, args["path"].(*string)), true

	case "Provider.id":
		if e.complexity.Provider.ID == nil {
			break
		}

		return e.complexity.Provider.ID(childComplexity), true

	case "Provider.kind":
		if e.complexity.Provider.Kind == nil {
			break
		}

		return e.complexity.Provider.Kind(childComplexity), true

	case "Provider.metadata":
		if e.complexity.Provider.Metadata == nil {
			break
		}

		return e.complexity.Provider.Metadata(childComplexity), true

	case "Provider.revisions":
		if e.complexity.Provider.Revisions == nil {
			break
		}

		return e.complexity.Provider.Revisions(childComplexity), true

	case "Provider.spec":
		if e.complexity.Provider.Spec == nil {
			break
		}

		return e.complexity.Provider.Spec(childComplexity), true

	case "Provider.status":
		if e.complexity.Provider.Status == nil {
			break
		}

		return e.complexity.Provider.Status(childComplexity), true

	case "Provider.unstructured":
		if e.complexity.Provider.Unstructured == nil {
			break
		}

		return e.complexity.Provider.Unstructured(childComplexity), true

	case "ProviderConfig.apiVersion":
		if e.complexity.ProviderConfig.APIVersion == nil {
			break
		}

		return e.complexity.ProviderConfig.APIVersion(childComplexity), true

	case "ProviderConfig.definition":
		if e.complexity.ProviderConfig.Definition == nil {
			break
		}

		return e.complexity.ProviderConfig.Definition(childComplexity), true

	case "ProviderConfig.events":
		if e.complexity.ProviderConfig.Events == nil {
			break
		}

		return e.complexity.ProviderConfig.Events(childComplexity), true

	case "ProviderConfig.fieldPath":
		if e.complexity.ProviderConfig.FieldPath == nil {
			break
		}

		args, err := ec.field_ProviderConfig_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProviderConfig.FieldPath(childComplexity, args["path"].(*string)), true

	case "ProviderConfig.id":
		if e.complexity.ProviderConfig.ID == nil {
			break
		}

		return e.complexity.ProviderConfig.ID(childComplexity), true

	case "ProviderConfig.kind":
		if e.complexity.ProviderConfig.Kind == nil {
			break
		}

		return e.complexity.ProviderConfig.Kind(childComplexity), true

	case "ProviderConfig.metadata":
		if e.complexity.ProviderConfig.Metadata == nil {
			break
		}

		return e.complexity.ProviderConfig.Metadata(childComplexity), true

	case "ProviderConfig.status":
		if e.complexity.ProviderConfig.Status == nil {
			break
		}

		return e.complexity.ProviderConfig.Status(childComplexity), true

	case "ProviderConfig.unstructured":
		if e.complexity.ProviderConfig.Unstructured == nil {
			break
		}

		return e.complexity.ProviderConfig.Unstructured(childComplexity), true

	case "ProviderConfigReference.name":
		if e.complexity.ProviderConfigReference.Name == nil {
			break
		}

		return e.complexity.ProviderConfigReference.Name(childComplexity), true

	case "ProviderConfigStatus.conditions":
		if e.complexity.ProviderConfigStatus.Conditions == nil {
			break
		}

		return e.complexity.ProviderConfigStatus.Conditions(childComplexity), true

	case "ProviderConfigStatus.users":
		if e.complexity.ProviderConfigStatus.Users == nil {
			break
		}

		return e.complexity.ProviderConfigStatus.Users(childComplexity), true

	case "ProviderConnection.nodes":
		if e.complexity.ProviderConnection.Nodes == nil {
			break
		}

		return e.complexity.ProviderConnection.Nodes(childComplexity), true

	case "ProviderConnection.totalCount":
		if e.complexity.ProviderConnection.TotalCount == nil {
			break
		}

		return e.complexity.ProviderConnection.TotalCount(childComplexity), true

	case "ProviderRevision.apiVersion":
		if e.complexity.ProviderRevision.APIVersion == nil {
			break
		}

		return e.complexity.ProviderRevision.APIVersion(childComplexity), true

	case "ProviderRevision.events":
		if e.complexity.ProviderRevision.Events == nil {
			break
		}

		return e.complexity.ProviderRevision.Events(childComplexity), true

	case "ProviderRevision.fieldPath":
		if e.complexity.ProviderRevision.FieldPath == nil {
			break
		}

		args, err := ec.field_ProviderRevision_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProviderRevision.FieldPath(childComplexity, args["path"].(*string)), true

	case "ProviderRevision.id":
		if e.complexity.ProviderRevision.ID == nil {
			break
		}

		return e.complexity.ProviderRevision.ID(childComplexity), true

	case "ProviderRevision.kind":
		if e.complexity.ProviderRevision.Kind == nil {
			break
		}

		return e.complexity.ProviderRevision.Kind(childComplexity), true

	case "ProviderRevision.metadata":
		if e.complexity.ProviderRevision.Metadata == nil {
			break
		}

		return e.complexity.ProviderRevision.Metadata(childComplexity), true

	case "ProviderRevision.spec":
		if e.complexity.ProviderRevision.Spec == nil {
			break
		}

		return e.complexity.ProviderRevision.Spec(childComplexity), true

	case "ProviderRevision.status":
		if e.complexity.ProviderRevision.Status == nil {
			break
		}

		return e.complexity.ProviderRevision.Status(childComplexity), true

	case "ProviderRevision.unstructured":
		if e.complexity.ProviderRevision.Unstructured == nil {
			break
		}

		return e.complexity.ProviderRevision.Unstructured(childComplexity), true

	case "ProviderRevisionConnection.nodes":
		if e.complexity.ProviderRevisionConnection.Nodes == nil {
			break
		}

		return e.complexity.ProviderRevisionConnection.Nodes(childComplexity), true

	case "ProviderRevisionConnection.totalCount":
		if e.complexity.ProviderRevisionConnection.TotalCount == nil {
			break
		}

		return e.complexity.ProviderRevisionConnection.TotalCount(childComplexity), true

	case "ProviderRevisionSpec.desiredState":
		if e.complexity.ProviderRevisionSpec.DesiredState == nil {
			break
		}

		return e.complexity.ProviderRevisionSpec.DesiredState(childComplexity), true

	case "ProviderRevisionSpec.ignoreCrossplaneConstraints":
		if e.complexity.ProviderRevisionSpec.IgnoreCrossplaneConstraints == nil {
			break
		}

		return e.complexity.ProviderRevisionSpec.IgnoreCrossplaneConstraints(childComplexity), true

	case "ProviderRevisionSpec.package":
		if e.complexity.ProviderRevisionSpec.Package == nil {
			break
		}

		return e.complexity.ProviderRevisionSpec.Package(childComplexity), true

	case "ProviderRevisionSpec.packagePullPolicy":
		if e.complexity.ProviderRevisionSpec.PackagePullPolicy == nil {
			break
		}

		return e.complexity.ProviderRevisionSpec.PackagePullPolicy(childComplexity), true

	case "ProviderRevisionSpec.revision":
		if e.complexity.ProviderRevisionSpec.Revision == nil {
			break
		}

		return e.complexity.ProviderRevisionSpec.Revision(childComplexity), true

	case "ProviderRevisionSpec.skipDependencyResolution":
		if e.complexity.ProviderRevisionSpec.SkipDependencyResolution == nil {
			break
		}

		return e.complexity.ProviderRevisionSpec.SkipDependencyResolution(childComplexity), true

	case "ProviderRevisionStatus.conditions":
		if e.complexity.ProviderRevisionStatus.Conditions == nil {
			break
		}

		return e.complexity.ProviderRevisionStatus.Conditions(childComplexity), true

	case "ProviderRevisionStatus.foundDependencies":
		if e.complexity.ProviderRevisionStatus.FoundDependencies == nil {
			break
		}

		return e.complexity.ProviderRevisionStatus.FoundDependencies(childComplexity), true

	case "ProviderRevisionStatus.installedDependencies":
		if e.complexity.ProviderRevisionStatus.InstalledDependencies == nil {
			break
		}

		return e.complexity.ProviderRevisionStatus.InstalledDependencies(childComplexity), true

	case "ProviderRevisionStatus.invalidDependencies":
		if e.complexity.ProviderRevisionStatus.InvalidDependencies == nil {
			break
		}

		return e.complexity.ProviderRevisionStatus.InvalidDependencies(childComplexity), true

	case "ProviderRevisionStatus.objects":
		if e.complexity.ProviderRevisionStatus.Objects == nil {
			break
		}

		return e.complexity.ProviderRevisionStatus.Objects(childComplexity), true

	case "ProviderRevisionStatus.permissionRequests":
		if e.complexity.ProviderRevisionStatus.PermissionRequests == nil {
			break
		}

		return e.complexity.ProviderRevisionStatus.PermissionRequests(childComplexity), true

	case "ProviderSpec.ignoreCrossplaneConstraints":
		if e.complexity.ProviderSpec.IgnoreCrossplaneConstraints == nil {
			break
		}

		return e.complexity.ProviderSpec.IgnoreCrossplaneConstraints(childComplexity), true

	case "ProviderSpec.package":
		if e.complexity.ProviderSpec.Package == nil {
			break
		}

		return e.complexity.ProviderSpec.Package(childComplexity), true

	case "ProviderSpec.packagePullPolicy":
		if e.complexity.ProviderSpec.PackagePullPolicy == nil {
			break
		}

		return e.complexity.ProviderSpec.PackagePullPolicy(childComplexity), true

	case "ProviderSpec.revisionActivationPolicy":
		if e.complexity.ProviderSpec.RevisionActivationPolicy == nil {
			break
		}

		return e.complexity.ProviderSpec.RevisionActivationPolicy(childComplexity), true

	case "ProviderSpec.revisionHistoryLimit":
		if e.complexity.ProviderSpec.RevisionHistoryLimit == nil {
			break
		}

		return e.complexity.ProviderSpec.RevisionHistoryLimit(childComplexity), true

	case "ProviderSpec.skipDependencyResolution":
		if e.complexity.ProviderSpec.SkipDependencyResolution == nil {
			break
		}

		return e.complexity.ProviderSpec.SkipDependencyResolution(childComplexity), true

	case "ProviderStatus.conditions":
		if e.complexity.ProviderStatus.Conditions == nil {
			break
		}

		return e.complexity.ProviderStatus.Conditions(childComplexity), true

	case "ProviderStatus.currentIdentifier":
		if e.complexity.ProviderStatus.CurrentIdentifier == nil {
			break
		}

		return e.complexity.ProviderStatus.CurrentIdentifier(childComplexity), true

	case "ProviderStatus.currentRevision":
		if e.complexity.ProviderStatus.CurrentRevision == nil {
			break
		}

		return e.complexity.ProviderStatus.CurrentRevision(childComplexity), true

	case "Query.compositeResourceDefinitions":
		if e.complexity.Query.CompositeResourceDefinitions == nil {
			break
		}

		args, err := ec.field_Query_compositeResourceDefinitions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CompositeResourceDefinitions(childComplexity, args["revision"].(*model.ReferenceID), args["dangling"].(*bool)), true

	case "Query.compositions":
		if e.complexity.Query.Compositions == nil {
			break
		}

		args, err := ec.field_Query_compositions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Compositions(childComplexity, args["revision"].(*model.ReferenceID), args["dangling"].(*bool)), true

	case "Query.configMap":
		if e.complexity.Query.ConfigMap == nil {
			break
		}

		args, err := ec.field_Query_configMap_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConfigMap(childComplexity, args["namespace"].(string), args["name"].(string)), true

	case "Query.configurationRevisions":
		if e.complexity.Query.ConfigurationRevisions == nil {
			break
		}

		args, err := ec.field_Query_configurationRevisions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConfigurationRevisions(childComplexity, args["configuration"].(*model.ReferenceID), args["active"].(*bool)), true

	case "Query.configurations":
		if e.complexity.Query.Configurations == nil {
			break
		}

		return e.complexity.Query.Configurations(childComplexity), true

	case "Query.crossplaneResourceTree":
		if e.complexity.Query.CrossplaneResourceTree == nil {
			break
		}

		args, err := ec.field_Query_crossplaneResourceTree_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrossplaneResourceTree(childComplexity, args["id"].(model.ReferenceID)), true

	case "Query.customResourceDefinitions":
		if e.complexity.Query.CustomResourceDefinitions == nil {
			break
		}

		args, err := ec.field_Query_customResourceDefinitions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CustomResourceDefinitions(childComplexity, args["revision"].(*model.ReferenceID)), true

	case "Query.events":
		if e.complexity.Query.Events == nil {
			break
		}

		args, err := ec.field_Query_events_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Events(childComplexity, args["involved"].(*model.ReferenceID)), true

	case "Query.kubernetesResource":
		if e.complexity.Query.KubernetesResource == nil {
			break
		}

		args, err := ec.field_Query_kubernetesResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.KubernetesResource(childComplexity, args["id"].(model.ReferenceID)), true

	case "Query.kubernetesResources":
		if e.complexity.Query.KubernetesResources == nil {
			break
		}

		args, err := ec.field_Query_kubernetesResources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.KubernetesResources(childComplexity, args["apiVersion"].(string), args["kind"].(string), args["listKind"].(*string), args["namespace"].(*string)), true

	case "Query.providerRevisions":
		if e.complexity.Query.ProviderRevisions == nil {
			break
		}

		args, err := ec.field_Query_providerRevisions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProviderRevisions(childComplexity, args["provider"].(*model.ReferenceID), args["active"].(*bool)), true

	case "Query.providers":
		if e.complexity.Query.Providers == nil {
			break
		}

		return e.complexity.Query.Providers(childComplexity), true

	case "Query.secret":
		if e.complexity.Query.Secret == nil {
			break
		}

		args, err := ec.field_Query_secret_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Secret(childComplexity, args["namespace"].(string), args["name"].(string)), true

	case "Secret.apiVersion":
		if e.complexity.Secret.APIVersion == nil {
			break
		}

		return e.complexity.Secret.APIVersion(childComplexity), true

	case "Secret.data":
		if e.complexity.Secret.Data == nil {
			break
		}

		args, err := ec.field_Secret_data_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Secret.Data(childComplexity, args["keys"].([]string)), true

	case "Secret.events":
		if e.complexity.Secret.Events == nil {
			break
		}

		return e.complexity.Secret.Events(childComplexity), true

	case "Secret.fieldPath":
		if e.complexity.Secret.FieldPath == nil {
			break
		}

		args, err := ec.field_Secret_fieldPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Secret.FieldPath(childComplexity, args["path"].(*string)), true

	case "Secret.id":
		if e.complexity.Secret.ID == nil {
			break
		}

		return e.complexity.Secret.ID(childComplexity), true

	case "Secret.kind":
		if e.complexity.Secret.Kind == nil {
			break
		}

		return e.complexity.Secret.Kind(childComplexity), true

	case "Secret.metadata":
		if e.complexity.Secret.Metadata == nil {
			break
		}

		return e.complexity.Secret.Metadata(childComplexity), true

	case "Secret.type":
		if e.complexity.Secret.Type == nil {
			break
		}

		return e.complexity.Secret.Type(childComplexity), true

	case "Secret.unstructured":
		if e.complexity.Secret.Unstructured == nil {
			break
		}

		return e.complexity.Secret.Unstructured(childComplexity), true

	case "SecretReference.name":
		if e.complexity.SecretReference.Name == nil {
			break
		}

		return e.complexity.SecretReference.Name(childComplexity), true

	case "SecretReference.namespace":
		if e.complexity.SecretReference.Namespace == nil {
			break
		}

		return e.complexity.SecretReference.Namespace(childComplexity), true

	case "TypeReference.apiVersion":
		if e.complexity.TypeReference.APIVersion == nil {
			break
		}

		return e.complexity.TypeReference.APIVersion(childComplexity), true

	case "TypeReference.kind":
		if e.complexity.TypeReference.Kind == nil {
			break
		}

		return e.complexity.TypeReference.Kind(childComplexity), true

	case "UpdateKubernetesResourcePayload.resource":
		if e.complexity.UpdateKubernetesResourcePayload.Resource == nil {
			break
		}

		return e.complexity.UpdateKubernetesResourcePayload.Resource(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateKubernetesResourceInput,
		ec.unmarshalInputDefinedCompositeResourceClaimOptionsInput,
		ec.unmarshalInputDefinedCompositeResourceOptionsInput,
		ec.unmarshalInputPatch,
		ec.unmarshalInputUpdateKubernetesResourceInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../schema/apiextensions.gql", Input: `"""
A CompositeResourceDefinition (or XRD) defines a new kind of resource. The new
resource is composed of other composite or managed resources.
"""
type CompositeResourceDefinition implements Node & KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "The desired state of this resource."
  spec: CompositeResourceDefinitionSpec!

  "The observed state of this resource."
  status: CompositeResourceDefinitionStatus

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection! @goField(forceResolver: true)

  "The generated ` + "`" + `CustomResourceDefinition` + "`" + ` for this XRD"
  compositeResourceCRD: CustomResourceDefinition @goField(forceResolver: true)

  "The generated ` + "`" + `CustomResourceDefinition` + "`" + ` of this XRDs ` + "`" + `CompositeClaim` + "`" + ` if defined"
  compositeResourceClaimCRD: CustomResourceDefinition
    @goField(forceResolver: true)

  "Composite resources (XRs) defined by this XRD."
  definedCompositeResources(
    "Return resources of this version."
    version: String
      @deprecated(
        reason: "Use ` + "`" + `DefinedCompositeResourceOptions` + "`" + `.version instead"
      )

    "Options to filter or limit the resources"
    options: DefinedCompositeResourceOptionsInput
  ): CompositeResourceConnection! @goField(forceResolver: true)

  "Composite resource claims (XRCs) defined by this XRD."
  definedCompositeResourceClaims(
    "Return resources of this version."
    version: String
      @deprecated(
        reason: "Use ` + "`" + `DefinedCompositeResourceClaimOptions` + "`" + `.version instead"
      )

    "Return resources in this namespace."
    namespace: String
      @deprecated(
        reason: "Use ` + "`" + `DefinedCompositeResourceClaimOptions` + "`" + `.namespace instead"
      )

    "Options to filter or limit the resources"
    options: DefinedCompositeResourceClaimOptionsInput
  ): CompositeResourceClaimConnection! @goField(forceResolver: true)
}

"Options to filter or limit the defined composite resources"
input DefinedCompositeResourceOptionsInput {
  "Return resources of this version."
  version: String

  """
  Optionally limit the results to XRCs.
  If ` + "`" + `true` + "`" + ` return resources that have ` + "`" + `Condition` + "`" + ` ` + "`" + `Ready` + "`" + ` ` + "`" + `True` + "`" + `.
  If ` + "`" + `false` + "`" + ` return resources that have ` + "`" + `Condition` + "`" + ` ` + "`" + `Ready` + "`" + ` ` + "`" + `False` + "`" + ` or ` + "`" + `Condition` + "`" + ` ` + "`" + `Ready` + "`" + ` not present
  """
  ready: Boolean
}

"Options to filter or limit the defined composite claim resources"
input DefinedCompositeResourceClaimOptionsInput {
  "Return resources of this version."
  version: String

  "Return resources in this namespace."
  namespace: String

  """
  Optionally limit the results to XRCs.
  If ` + "`" + `true` + "`" + ` return resources that have ` + "`" + `Condition` + "`" + ` ` + "`" + `Ready` + "`" + ` ` + "`" + `True` + "`" + `.
  If ` + "`" + `false` + "`" + ` return resources that have ` + "`" + `Condition` + "`" + ` ` + "`" + `Ready` + "`" + ` ` + "`" + `False` + "`" + ` or ` + "`" + `Condition` + "`" + ` ` + "`" + `Ready` + "`" + ` not present
  """
  ready: Boolean
}

"""
A CompositeResourceConnection represents a connection to composite resources.
"""
type CompositeResourceConnection {
  "Connected nodes."
  nodes: [CompositeResource!]

  "The total number of connected nodes."
  totalCount: Int!
}

"""
A CompositeResourceConnection represents a connection to composite resource
claims.
"""
type CompositeResourceClaimConnection {
  "Connected nodes."
  nodes: [CompositeResourceClaim!]

  "The total number of connected nodes."
  totalCount: Int!
}

"""
A CompositeResourceDefinitionSpec represents the desired state of a composite
resource definition.
"""
type CompositeResourceDefinitionSpec {
  """
  Group specifies the API group of the defined composite resource. Composite
  resources are served under ` + "`" + `/apis/<group>/...` + "`" + `. Must match the name of the XRD
  (in the form ` + "`" + `<names.plural>.<group>` + "`" + `).
  """
  group: String!

  """
  Names specifies the resource and kind names of the defined composite resource.
  """
  names: CompositeResourceDefinitionNames!

  """
  ClaimNames specifies the names of an optional composite resource claim. When
  claim names are specified Crossplane will create a namespaced 'composite
  resource claim' CRD that corresponds to the defined composite resource. This
  composite resource claim acts as a namespaced proxy for the composite
  resource; creating, updating, or deleting the claim will create, update, or
  delete a corresponding composite resource. You may add claim names to an
  existing CompositeResourceDefinition, but they cannot be changed or removed
  once they have been set.
  """
  claimNames: CompositeResourceDefinitionNames

  """
  ConnectionSecretKeys is the list of keys that will be exposed to the end user
   of the defined kind.
  """
  connectionSecretKeys: [String!]

  """
  DefaultComposition is the Composition resource that will be used in case no
   composition selector is given.
  """
  defaultComposition: Composition @goField(forceResolver: true)

  """
  EnforcedComposition is the Composition resource that will be used by all
   composite instances whose schema is defined by this definition.
  """
  enforcedComposition: Composition @goField(forceResolver: true)

  """
  Versions is the list of all API versions of the defined composite resource.
  Version names are used to compute the order in which served versions are
  listed in API discovery. If the version string is "kube-like", it will sort
  above non "kube-like" version strings, which are ordered lexicographically.
  "Kube-like" versions start with a "v", then are followed by a number (the
  major version), then optionally the string "alpha" or "beta" and another
  number (the minor version). These are sorted first by GA > beta > alpha (where
  GA is a version with no suffix such as beta or alpha), and then by comparing
  major version, thenminor version. An example sorted list of versions: v10,
  v2, v1, v11beta2,v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10. Note
  that all versions must have identical schemas; Crossplane does not currently
  support conversion between different version schemas.
  """
  versions: [CompositeResourceDefinitionVersion!]
}

"""
CompositeResourceDefinitionNames specifies the resource and kind names of the
defined composite resource or claim.
"""
type CompositeResourceDefinitionNames {
  """
  The plural name of the resource to serve. Composite resources are served by
  the Kuberntes API under ` + "`" + `/apis/<group>/<version>/.../<plural>` + "`" + `.
  """
  plural: String!

  """
  The singular name of the resource.
  """
  singular: String

  """
  Short names for the resource, exposed in API discovery documents, and used by
  clients to support invocations like ` + "`" + `kubectl get <shortname>` + "`" + `.
  """
  shortNames: [String!]

  """
  The Kubernetes API kind of the defined resource.
  """
  kind: String!

  """
  The Kubernetes API kind of a list of the defined resource.
  """
  listKind: String

  """
  A list of grouped resources this custom resource belongs to (e.g. 'all'). This
  is published in API discovery documents, and used by clients to support
  invocations like ` + "`" + `kubectl get all` + "`" + `.
  """
  categories: [String!]
}

"""
A CompositeResourceDefinitionVersion describes a version of a composite
resource.
"""
type CompositeResourceDefinitionVersion {
  """
  Name of this version, e.g. v1, v2beta1, etc. Composite resources are
  served under this version at ` + "`" + `/apis/<group>/<version>/...` + "`" + ` if ` + "`" + `served` + "`" + ` is
  true.
  """
  name: String!

  """
  Referenceable specifies that this version may be referenced by a Composition
  in order to configure which resources an XR may be composed of. Exactly one
  version must be marked as referenceable; all Compositions must target only the
  referenceable version. The referenceable version must be served.
  """
  referenceable: Boolean!

  """
  Served specifies that this version should be served via Kubernetes REST APIs.
  """
  served: Boolean!

  """
  Schema describes the schema used for validation, pruning, and defaulting of
  this version of the defined composite resource. Fields required by all
  composite resources are injected into this schema automatically, and override
  equivalently named fields in this schema.
  """
  schema: CompositeResourceValidation
}

"""
A CompositeResourceValidation is a list of validation methods for a composite
resource.
"""
type CompositeResourceValidation {
  "OpenAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning."
  openAPIV3Schema: JSON
}

"""
A CompositeResourceDefinitionStatus represents the observed state of a composite
resource definition.
"""
type CompositeResourceDefinitionStatus implements ConditionedStatus {
  "The observed condition of this resource."
  conditions: [Condition!]

  """
  Controllers represents the status of the controllers that power this
  composite resource definition.
  """
  controllers: CompositeResourceDefinitionControllerStatus
}

"""
A CompositeResourceDefinitionControllerStatus shows the observed state of the
controllers that power the definition.
"""
type CompositeResourceDefinitionControllerStatus {
  """
  The CompositeResourceTypeRef is the type of composite resource that Crossplane
  is currently reconciling for this definition. Its version will eventually
  become consistent with the definition's referenceable version.Note that
  clients may interact with any served type; this is simply the type that
  Crossplane interacts with.
  """
  compositeResourceType: TypeReference

  """
  The CompositeResourceClaimTypeRef is the type of composite resource claim
  that Crossplane is currently reconciling for this definition. Its version
  will eventually become consistent with the definition's referenceable version.
  Note that clients may interact with any served type; this issimply the type
  that Crossplane interacts with.
  """
  compositeResourceClaimType: TypeReference
}

"""
A TypeReference references a type of Kubernetes resource by API version and
kind.
"""
type TypeReference {
  "The Kubernetes API version of the referenced resource."
  apiVersion: String!

  "The Kubernetes API kind of the referenced resource."
  kind: String!
}

"""
A Composition defines the group of resources to be created when a compatible
type of composite resource is created with reference to the composition.
"""
type Composition implements Node & KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "The desired state of this resource."
  spec: CompositionSpec!

  "The observed state of this resource."
  status: CompositionStatus

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection! @goField(forceResolver: true)
}

"""
A CompositionSpec represents the desired state of a composition.
"""
type CompositionSpec {
  """
  CompositeTypeRef specifies the type of composite resource that this
  composition is compatible with.
  """
  compositeTypeRef: TypeReference!

  """
  WriteConnectionSecretsToNamespace specifies the namespace in which the
  connection secrets of composite resource dynamically provisioned using this
  composition will be created.
  """
  writeConnectionSecretsToNamespace: String

  # TODO(negz): Model patch sets and resource templates.
}

"""
A CompositionStatus represents the observed state of a composition.
"""
type CompositionStatus implements ConditionedStatus {
  "The observed condition of this resource."
  conditions: [Condition!]
}
`, BuiltIn: false},
	{Name: "../../../schema/common.gql", Input: `"""
Time is a timestamp.
"""
scalar Time

"""
A StringMap is a 'map' of string keys to string values, i.e. an object with
string keys and string values. Note that despite this value being returned as a
'real' object (as opposed to JSON encoded as a string like JSON) this type
is still a scalar, and thus it's not possible to query at key granularity; you
always get the whole map.
"""
scalar StringMap

"""
Unstructured, schemaless JSON.
"""
scalar JSON

"""
An object with an ID.
"""
interface Node {
  "An opaque identifier that is unique across all types."
  id: ID!
}

"""
An object that corresponds to a Kubernetes API resource.
"""
interface KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection!
}

"""
An EventConnection represents a connection to events.
"""
type EventConnection {
  "Connected nodes."
  nodes: [Event!]

  "The total number of connected nodes."
  totalCount: Int!
}

"""
A KubernetesResourceConnection represents a connection to Kubernetes resources.
"""
type KubernetesResourceConnection {
  "Connected nodes."
  nodes: [KubernetesResource!]

  "The total number of connected nodes."
  totalCount: Int!
}

"""
A GenericResource represents a kind of Kubernetes resource that does not
correspond to a kind or class of resources that is more specifically modelled
by xgql.
"""
type GenericResource implements Node & KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection! @goField(forceResolver: true)
}

"""
ObjectMeta is metadata that is common to all Kubernetes API resources.
https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#objectmeta-v1-meta
"""
type ObjectMeta {
  """
  The name of this resource. Unique within its API group and version for
  cluster scoped resources, and also within its namespace for namespaced
  resources.
  """
  name: String!

  """
  An optional prefix used by the Kubernetes API server to generate a unique
  name at creation time if a name was not provided.
  """
  generateName: String

  """
  The space within each name must be unique, for namespaced resources. An empty
  namespace is equivalent to the 'default' namespace.
  """
  namespace: String

  """
  An opaque identifier of this resource that is unique across time.
  """
  uid: String!

  """
  An opaque version that changes whenever the underlying resource changes in the
  API server. Used for change detection and optimistic concurrency.
  """
  resourceVersion: String!

  """
  A sequence number representing the specific generation of the desired state.
  """
  generation: Int!

  """
  The time the underlying Kubernetes resource was created in the API server.
  """
  creationTime: Time!

  """
  The time at which the underlying Kubernetes resource will be (or was) deleted.
  Resources may exist past their deletion time while their controllers handle
  any required cleanup.
  """
  deletionTime: Time

  """
  A map of string keys and values that can be used to organize and categorize
  (scope and select) objects. May match selectors of replication controllers
  and services.

   More info: http://kubernetes.io/docs/user-guide/labels
  """
  labels("Label keys for which to return values." keys: [String!]): StringMap

  """
  A map of string keys and values that may be set by external tools to store and
  retrieve arbitrary metadata.

  More info: http://kubernetes.io/docs/user-guide/annotations
  """
  annotations(
    "Annotation keys for which to return values."
    keys: [String!]
  ): StringMap

  """
  Resources depended by this resource. If ALL resources in the list have been
  deleted, this resource will be garbage collected. If this resource is managed
  by a controller, then an entry in this list will point to this controller,
  with the controller field set to true. There cannot be more than one managing
  controller.
  """
  owners: OwnerConnection! @goField(forceResolver: true)

  """
  The controller of this resource, if any. In Kubernetes exactly one owner of a
  resource may be its "controller" - the resource that manages its lifecycle. A
  Crossplane Provider creates and manipulates ProviderRevisions and each
  ProviderRevision creates and manipulates CustomResourceDefinitions in turn. In
  this example the Provider would be the controller of its ProviderRevisions,
  and the ProviderRevisions would be the controller of their CRDs.
  """
  controller: KubernetesResource @goField(forceResolver: true)
}

"""
An OwnerConnection represents a connection to an owner.
"""
type OwnerConnection {
  "Connected nodes."
  nodes: [Owner!]
  "The total number of connected nodes."
  totalCount: Int!
}

"""
An owner of a Kubernetes resource.
"""
type Owner {
  "The owner."
  resource: KubernetesResource!

  "Whether the owner is the controller of the owned Kubernetes resource."
  controller: Boolean
}

"""
A ConditionedStatus represents the observed state of a Kubernetes resource that
exposes status conditions.
"""
interface ConditionedStatus {
  "The observed condition of this resource."
  conditions: [Condition!]
}

"""
A condition that may apply to a resource.

Note that type and reason are intentionally not enums; Crossplane does not limit
the allowed values at the API level.
"""
type Condition {
  """
  Type of this condition. At most one of each condition type may apply to a
  resource at any point in time.
  """
  type: String!

  """
  Status of this condition; is it currently True, False, or Unknown?
  """
  status: ConditionStatus!

  """
  LastTransitionTime is the last time this condition transitioned from one
  status to another.
  """
  lastTransitionTime: Time!

  """
  A Reason for this condition's last transition from one status to another.
  """
  reason: String!

  """
  A Message containing details about this condition's last transition from one
  status to another, if any.
  """
  message: String
}

"""
A ConditionStatus represensts the status of a condition.
"""
enum ConditionStatus {
  "The status of the condition is unknown."
  UNKNOWN

  "The condition is false."
  FALSE

  "The condition is true."
  TRUE
}

"""
A PolicyRule holds information that describes a KubernetesRBAC policy rule.
"""
type PolicyRule {
  """
  Verbs is a list of verbs that apply to ALL the resources specified by this
  rule. '*' represents all verbs.
  """
  verbs: [String!]!

  """
  APIGroups is the name of the APIGroup that contains the resources. If multiple
  API groups are specified, any action requested against one of the enumerated
  resources in any API group will be allowed.
  """
  apiGroups: [String!]

  """
  Resources is a list of resources this rule applies to. '*' represents all
  resources.
  """
  resources: [String!]

  """
  ResourceNames is a list of names that the rule applies to. An empty set means
  that everything is allowed.
  """
  resourceNames: [String!]

  """
  NonResourceURLs is a set of partial urls that a user should have access to.
  '*' is allowed, but only as the full, final step in the path. Rules can either
  apply to API resources (such as "pods" or "secrets") or non-resource URL paths
  (such as "/api"),  but not both.
  """
  nonResourceURLs: [String!]
}

"""
A LabelSelector matches a Kubernetes resource by labels.
"""
type LabelSelector {
  "The labels to match on."
  matchLabels: StringMap
}

# NOTE(negz): Event does not implement KubernetesResource simply because an
# event does not have events. We might consider creating a distinct
# InvolvedObject interface (or something like that) for the events field.

"""
An event pertaining to a Kubernetes resource.
"""
type Event implements Node {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "The Kubernetes resource this event pertains to."
  involvedObject: KubernetesResource! @goField(forceResolver: true)

  "The type of event."
  type: EventType

  "The reason the event was emitted."
  reason: String

  "Details about the event, if any."
  message: String

  "The source of the event - e.g. a controller."
  source: EventSource

  "The number of times this event has occurred."
  count: Int

  "The time at which this event was first recorded."
  firstTime: Time

  "The time at which this event was most recently recorded."
  lastTime: Time

  "An unstructured JSON representation of the event."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )
}

"""
An EventSource is the source of an event. Note that in this context 'source'
indicates the software or system that emitted the event, not the Kubernetes
resource it pertains to.
"""
type EventSource {
  "The software component that emitted the event."
  component: String
}

"""
An EventType indicates the type of an event.
"""
enum EventType {
  "A normal, informational event."
  NORMAL

  "A warning that something suboptimal has occurred."
  WARNING
}

"""
A Secret holds secret data.
"""
type Secret implements Node & KubernetesResource {
  """
  An opaque identifier that is unique across all types.
  """
  id: ID!

  """
  The underlying Kubernetes API version of this resource.
  """
  apiVersion: String!

  """
  The underlying Kubernetes API kind of this resource.
  """
  kind: String!

  """
  Metadata that is common to all Kubernetes API resources.
  """
  metadata: ObjectMeta!

  """
  Type of this secret.
  """
  type: String

  """
  The data stored in this secret. Values are not base64 encoded.
  """
  data("Data keys for which to return values." keys: [String!]): StringMap
    @goField(name: "data")
    @goTag(key: "json", value: "-")

  """
  An unstructured JSON representation of the underlying Kubernetes resource.
  """
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  """
  Events pertaining to this resource.
  """
  events: EventConnection! @goField(forceResolver: true)
}

"""
A ConfigMap holds configuration data.
"""
type ConfigMap implements Node & KubernetesResource {
  """
  An opaque identifier that is unique across all types.
  """
  id: ID!

  """
  The underlying Kubernetes API version of this resource.
  """
  apiVersion: String!

  """
  The underlying Kubernetes API kind of this resource.
  """
  kind: String!

  """
  Metadata that is common to all Kubernetes API resources.
  """
  metadata: ObjectMeta!

  """
  The data stored in this config map.
  """
  data("Data keys for which to return values." keys: [String!]): StringMap
    @goField(name: "data")
    @goTag(key: "json", value: "-")

  """
  An unstructured JSON representation of the underlying Kubernetes resource.
  """
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  # TODO(negz): Support binaryData too? What would the return value be?

  """
  Events pertaining to this resource.
  """
  events: EventConnection! @goField(forceResolver: true)
}

"` + "`" + `ObjectReference` + "`" + ` contains enough information to let you inspect or modify the referred object."
type ObjectReference {
  "Kind of the referent."
  kind: String

  "Namespace of the referent."
  namespace: String

  "Name of the referent."
  name: String
}

"""
` + "`" + `LocalObjectReference` + "`" + ` contains a name to to let you inspect or modify the
locally referred object.
"""
type LocalObjectReference {
  "Name of the referent."
  name: String!
}

"A ` + "`" + `SecretReference` + "`" + ` is a reference to a secret in an arbitrary namespace."
type SecretReference {
  "Name of the ` + "`" + `Secret` + "`" + `."
  name: String!

  "Namespace of the ` + "`" + `Secret` + "`" + `."
  namespace: String!
}

"""
A CustomResourceDefinition defines a type of custom resource that extends the
set of resources supported by the Kubernetes API.
"""
type CustomResourceDefinition implements Node & KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "The desired state of this resource."
  spec: CustomResourceDefinitionSpec!

  "The observed state of this resource."
  status: CustomResourceDefinitionStatus

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection! @goField(forceResolver: true)

  "Custom resources defined by this CRD"
  definedResources(
    "Return resources of this version."
    version: String
  ): KubernetesResourceConnection! @goField(forceResolver: true)
}

"""
A CustomResourceDefinitionSpec represents the desired state of a custom resource
definition.
"""
type CustomResourceDefinitionSpec {
  """
  Group specifies the API group of the defined custom resource. Custom resources
  are served under ` + "`" + `/apis/<group>/...` + "`" + `. Must match the name of the CRD (in the
  form ` + "`" + `<names.plural>.<group>` + "`" + `).
  """
  group: String!

  """
  Names specifies the resource and kind names of the defined custom resource.
  """
  names: CustomResourceDefinitionNames!

  """
  Scope of the defined custom resource.
  """
  scope: ResourceScope!

  """
  Versions is the list of all API versions of the defined custom resource.
  Version names are used to compute the order in which served versions are
  listed in API discovery. If the version string is "kube-like", it will sort
  above non "kube-like" version strings, which are ordered lexicographically.
  "Kube-like" versions start with a "v", then are followed by a number (the
  major version), then optionally the string "alpha" or "beta" and another
  number (the minor version). These are sorted first by GA > beta > alpha (where
  GA is a version with no suffix such as beta or alpha), and then by comparing
  major version, thenminor version. An example sorted list of versions: v10,
  v2, v1, v11beta2,v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
  """
  versions: [CustomResourceDefinitionVersion!]
}

"""
ResourceScope defines the scopes available to custom resources.
"""
enum ResourceScope {
  """
  Cluster scoped resources exist outside any namespace. The combination of their
  API version, kind, and name must be unique within a cluster.
  """
  CLUSTER_SCOPED

  """
  Namespace scoped resources exist within a particular namespace. The
  combination of their API version, kind, and name must be unique only within
  their namespace.
  """
  NAMESPACE_SCOPED
}

"""
CustomResourceDefinitionNames specifies the resource and kind names of the
defined custom resource.
"""
type CustomResourceDefinitionNames {
  """
  The plural name of the resource to serve. Custom resources are served by
   the Kuberntes API under ` + "`" + `/apis/<group>/<version>/.../<plural>` + "`" + `.
  """
  plural: String!

  """
  The singular name of the resource.
  """
  singular: String

  """
  Short names for the resource, exposed in API discovery documents, and used by
  clients to support invocations like ` + "`" + `kubectl get <shortname>` + "`" + `.
  """
  shortNames: [String!]

  """
  The Kubernetes API kind of the defined resource.
  """
  kind: String!

  """
  The Kubernetes API kind of a list of the defined resource.
  """
  listKind: String

  """
  A list of grouped resources this custom resource belongs to (e.g. 'all'). This
  is published in API discovery documents, and used by clients to support
  invocations like ` + "`" + `kubectl get all` + "`" + `.
  """
  categories: [String!]
}

"""
A CustomResourceDefinitionVersion describes a version of a custom resource.
"""
type CustomResourceDefinitionVersion {
  """
  Name of this version, e.g. v1, v2beta1, etc. Custom resources are served
  under this version at ` + "`" + `/apis/<group>/<version>/...` + "`" + ` if ` + "`" + `served` + "`" + ` istrue.
  """
  name: String!

  """
  Served specifies that this version should be served via Kubernetes REST APIs.
  """
  served: Boolean!

  """
  Schema describes the schema used for validation, pruning, and defaulting of
  this version of the defined custom resource.
  """
  schema: CustomResourceValidation
}

"""
A CustomResourceValidation is a list of validation methods for a custom
resource.
"""
type CustomResourceValidation {
  "OpenAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning."
  openAPIV3Schema: JSON
}

"""
A CustomResourceDefinitionStatus represents the observed state of a custom
resource definition.
"""
type CustomResourceDefinitionStatus implements ConditionedStatus {
  "The observed condition of this resource."
  conditions: [Condition!]
}
`, BuiltIn: false},
	{Name: "../../../schema/composite.gql", Input: `"""
A CompositeResource is a resource this is reconciled by composing other
composite or managed resources. Composite resources use a Composition to
determine which resources to compose, and how.
"""
type CompositeResource implements Node & KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "The desired state of this resource."
  spec: CompositeResourceSpec!

  "The observed state of this resource."
  status: CompositeResourceStatus

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection! @goField(forceResolver: true)

  "The definition of this resource."
  definition: CompositeResourceDefinition @goField(forceResolver: true)
}

"""
A CompositeResourceSpec represents the desired state of a composite resource.
"""
type CompositeResourceSpec {
  """
  The composition this composite resource uses to compose resources.
  """
  composition: Composition @goField(forceResolver: true)

  """
  The compositionRef this composite resource uses to compose resources.
  """
  compositionRef: LocalObjectReference

  """
  A composition selector is used to select this composite resource's composition
  by matching on labels.
  """
  compositionSelector: LabelSelector

  """
  The composite resource claim that claims this composite resource.
  """
  claim: CompositeResourceClaim @goField(forceResolver: true)

  "The ` + "`" + `ObjectReference` + "`" + ` for the composite resource claim that claims this composite resource"
  claimRef: ObjectReference

  """
  The secret this composite resource writes its connection details to.
  """
  connectionSecret: Secret @goField(forceResolver: true)

  """
  The ` + "`" + `ObjectReference` + "`" + `s for the resources composed by this composite resources.
  """
  resourceRefs: [ObjectReference!]!

  """
  The resources of which this composite resource is composed.
  """
  resources: KubernetesResourceConnection! @goField(forceResolver: true)

  "Reference to the secret this composite resource writes its connection details to"
  writeConnectionSecretToReference: SecretReference
}

# TODO(negz): Do we need to support GenericResource here, just in case? We only
# support managed an composite resources officially, but in practice some folks
# use arbitrary resources.

"""
A CompositeResourceClaimStatus represents the observed state of a composite
resource.
"""
type CompositeResourceStatus implements ConditionedStatus {
  "The observed condition of this resource."
  conditions: [Condition!]

  "The status of this composite resource's connection details."
  connectionDetails: CompositeResourceConnectionDetails
}

"""
CompositeResourceConnectionDetails represents the observed status of a composite
resource's connection details.
"""
type CompositeResourceConnectionDetails {
  """
  The time at which the composite resource's connection details were last
  published.
  """
  lastPublishedTime: Time
}

"""
A CompositeResourceClaim is a namespaced proxy for a composite resource.
"""
type CompositeResourceClaim implements Node & KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "The desired state of this resource."
  spec: CompositeResourceClaimSpec!

  "The observed state of this resource."
  status: CompositeResourceClaimStatus

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection! @goField(forceResolver: true)

  "The definition of this resource."
  definition: CompositeResourceDefinition @goField(forceResolver: true)
}

"""
A CompositeResourceClaimSpec represents the desired state of a composite
resource claim.
"""
type CompositeResourceClaimSpec {
  """
  The composition this composite resource claim uses to compose resources.
  """
  composition: Composition @goField(forceResolver: true)

  """
  The compositionRef this composite resource claim uses to compose resources.
  """
  compositionRef: LocalObjectReference

  """
  A composition selector is used to select this composite resource claims's
  (composite resource's) composition by matching on labels.
  """
  compositionSelector: LabelSelector

  """
  The composite resource to which this composite resource claim is bound.
  """
  resource: CompositeResource @goField(forceResolver: true)

  """
  A reference to the composite resource to which this composite resource claim is bound.
  """
  resourceRef: ObjectReference

  """
  The secret this composite resource claim writes its connection details to.
  """
  connectionSecret: Secret @goField(forceResolver: true)

  "Reference to the secret this composite resource writes its connection details to"
  writeConnectionSecretToReference: SecretReference
}

"""
A CompositeResourceClaimStatus represents the observed status of a composite
resource claim.
"""
type CompositeResourceClaimStatus implements ConditionedStatus {
  "The observed condition of this resource."
  conditions: [Condition!]

  "The status of this composite resource's connection details."
  connectionDetails: CompositeResourceClaimConnectionDetails
}

"""
CompositeResourceConnectionDetails represents the observed status of a composite
resource claim's connection details.
"""
type CompositeResourceClaimConnectionDetails {
  """
  The time at which the composite resource claim's connection details were last
  published.
  """
  lastPublishedTime: Time
}
`, BuiltIn: false},
	{Name: "../../../schema/configuration.gql", Input: `"""
A Configuration extends Crossplane with support for new composite resources.
"""
type Configuration implements Node & KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "The desired state of this resource."
  spec: ConfigurationSpec!

  "The observed state of this resource."
  status: ConfigurationStatus

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection! @goField(forceResolver: true)

  "Revisions of this configuration."
  revisions: ConfigurationRevisionConnection! @goField(forceResolver: true)

  "The active revision of this configuration."
  activeRevision: ConfigurationRevision @goField(forceResolver: true)
}

"""
A ConfigurationRevisionConnection represents a connection to configuration
revisions.
"""
type ConfigurationRevisionConnection {
  "Connected nodes."
  nodes: [ConfigurationRevision!]

  "The total number of connected nodes."
  totalCount: Int!
}

# TODO(negz): Include packagePullSecrets? It seems idiomatic to resolve an array
# of actual secrets, but we're missing the information required to do so and
# it's not obvious whether returning them is useful. At the Kubernetes level we
# have an array of local object references, which do not include a namespace.
# The Secrets are presumed to be read from the namespace in which Crossplane is
# running, which we do not know.

"""
A ConfigurationSpec represents the desired state of a configuration.
"""
type ConfigurationSpec {
  """
  The name of the configuration package to pull from an OCI registry.
  """
  package: String!

  """
  RevisionActivationPolicy specifies how the package controller should update
  from one revision to the next.
  """
  revisionActivationPolicy: RevisionActivationPolicy

  """
  RevisionHistoryLimit dictates how the package controller cleans up old
  inactive package revisions. Defaults to 1. Can be disabled by explicitly
  setting to 0.
  """
  revisionHistoryLimit: Int

  """
  PackagePullPolicy defines the pull policy for the package.
  """
  packagePullPolicy: PackagePullPolicy

  """
  IgnoreCrossplaneConstraints indicates to the package manager whether to honor
  Crossplane version constraints specified by the package.
  """
  ignoreCrossplaneConstraints: Boolean

  """
  SkipDependencyResolution indicates to the package manager whether to skip
  resolving dependencies for a package.
  """
  skipDependencyResolution: Boolean
}

"""
A ConfigurationRevisionStatus represents the observed state of a configuration.
"""
type ConfigurationStatus implements ConditionedStatus {
  """
  The observed condition of this resource.
  """
  conditions: [Condition!]

  """
  CurrentRevision is the name of the current package revision. It will reflect
  the most up to date revision, whether it has been activated or not.
  """
  currentRevision: String

  """
  CurrentIdentifier is the most recent package source that was used to produce a
  revision. The package manager uses this field to determine whether to check
  for package updates for a given source when packagePullPolicy is set to
  IfNotPresent.
  """
  currentIdentifier: String
}

"""
A ConfigurationRevision represents a revision or 'version' of a configuration.
"""
type ConfigurationRevision implements Node & KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "The desired state of this resource."
  spec: ConfigurationRevisionSpec!

  "The observed state of this resource."
  status: ConfigurationRevisionStatus

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection! @goField(forceResolver: true)
}

"""
A ConfigurationRevisionSpec represents the desired state of a configuration
revision.
"""
type ConfigurationRevisionSpec {
  """
  Desired state of the configuration revision.
  """
  desiredState: PackageRevisionDesiredState!

  """
  Package image used by the install pod to extract package contents.
  """
  package: String!

  """
  PackagePullPolicy defines the pull policy for the package..
  """
  packagePullPolicy: PackagePullPolicy

  """
  Revision number. Indicates when the revision will be garbage collected based
  on the configuration's RevisionHistoryLimit.
  """
  revision: Int!

  """
  IgnoreCrossplaneConstraints indicates to the package manager whether to honor
  Crossplane version constrains specified by the package.
  """
  ignoreCrossplaneConstraints: Boolean

  """
  SkipDependencyResolution indicates to the package manager whether to skip
  resolving dependencies for a package.
  """
  skipDependencyResolution: Boolean
}

"""
A ConfigurationRevisionStatus represents the observed state of a configuration
revision.
"""
type ConfigurationRevisionStatus implements ConditionedStatus {
  """
  The observed condition of this resource.
  """
  conditions: [Condition!]

  """
  The number of known dependencies.
  """
  foundDependencies: Int

  """
  The number of installed dependencies.
  """
  installedDependencies: Int

  """
  The number of invalid dependencies.
  """
  invalidDependencies: Int

  """
  Permissions requested by this configuration revision.
  """
  permissionRequests: [PolicyRule!]

  """
  Objects owned by this configuration revision - i.e. objects that were created
  by this configuration revision or that would have been created if they did
  not already exist.

  In practice these objects are currently always a CompositeResourceDefinition
  or a Composition. Crossplane lints the content of configuration packages to
  enforce this, but it's not enforced at the Kubernetes API level. We return an
  array of KubernetesResource here because doing so allows us to package
  different types in future without a breaking GraphQL schema change.
  """
  objects: KubernetesResourceConnection! @goField(forceResolver: true)
}
`, BuiltIn: false},
	{Name: "../../../schema/directives.gql", Input: `directive @goModel(
  model: String
  models: [String!]
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

directive @goField(
  forceResolver: Boolean
  name: String
  omittable: Boolean
  type: String
  embed: Boolean
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @goTag(
  key: String!
  value: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../../../schema/managed.gql", Input: `"""
A ManagedResource is a Kubernetes API representation of a resource in an
external system, such as a cloud provider's API. Crossplane providers add
support for new kinds of managed resource.
"""
type ManagedResource implements Node & KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "The desired state of this resource."
  spec: ManagedResourceSpec!

  "The observed state of this resource."
  status: ManagedResourceStatus

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection! @goField(forceResolver: true)

  "The definition of this resource."
  definition: ManagedResourceDefinition @goField(forceResolver: true)
}

"""
A ManagedResourceDefinition defines a managed resource.

At the time of writing a ManagedResourceDefinition will always be a
CustomResourceDefinition. We use a union because this may change in future per
https://github.com/crossplane/crossplane/issues/2262
"""
union ManagedResourceDefinition = CustomResourceDefinition

"""
A ManagedResourceSpec represents the desired state of a managed resource.
"""
type ManagedResourceSpec {
  """
  The secret this managed resource writes its connection details to.
  """
  connectionSecret: Secret @goField(forceResolver: true)

  """
  The provider configuration configures how this managed resource interacts
  with an external system.
  """
  providerConfigRef: ProviderConfigReference

  """
  The deletion policy specifies what will happen to the underlying external
  resource when this managed resource is deleted.
  """
  deletionPolicy: DeletionPolicy
}

"""
A reference to the ProviderConfig used by a particular managed resource.
"""
type ProviderConfigReference {
  "Name of the provider config."
  name: String!
}

"""
A DeletionPolicy specifies what will happen to the underlying external resource
when this managed resource is deleted - either "Delete" or "Orphan" the external
resource.
"""
enum DeletionPolicy {
  """
  Delete the resource from the external system when the managed resource is
  deleted.
  """
  DELETE

  """
  Leave the resource in the external system when the managed resource is
  deleted.
  """
  ORPHAN
}

"""
A ManagedResourceStatus represents the observed state of a managed resource.
"""
type ManagedResourceStatus implements ConditionedStatus {
  "The observed condition of this resource."
  conditions: [Condition!]
}
`, BuiltIn: false},
	{Name: "../../../schema/mutations.gql", Input: `"""
Mutation is the root type for GraphQL mutations.
"""
type Mutation {
  """
  Create a Kubernetes resource.
  """
  createKubernetesResource(
    "The inputs to the creation."
    input: CreateKubernetesResourceInput!
  ): CreateKubernetesResourcePayload!

  """
  Update a Kubernetes resource.
  """
  updateKubernetesResource(
    "The ID of the resource to be updated."
    id: ID!

    "The inputs to the update."
    input: UpdateKubernetesResourceInput!
  ): UpdateKubernetesResourcePayload!

  """
  Delete a Kubernetes resource.
  """
  deleteKubernetesResource(
    "The ID of the resource to be deleted."
    id: ID!
  ): DeleteKubernetesResourcePayload!

  # TODO(negz): Support strongly typed mutations for well-known types like
  # providers and configurations.
}

"""
A Patch that should be applied to an unstructured input before it is submitted.
"""
input Patch {
  """
  A field path references a field within a Kubernetes object via a simple
  string. API conventions describe the syntax as "standard JavaScript syntax for
  accessing that field, assuming the JSON object was transformed into a
  JavaScript object, without the leading dot, such as metadata.name".

  Valid examples:

  * metadata.name
  * spec.containers[0].name
  * data[.config.yml]
  * metadata.annotations['crossplane.io/external-name']
  * spec.items[0][8]
  * apiVersion
  * [42]

  Invalid examples:

  * .metadata.name - Leading period.
  * metadata..name - Double period.
  * metadata.name. - Trailing period.
  * spec.containers[] - Empty brackets.
  * spec.containers.[0].name - Period before open bracket.

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath: String!

  """
  Unstructured JSON to be patched in at the suppled field path. This could be a
  string, an object, or any other valid JSON.
  """
  unstructured: JSON!
}

"""
CreateKubernetesResourceInput is the input required to create a Kubernetes
resource.
"""
input CreateKubernetesResourceInput {
  "The Kubernetes resource to be created, as raw JSON."
  unstructured: JSON!

  "Patches that should be applied to the Kubernetes resource before creation."
  patches: [Patch!]
}

"""
CreateKubernetesResourcePayload is the result of creating a Kubernetes resource.
"""
type CreateKubernetesResourcePayload {
  "The created Kubernetes resource. Null if the create failed."
  resource: KubernetesResource
}

"""
UpdateKubernetesResourceInput is the input required to update a Kubernetes
resource.
"""
input UpdateKubernetesResourceInput {
  "The Kubernetes resource to be updated, as raw JSON."
  unstructured: JSON!

  "Patches that should be applied to the Kubernetes resource before updating."
  patches: [Patch!]
}

"""
UpdateKubernetesResourcePayload is the result of updating a Kubernetes resource.
"""
type UpdateKubernetesResourcePayload {
  "The updated Kubernetes resource. Null if the update failed."
  resource: KubernetesResource
}

"""
DeleteKubernetesResourcePayload is the result of deleting a Kubernetes resource.
"""
type DeleteKubernetesResourcePayload {
  "The deleted Kubernetes resource. Null if the delete failed."
  resource: KubernetesResource
}
`, BuiltIn: false},
	{Name: "../../../schema/package.gql", Input: `"""
A RevisionActivationPolicy indicates how a provider or configuration package
should activate its revisions.
"""
enum RevisionActivationPolicy {
  "Automatically activate package revisions."
  AUTOMATIC

  "Require a user to manually activate revisions."
  MANUAL
}

"""
A PackagePullPolicy represents when to pull a package OCI image from a registry.
"""
enum PackagePullPolicy {
  "Always pull the package image, even if it is already present."
  ALWAYS

  "Never pull the package image."
  NEVER

  "Only pull the package image if it is not present."
  IF_NOT_PRESENT
}

"""
A PackageRevisionDesiredState represents the desired state of a provider or
configuration revision.
"""
enum PackageRevisionDesiredState {
  "The revision should be inactive."
  INACTIVE

  "The revision should be active."
  ACTIVE
}
`, BuiltIn: false},
	{Name: "../../../schema/provider.gql", Input: `"""
A Provider extends Crossplane with support for new managed resources.
"""
type Provider implements Node & KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "The desired state of this resource."
  spec: ProviderSpec!

  "The observed state of this resource."
  status: ProviderStatus

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection! @goField(forceResolver: true)

  "Revisions of this provider."
  revisions: ProviderRevisionConnection! @goField(forceResolver: true)

  "The active revision of this provider."
  activeRevision: ProviderRevision @goField(forceResolver: true)
}

"""
A ProviderRevisionConnection represents a connection to provider revisions.
"""
type ProviderRevisionConnection {
  "Connected nodes."
  nodes: [ProviderRevision!]

  "The total number of connected nodes."
  totalCount: Int!
}

# TODO(negz): Include packagePullSecrets? It seems idiomatic to resolve an array
# of actual secrets, but we're missing the information required to do so and
# it's not obvious whether returning them is useful. At the Kubernetes level we
# have an array of local object references, which do not include a namespace.
# The Secrets are presumed to be read from the namespace in which Crossplane is
# running, which we do not know.

"""
A ProviderSpec represents the desired state of a provider.
"""
type ProviderSpec {
  """
  The name of the provider package to pull from an OCI registry.
  """
  package: String!

  """
  RevisionActivationPolicy specifies how the package controller should update
  from one revision to the next.
  """
  revisionActivationPolicy: RevisionActivationPolicy

  """
  RevisionHistoryLimit dictates how the package controller cleans up old
  inactive package revisions. Defaults to 1. Can be disabled by explicitly
  setting to 0.
  """
  revisionHistoryLimit: Int

  """
  PackagePullPolicy defines the pull policy for the package.
  """
  packagePullPolicy: PackagePullPolicy

  """
  IgnoreCrossplaneConstraints indicates to the package manager whether to honor
  Crossplane version constraints specified by the package.
  """
  ignoreCrossplaneConstraints: Boolean

  """
  SkipDependencyResolution indicates to the package manager whether to skip
  resolving dependencies for a package.
  """
  skipDependencyResolution: Boolean
}

"""
A ProviderStatus represents the observed state of a provider.
"""
type ProviderStatus implements ConditionedStatus {
  """
  The observed condition of this resource.
  """
  conditions: [Condition!]

  """
  CurrentRevision is the name of the current package revision. It will reflect
  the most up to date revision, whether it has been activated or not.
  """
  currentRevision: String

  """
  CurrentIdentifier is the most recent package source that was used to produce a
  revision. The package manager uses this field to determine whether to check
  for package updates for a given source when packagePullPolicy is set to
  IfNotPresent.
  """
  currentIdentifier: String
}

"""
A ProviderRevision represents a revision or 'version' of a provider.
"""
type ProviderRevision implements Node & KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "The desired state of this resource."
  spec: ProviderRevisionSpec!

  "The observed state of this resource."
  status: ProviderRevisionStatus

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection! @goField(forceResolver: true)
}

"""
A ProviderRevisionSpec represents the desired state of a provider revision.
"""
type ProviderRevisionSpec {
  """
  Desired state of the provider revision.
  """
  desiredState: PackageRevisionDesiredState!

  """
  Package image used by the install pod to extract package contents.
  """
  package: String!

  """
  PackagePullPolicy defines the pull policy for the package. It is also applied
  to any images pulled for the package, such as a provider's controller image.
  """
  packagePullPolicy: PackagePullPolicy

  """
  Revision number. Indicates when the revision will be garbage collected based
  on the configuration's RevisionHistoryLimit.
  """
  revision: Int!

  """
  IgnoreCrossplaneConstraints indicates to the package manager whether to honor
  Crossplane version constrains specified by the package.
  """
  ignoreCrossplaneConstraints: Boolean

  """
  SkipDependencyResolution indicates to the package manager whether to skip
  resolving dependencies for a package.
  """
  skipDependencyResolution: Boolean
}

"""
A ProviderRevisionStatus represents the observed state of a provider revision.
"""
type ProviderRevisionStatus implements ConditionedStatus {
  """
  The observed condition of this resource.
  """
  conditions: [Condition!]

  """
  The number of known dependencies.
  """
  foundDependencies: Int

  """
  The number of installed dependencies.
  """
  installedDependencies: Int

  """
  The number of invalid dependencies.
  """
  invalidDependencies: Int

  """
  Permissions requested by this configuration revision.
  """
  permissionRequests: [PolicyRule!]

  """
  Objects owned by this provider revision - i.e. objects that were created by
  this provider revision or that would have been created if they did not already
  exist.

  In practice these objects are currently always a CustomResourceDefinition.
  Crossplane lints the content of provider packages to enforce this, but it's
  not enforced at the Kubernetes API level. We return an array of
  KubernetesResource here because doing so allows us to package different types
  in future without a breaking GraphQL schema change.
  """
  objects: KubernetesResourceConnection! @goField(forceResolver: true)
}
`, BuiltIn: false},
	{Name: "../../../schema/providerconfig.gql", Input: `"""
A ProviderConfig configures a provider, in that it provides configuration that
is relevant to all managed resources installed by a provider.
"""
type ProviderConfig implements Node & KubernetesResource {
  "An opaque identifier that is unique across all types."
  id: ID!

  "The underlying Kubernetes API version of this resource."
  apiVersion: String!

  "The underlying Kubernetes API kind of this resource."
  kind: String!

  "Metadata that is common to all Kubernetes API resources."
  metadata: ObjectMeta!

  "The observed state of this resource."
  status: ProviderConfigStatus

  "An unstructured JSON representation of the underlying Kubernetes resource."
  unstructured: JSON!
    @deprecated(reason: "Use ` + "`" + `fieldPath` + "`" + ` instead")
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.SkipUnstructured"
      embed: true
    )

  """
  A JSON representation of a field within the underlying Kubernetes resource.

  API conventions describe the syntax as:
  > standard JavaScript syntax for accessing that field, assuming the JSON
  > object was transformed into a JavaScript object, without the leading dot,
  > such as ` + "`" + `metadata.name` + "`" + `.

  Valid examples:

  * ` + "`" + `metadata.name` + "`" + `
  * ` + "`" + `spec.containers[0].name` + "`" + `
  * ` + "`" + `data[.config.yml]` + "`" + `
  * ` + "`" + `metadata.annotations['crossplane.io/external-name']` + "`" + `
  * ` + "`" + `spec.items[0][8]` + "`" + `
  * ` + "`" + `apiVersion` + "`" + `
  * ` + "`" + `[42]` + "`" + `
  * ` + "`" + `spec.containers[*].args[*]` + "`" + ` - Supports wildcard expansion.

  Invalid examples:

  * ` + "`" + `.metadata.name` + "`" + ` - Leading period.
  * ` + "`" + `metadata..name` + "`" + ` - Double period.
  * ` + "`" + `metadata.name.` + "`" + ` - Trailing period.
  * ` + "`" + `spec.containers[]` + "`" + ` - Empty brackets.
  * ` + "`" + `spec.containers.[0].name` + "`" + ` - Period before open bracket.

  Wildcards support:

  For an object with the following data:

  ` + "`" + `` + "`" + `` + "`" + `json
  {
    "spec": {
      "containers": [
        {
          "name": "cool",
          "image": "latest",
          "args": [
            "start",
            "now",
            "debug"
          ]
        }
      ]
    }
  }
  ` + "`" + `` + "`" + `` + "`" + `

  The wildcard ` + "`" + `spec.containers[*].args[*]` + "`" + ` will be expanded to:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "spec.containers[0].args[0]",
    "spec.containers[0].args[1]",
    "spec.containers[0].args[2]",
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  And the following result will be returned:

  ` + "`" + `` + "`" + `` + "`" + `json
  [
    "start",
    "now",
    "debug"
  ]
  ` + "`" + `` + "`" + `` + "`" + `

  https://github.com/kubernetes/community/blob/61f3d0/contributors/devel/sig-architecture/api-conventions.md#selecting-fields
  """
  fieldPath(
    "A path to a field within a Kubernetes object."
    path: String
  ): JSON!
    @goField(
      type: "github.com/upbound/xgql/internal/graph/model.PavedAccess"
      embed: true
    )

  "Events pertaining to this resource."
  events: EventConnection! @goField(forceResolver: true)

  "The definition of this resource."
  definition: ProviderConfigDefinition @goField(forceResolver: true)
}

"""
A ProviderConfigDefinition defines a provider configuration.

At the time of writing a ProviderConfigDefinition will always be a
CustomResourceDefinition. We use a union because this may change in future per
https://github.com/crossplane/crossplane/issues/2262
"""
union ProviderConfigDefinition = CustomResourceDefinition

"""
A ProviderConfigStatus represents the observed state of a provider config.
"""
type ProviderConfigStatus implements ConditionedStatus {
  "The observed condition of this resource."
  conditions: [Condition!]

  "The number of managed resources currently using this provider config."
  users: Int
}
`, BuiltIn: false},
	{Name: "../../../schema/queries.gql", Input: `"""
Query is the root type for GraphQL queries.
"""
type Query {
  """
  An arbitrary Kubernetes resource. Types that are known to xgql will be
  returned appropriately (e.g. a Crossplane provider will be of the GraphQL
  Provider type). Types that are not known to xgql will be returned as a
  GenericResource.
  """
  kubernetesResource(
    "The ID of the desired resource."
    id: ID!
  ): KubernetesResource

  """
  All extant Kubernetes resources of an arbitrary type. Types that are known to
  xgql will be returned appropriately (e.g. a Crossplane provider will be of the
  GraphQL Provider type). Types that are not known to xgql will be returned as a
  GenericResource.
  """
  kubernetesResources(
    """
    API Version of the desired resource type.
    """
    apiVersion: String!

    """
    Kind of the desired resource type.
    """
    kind: String!

    """
    List kind of the desired resource type. Defaults to the supplied kind
    suffixed with 'List', which is appropriate for the vast majority of kinds.
    """
    listKind: String

    """
    Return resources from only this namespace. Has no effect on cluster scoped
    resources. Leave unset to return namespaced resources from all namespaces.
    """
    namespace: String
  ): KubernetesResourceConnection!

  """
  Kubernetes events.
  """
  events(
    "Only return events associated with the supplied ID."
    involved: ID
  ): EventConnection!

  """
  A Kubernetes secret.
  """
  secret(
    "The secret's namespace"
    namespace: String!

    "The secret's name"
    name: String!
  ): Secret

  """
  A Kubernetes config map.
  """
  configMap(
    "The config map's namespace"
    namespace: String!

    "The config map's name"
    name: String!
  ): ConfigMap

  """
  Providers that are currently installed.
  """
  providers: ProviderConnection!

  """
  Provider revisions that currently exist.
  """
  providerRevisions(
    """
    Only return revisions owned by the supplied provider.
    """
    provider: ID

    """
    Only return active provider revisions.
    """
    active: Boolean
  ): ProviderRevisionConnection!

  """
  Custom Resource Definitions (CRDs) that currently exist.
  """
  customResourceDefinitions(
    """
    Only return CRDs that are owned by the supplied provider revision.
    """
    revision: ID
  ): CustomResourceDefinitionConnection!

  """
  Configurations that are currently installed.
  """
  configurations: ConfigurationConnection!

  """
  Configuration revisions that currently exist.
  """
  configurationRevisions(
    """
    Only return revisions owned by the supplied configuration.
    """
    configuration: ID

    """
    Only return active provider revisions.
    """
    active: Boolean
  ): ConfigurationRevisionConnection!

  """
  Composite Resource Definitions (XRDs) that currently exist.
  """
  compositeResourceDefinitions(
    """
    Only return XRDs that are owned by the supplied configuration revision.
    """
    revision: ID

    """
    Only return XRDs that aren't owned by a configuration revision. Takes
    precedence over revision when both are set.
    """
    dangling: Boolean = false
  ): CompositeResourceDefinitionConnection!

  """
  Compositions that currently exist.
  """
  compositions(
    """
    Only return Compositions that are owned by the supplied configuration
    revision ID.
    """
    revision: ID

    """
    Only return Compositions that aren't owned by a configuration revision.
    Takes precedence over revision when both are set.
    """
    dangling: Boolean = false
  ): CompositionConnection!

  """
  Get an ` + "`" + `KubernetesResource` + "`" + ` and its descendants which form a tree. The two
  ` + "`" + `KubernetesResource` + "`" + `s that have descendants are ` + "`" + `CompositeResourceClaim` + "`" + ` (its
  ` + "`" + `CompositeResource` + "`" + `) and ` + "`" + `CompositeResource` + "`" + ` (the ` + "`" + `KubernetesResource` + "`" + `s it
  composes via a ` + "`" + `Composition` + "`" + `).
  """
  crossplaneResourceTree(
    "The ` + "`" + `ID` + "`" + ` of an ` + "`" + `CrossplaneResource` + "`" + `"
    id: ID!
  ): CrossplaneResourceTreeConnection!
}

"""
A ` + "`" + `CrossplaneResourceTreeConnection` + "`" + ` represents a connection to ` + "`" + `CrossplaneResourceTreeNode` + "`" + `s
"""
type CrossplaneResourceTreeConnection {
  "Connected nodes."
  nodes: [CrossplaneResourceTreeNode!]

  "The total number of connected nodes."
  totalCount: Int!
}

"""
An ` + "`" + `CrossplaneResourceTreeNode` + "`" + ` is an ` + "`" + `KubernetesResource` + "`" + ` with a ` + "`" + `ID` + "`" + ` of its parent
` + "`" + `CrossplaneResource` + "`" + `.

Note: A ` + "`" + `NULL` + "`" + ` ` + "`" + `parentId` + "`" + ` represents the root of the descendant tree.
"""
type CrossplaneResourceTreeNode {
  "The ` + "`" + `ID` + "`" + ` of the parent ` + "`" + `KubernetesResource` + "`" + ` (` + "`" + `NULL` + "`" + ` is the root of the tree)"
  parentId: ID

  "The ` + "`" + `KubernetesResource` + "`" + ` object of this ` + "`" + `CrossplaneResourceTreeNode` + "`" + `"
  resource: KubernetesResource!
}

"""
A ProviderConnection represents a connection to providers.
"""
type ProviderConnection {
  "Connected nodes."
  nodes: [Provider!]

  "The total number of connected nodes."
  totalCount: Int!
}

"""
A CustomResourceDefinitionConnection represents a connection to custom
resource definitions (CRDs).
"""
type CustomResourceDefinitionConnection {
  "Connected nodes."
  nodes: [CustomResourceDefinition!]

  "The total number of connected nodes."
  totalCount: Int!
}

"""
A ConfigurationConnection represents a connection to configurations.
"""
type ConfigurationConnection {
  "Connected nodes."
  nodes: [Configuration!]

  "The total number of connected nodes."
  totalCount: Int!
}

"""
A CompositeResourceDefinitionConnection represents a connection to composite
resource definitions (XRDs).
"""
type CompositeResourceDefinitionConnection {
  "Connected nodes."
  nodes: [CompositeResourceDefinition!]

  "The total number of connected nodes."
  totalCount: Int!
}

"""
A CompositionConnection represents a connection to compositions.
"""
type CompositionConnection {
  "Connected nodes."
  nodes: [Composition!]

  "The total number of connected nodes."
  totalCount: Int!
}
`, BuiltIn: false},
	{Name: "../../../live_query/live_query.graphql", Input: `type Subscription {
		"""
		A live query that is updated when the underlying data changes.
		First, the initial data is sent.
		Then, once the underlying data changes, the "patches" extension is updated with a list of patches to apply to the data.
		"""
		liveQuery(
			"""
			Propose a desired throttle interval ot the server to receive updates to at most once per \"throttle\" milliseconds.
			"""
			throttle: Int = 200
		): Query
	}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_CompositeResourceClaim_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_CompositeResourceDefinition_definedCompositeResourceClaims_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["version"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["version"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 *model.DefinedCompositeResourceClaimOptionsInput
	if tmp, ok := rawArgs["options"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
		arg2, err = ec.unmarshalODefinedCompositeResourceClaimOptionsInput2githubcomupboundxgqlinternalgraphmodelDefinedCompositeResourceClaimOptionsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["options"] = arg2
	return args, nil
}

func (ec *executionContext) field_CompositeResourceDefinition_definedCompositeResources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["version"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["version"] = arg0
	var arg1 *model.DefinedCompositeResourceOptionsInput
	if tmp, ok := rawArgs["options"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
		arg1, err = ec.unmarshalODefinedCompositeResourceOptionsInput2githubcomupboundxgqlinternalgraphmodelDefinedCompositeResourceOptionsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["options"] = arg1
	return args, nil
}

func (ec *executionContext) field_CompositeResourceDefinition_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_CompositeResource_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Composition_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_ConfigMap_data_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["keys"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keys"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["keys"] = arg0
	return args, nil
}

func (ec *executionContext) field_ConfigMap_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_ConfigurationRevision_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Configuration_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_CustomResourceDefinition_definedResources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["version"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["version"] = arg0
	return args, nil
}

func (ec *executionContext) field_CustomResourceDefinition_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Event_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_GenericResource_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_ManagedResource_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createKubernetesResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateKubernetesResourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateKubernetesResourceInput2githubcomupboundxgqlinternalgraphmodelCreateKubernetesResourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteKubernetesResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ReferenceID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateKubernetesResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ReferenceID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.UpdateKubernetesResourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateKubernetesResourceInput2githubcomupboundxgqlinternalgraphmodelUpdateKubernetesResourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_ObjectMeta_annotations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["keys"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keys"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["keys"] = arg0
	return args, nil
}

func (ec *executionContext) field_ObjectMeta_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["keys"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keys"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["keys"] = arg0
	return args, nil
}

func (ec *executionContext) field_ProviderConfig_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_ProviderRevision_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Provider_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_compositeResourceDefinitions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ReferenceID
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalOID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["dangling"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dangling"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dangling"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_compositions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ReferenceID
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalOID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["dangling"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dangling"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dangling"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_configMap_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_configurationRevisions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ReferenceID
	if tmp, ok := rawArgs["configuration"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configuration"))
		arg0, err = ec.unmarshalOID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["configuration"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["active"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["active"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_crossplaneResourceTree_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ReferenceID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_customResourceDefinitions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ReferenceID
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalOID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_events_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ReferenceID
	if tmp, ok := rawArgs["involved"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("involved"))
		arg0, err = ec.unmarshalOID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["involved"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_kubernetesResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ReferenceID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_kubernetesResources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["apiVersion"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiVersion"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["apiVersion"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["kind"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kind"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["kind"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["listKind"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("listKind"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["listKind"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_providerRevisions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ReferenceID
	if tmp, ok := rawArgs["provider"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
		arg0, err = ec.unmarshalOID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["provider"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["active"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["active"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_secret_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	return args, nil
}

func (ec *executionContext) field_Secret_data_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["keys"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keys"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["keys"] = arg0
	return args, nil
}

func (ec *executionContext) field_Secret_fieldPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _CompositeResource_id(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResource_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResource_kind(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResource_metadata(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResource_spec(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CompositeResourceSpec)
	fc.Result = res
	return ec.marshalNCompositeResourceSpec2githubcomupboundxgqlinternalgraphmodelCompositeResourceSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "composition":
				return ec.fieldContext_CompositeResourceSpec_composition(ctx, field)
			case "compositionRef":
				return ec.fieldContext_CompositeResourceSpec_compositionRef(ctx, field)
			case "compositionSelector":
				return ec.fieldContext_CompositeResourceSpec_compositionSelector(ctx, field)
			case "claim":
				return ec.fieldContext_CompositeResourceSpec_claim(ctx, field)
			case "claimRef":
				return ec.fieldContext_CompositeResourceSpec_claimRef(ctx, field)
			case "connectionSecret":
				return ec.fieldContext_CompositeResourceSpec_connectionSecret(ctx, field)
			case "resourceRefs":
				return ec.fieldContext_CompositeResourceSpec_resourceRefs(ctx, field)
			case "resources":
				return ec.fieldContext_CompositeResourceSpec_resources(ctx, field)
			case "writeConnectionSecretToReference":
				return ec.fieldContext_CompositeResourceSpec_writeConnectionSecretToReference(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResource_status(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResourceStatus)
	fc.Result = res
	return ec.marshalOCompositeResourceStatus2githubcomupboundxgqlinternalgraphmodelCompositeResourceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conditions":
				return ec.fieldContext_CompositeResourceStatus_conditions(ctx, field)
			case "connectionDetails":
				return ec.fieldContext_CompositeResourceStatus_connectionDetails(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResource_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResource_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CompositeResource_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResource_events(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResource().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResource_definition(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_definition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResource().Definition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResourceDefinition)
	fc.Result = res
	return ec.marshalOCompositeResourceDefinition2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_definition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CompositeResourceDefinition_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_CompositeResourceDefinition_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_CompositeResourceDefinition_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_CompositeResourceDefinition_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_CompositeResourceDefinition_spec(ctx, field)
			case "status":
				return ec.fieldContext_CompositeResourceDefinition_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_CompositeResourceDefinition_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_CompositeResourceDefinition_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_CompositeResourceDefinition_events(ctx, field)
			case "compositeResourceCRD":
				return ec.fieldContext_CompositeResourceDefinition_compositeResourceCRD(ctx, field)
			case "compositeResourceClaimCRD":
				return ec.fieldContext_CompositeResourceDefinition_compositeResourceClaimCRD(ctx, field)
			case "definedCompositeResources":
				return ec.fieldContext_CompositeResourceDefinition_definedCompositeResources(ctx, field)
			case "definedCompositeResourceClaims":
				return ec.fieldContext_CompositeResourceDefinition_definedCompositeResourceClaims(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaim_id(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaim) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaim_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaim_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaim",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaim_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaim) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaim_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaim_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaim",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaim_kind(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaim) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaim_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaim_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaim",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaim_metadata(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaim) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaim_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaim_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaim",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaim_spec(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaim) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaim_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CompositeResourceClaimSpec)
	fc.Result = res
	return ec.marshalNCompositeResourceClaimSpec2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaimSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaim_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaim",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "composition":
				return ec.fieldContext_CompositeResourceClaimSpec_composition(ctx, field)
			case "compositionRef":
				return ec.fieldContext_CompositeResourceClaimSpec_compositionRef(ctx, field)
			case "compositionSelector":
				return ec.fieldContext_CompositeResourceClaimSpec_compositionSelector(ctx, field)
			case "resource":
				return ec.fieldContext_CompositeResourceClaimSpec_resource(ctx, field)
			case "resourceRef":
				return ec.fieldContext_CompositeResourceClaimSpec_resourceRef(ctx, field)
			case "connectionSecret":
				return ec.fieldContext_CompositeResourceClaimSpec_connectionSecret(ctx, field)
			case "writeConnectionSecretToReference":
				return ec.fieldContext_CompositeResourceClaimSpec_writeConnectionSecretToReference(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceClaimSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaim_status(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaim) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaim_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResourceClaimStatus)
	fc.Result = res
	return ec.marshalOCompositeResourceClaimStatus2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaimStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaim_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaim",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conditions":
				return ec.fieldContext_CompositeResourceClaimStatus_conditions(ctx, field)
			case "connectionDetails":
				return ec.fieldContext_CompositeResourceClaimStatus_connectionDetails(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceClaimStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaim_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaim) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaim_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaim_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaim",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaim_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaim) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaim_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaim_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaim",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CompositeResourceClaim_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaim_events(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaim) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaim_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceClaim().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaim_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaim",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaim_definition(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaim) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaim_definition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceClaim().Definition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResourceDefinition)
	fc.Result = res
	return ec.marshalOCompositeResourceDefinition2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaim_definition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaim",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CompositeResourceDefinition_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_CompositeResourceDefinition_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_CompositeResourceDefinition_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_CompositeResourceDefinition_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_CompositeResourceDefinition_spec(ctx, field)
			case "status":
				return ec.fieldContext_CompositeResourceDefinition_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_CompositeResourceDefinition_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_CompositeResourceDefinition_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_CompositeResourceDefinition_events(ctx, field)
			case "compositeResourceCRD":
				return ec.fieldContext_CompositeResourceDefinition_compositeResourceCRD(ctx, field)
			case "compositeResourceClaimCRD":
				return ec.fieldContext_CompositeResourceDefinition_compositeResourceClaimCRD(ctx, field)
			case "definedCompositeResources":
				return ec.fieldContext_CompositeResourceDefinition_definedCompositeResources(ctx, field)
			case "definedCompositeResourceClaims":
				return ec.fieldContext_CompositeResourceDefinition_definedCompositeResourceClaims(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaimConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaimConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaimConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.CompositeResourceClaim)
	fc.Result = res
	return ec.marshalOCompositeResourceClaim2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaim(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaimConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaimConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CompositeResourceClaim_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_CompositeResourceClaim_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_CompositeResourceClaim_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_CompositeResourceClaim_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_CompositeResourceClaim_spec(ctx, field)
			case "status":
				return ec.fieldContext_CompositeResourceClaim_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_CompositeResourceClaim_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_CompositeResourceClaim_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_CompositeResourceClaim_events(ctx, field)
			case "definition":
				return ec.fieldContext_CompositeResourceClaim_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceClaim", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaimConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaimConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaimConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaimConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaimConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaimConnectionDetails_lastPublishedTime(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaimConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaimConnectionDetails_lastPublishedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastPublishedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaimConnectionDetails_lastPublishedTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaimConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaimSpec_composition(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaimSpec_composition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceClaimSpec().Composition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Composition)
	fc.Result = res
	return ec.marshalOComposition2githubcomupboundxgqlinternalgraphmodelComposition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaimSpec_composition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaimSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Composition_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_Composition_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_Composition_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_Composition_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_Composition_spec(ctx, field)
			case "status":
				return ec.fieldContext_Composition_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_Composition_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_Composition_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_Composition_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Composition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaimSpec_compositionRef(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaimSpec_compositionRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceClaimSpec().CompositionRef(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LocalObjectReference)
	fc.Result = res
	return ec.marshalOLocalObjectReference2githubcomupboundxgqlinternalgraphmodelLocalObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaimSpec_compositionRef(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaimSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_LocalObjectReference_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocalObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaimSpec_compositionSelector(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaimSpec_compositionSelector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompositionSelector, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LabelSelector)
	fc.Result = res
	return ec.marshalOLabelSelector2githubcomupboundxgqlinternalgraphmodelLabelSelector(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaimSpec_compositionSelector(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaimSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "matchLabels":
				return ec.fieldContext_LabelSelector_matchLabels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelSelector", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaimSpec_resource(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaimSpec_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceClaimSpec().Resource(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResource)
	fc.Result = res
	return ec.marshalOCompositeResource2githubcomupboundxgqlinternalgraphmodelCompositeResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaimSpec_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaimSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CompositeResource_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_CompositeResource_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_CompositeResource_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_CompositeResource_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_CompositeResource_spec(ctx, field)
			case "status":
				return ec.fieldContext_CompositeResource_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_CompositeResource_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_CompositeResource_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_CompositeResource_events(ctx, field)
			case "definition":
				return ec.fieldContext_CompositeResource_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaimSpec_resourceRef(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaimSpec_resourceRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceClaimSpec().ResourceRef(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObjectReference)
	fc.Result = res
	return ec.marshalOObjectReference2githubcomupboundxgqlinternalgraphmodelObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaimSpec_resourceRef(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaimSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext_ObjectReference_kind(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectReference_namespace(ctx, field)
			case "name":
				return ec.fieldContext_ObjectReference_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaimSpec_connectionSecret(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaimSpec_connectionSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceClaimSpec().ConnectionSecret(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Secret)
	fc.Result = res
	return ec.marshalOSecret2githubcomupboundxgqlinternalgraphmodelSecret(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaimSpec_connectionSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaimSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Secret_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_Secret_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_Secret_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_Secret_metadata(ctx, field)
			case "type":
				return ec.fieldContext_Secret_type(ctx, field)
			case "data":
				return ec.fieldContext_Secret_data(ctx, field)
			case "unstructured":
				return ec.fieldContext_Secret_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_Secret_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_Secret_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Secret", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaimSpec_writeConnectionSecretToReference(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaimSpec_writeConnectionSecretToReference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceClaimSpec().WriteConnectionSecretToReference(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SecretReference)
	fc.Result = res
	return ec.marshalOSecretReference2githubcomupboundxgqlinternalgraphmodelSecretReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaimSpec_writeConnectionSecretToReference(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaimSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SecretReference_name(ctx, field)
			case "namespace":
				return ec.fieldContext_SecretReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SecretReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaimStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaimStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaimStatus_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Condition)
	fc.Result = res
	return ec.marshalOCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaimStatus_conditions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaimStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_Condition_type(ctx, field)
			case "status":
				return ec.fieldContext_Condition_status(ctx, field)
			case "lastTransitionTime":
				return ec.fieldContext_Condition_lastTransitionTime(ctx, field)
			case "reason":
				return ec.fieldContext_Condition_reason(ctx, field)
			case "message":
				return ec.fieldContext_Condition_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Condition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceClaimStatus_connectionDetails(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceClaimStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceClaimStatus_connectionDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResourceClaimConnectionDetails)
	fc.Result = res
	return ec.marshalOCompositeResourceClaimConnectionDetails2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaimConnectionDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceClaimStatus_connectionDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceClaimStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lastPublishedTime":
				return ec.fieldContext_CompositeResourceClaimConnectionDetails_lastPublishedTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceClaimConnectionDetails", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.CompositeResource)
	fc.Result = res
	return ec.marshalOCompositeResource2githubcomupboundxgqlinternalgraphmodelCompositeResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CompositeResource_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_CompositeResource_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_CompositeResource_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_CompositeResource_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_CompositeResource_spec(ctx, field)
			case "status":
				return ec.fieldContext_CompositeResource_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_CompositeResource_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_CompositeResource_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_CompositeResource_events(ctx, field)
			case "definition":
				return ec.fieldContext_CompositeResource_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceConnectionDetails_lastPublishedTime(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceConnectionDetails_lastPublishedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastPublishedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceConnectionDetails_lastPublishedTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_id(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_kind(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_metadata(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_spec(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CompositeResourceDefinitionSpec)
	fc.Result = res
	return ec.marshalNCompositeResourceDefinitionSpec2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "group":
				return ec.fieldContext_CompositeResourceDefinitionSpec_group(ctx, field)
			case "names":
				return ec.fieldContext_CompositeResourceDefinitionSpec_names(ctx, field)
			case "claimNames":
				return ec.fieldContext_CompositeResourceDefinitionSpec_claimNames(ctx, field)
			case "connectionSecretKeys":
				return ec.fieldContext_CompositeResourceDefinitionSpec_connectionSecretKeys(ctx, field)
			case "defaultComposition":
				return ec.fieldContext_CompositeResourceDefinitionSpec_defaultComposition(ctx, field)
			case "enforcedComposition":
				return ec.fieldContext_CompositeResourceDefinitionSpec_enforcedComposition(ctx, field)
			case "versions":
				return ec.fieldContext_CompositeResourceDefinitionSpec_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceDefinitionSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_status(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResourceDefinitionStatus)
	fc.Result = res
	return ec.marshalOCompositeResourceDefinitionStatus2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conditions":
				return ec.fieldContext_CompositeResourceDefinitionStatus_conditions(ctx, field)
			case "controllers":
				return ec.fieldContext_CompositeResourceDefinitionStatus_controllers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceDefinitionStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CompositeResourceDefinition_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_events(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceDefinition().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_compositeResourceCRD(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_compositeResourceCRD(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceDefinition().CompositeResourceCrd(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CustomResourceDefinition)
	fc.Result = res
	return ec.marshalOCustomResourceDefinition2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_compositeResourceCRD(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CustomResourceDefinition_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_CustomResourceDefinition_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_CustomResourceDefinition_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_CustomResourceDefinition_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_CustomResourceDefinition_spec(ctx, field)
			case "status":
				return ec.fieldContext_CustomResourceDefinition_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_CustomResourceDefinition_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_CustomResourceDefinition_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_CustomResourceDefinition_events(ctx, field)
			case "definedResources":
				return ec.fieldContext_CustomResourceDefinition_definedResources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CustomResourceDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_compositeResourceClaimCRD(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_compositeResourceClaimCRD(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceDefinition().CompositeResourceClaimCrd(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CustomResourceDefinition)
	fc.Result = res
	return ec.marshalOCustomResourceDefinition2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_compositeResourceClaimCRD(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CustomResourceDefinition_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_CustomResourceDefinition_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_CustomResourceDefinition_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_CustomResourceDefinition_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_CustomResourceDefinition_spec(ctx, field)
			case "status":
				return ec.fieldContext_CustomResourceDefinition_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_CustomResourceDefinition_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_CustomResourceDefinition_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_CustomResourceDefinition_events(ctx, field)
			case "definedResources":
				return ec.fieldContext_CustomResourceDefinition_definedResources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CustomResourceDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_definedCompositeResources(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_definedCompositeResources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceDefinition().DefinedCompositeResources(rctx, obj, fc.Args["version"].(*string), fc.Args["options"].(*model.DefinedCompositeResourceOptionsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CompositeResourceConnection)
	fc.Result = res
	return ec.marshalNCompositeResourceConnection2githubcomupboundxgqlinternalgraphmodelCompositeResourceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_definedCompositeResources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_CompositeResourceConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_CompositeResourceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CompositeResourceDefinition_definedCompositeResources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinition_definedCompositeResourceClaims(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinition_definedCompositeResourceClaims(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceDefinition().DefinedCompositeResourceClaims(rctx, obj, fc.Args["version"].(*string), fc.Args["namespace"].(*string), fc.Args["options"].(*model.DefinedCompositeResourceClaimOptionsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CompositeResourceClaimConnection)
	fc.Result = res
	return ec.marshalNCompositeResourceClaimConnection2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaimConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinition_definedCompositeResourceClaims(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_CompositeResourceClaimConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_CompositeResourceClaimConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceClaimConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CompositeResourceDefinition_definedCompositeResourceClaims_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.CompositeResourceDefinition)
	fc.Result = res
	return ec.marshalOCompositeResourceDefinition2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CompositeResourceDefinition_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_CompositeResourceDefinition_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_CompositeResourceDefinition_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_CompositeResourceDefinition_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_CompositeResourceDefinition_spec(ctx, field)
			case "status":
				return ec.fieldContext_CompositeResourceDefinition_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_CompositeResourceDefinition_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_CompositeResourceDefinition_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_CompositeResourceDefinition_events(ctx, field)
			case "compositeResourceCRD":
				return ec.fieldContext_CompositeResourceDefinition_compositeResourceCRD(ctx, field)
			case "compositeResourceClaimCRD":
				return ec.fieldContext_CompositeResourceDefinition_compositeResourceClaimCRD(ctx, field)
			case "definedCompositeResources":
				return ec.fieldContext_CompositeResourceDefinition_definedCompositeResources(ctx, field)
			case "definedCompositeResourceClaims":
				return ec.fieldContext_CompositeResourceDefinition_definedCompositeResourceClaims(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionControllerStatus_compositeResourceType(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionControllerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionControllerStatus_compositeResourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompositeResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TypeReference)
	fc.Result = res
	return ec.marshalOTypeReference2githubcomupboundxgqlinternalgraphmodelTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionControllerStatus_compositeResourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionControllerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiVersion":
				return ec.fieldContext_TypeReference_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_TypeReference_kind(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypeReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionControllerStatus_compositeResourceClaimType(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionControllerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionControllerStatus_compositeResourceClaimType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompositeResourceClaimType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TypeReference)
	fc.Result = res
	return ec.marshalOTypeReference2githubcomupboundxgqlinternalgraphmodelTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionControllerStatus_compositeResourceClaimType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionControllerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiVersion":
				return ec.fieldContext_TypeReference_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_TypeReference_kind(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypeReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionNames_plural(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionNames) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionNames_plural(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plural, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionNames_plural(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionNames",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionNames_singular(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionNames) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionNames_singular(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Singular, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionNames_singular(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionNames",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionNames_shortNames(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionNames) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionNames_shortNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionNames_shortNames(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionNames",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionNames_kind(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionNames) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionNames_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionNames_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionNames",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionNames_listKind(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionNames) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionNames_listKind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ListKind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionNames_listKind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionNames",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionNames_categories(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionNames) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionNames_categories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Categories, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionNames_categories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionNames",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionSpec_group(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionSpec_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionSpec_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionSpec_names(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionSpec_names(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Names, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CompositeResourceDefinitionNames)
	fc.Result = res
	return ec.marshalNCompositeResourceDefinitionNames2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionNames(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionSpec_names(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "plural":
				return ec.fieldContext_CompositeResourceDefinitionNames_plural(ctx, field)
			case "singular":
				return ec.fieldContext_CompositeResourceDefinitionNames_singular(ctx, field)
			case "shortNames":
				return ec.fieldContext_CompositeResourceDefinitionNames_shortNames(ctx, field)
			case "kind":
				return ec.fieldContext_CompositeResourceDefinitionNames_kind(ctx, field)
			case "listKind":
				return ec.fieldContext_CompositeResourceDefinitionNames_listKind(ctx, field)
			case "categories":
				return ec.fieldContext_CompositeResourceDefinitionNames_categories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceDefinitionNames", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionSpec_claimNames(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionSpec_claimNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClaimNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResourceDefinitionNames)
	fc.Result = res
	return ec.marshalOCompositeResourceDefinitionNames2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionNames(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionSpec_claimNames(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "plural":
				return ec.fieldContext_CompositeResourceDefinitionNames_plural(ctx, field)
			case "singular":
				return ec.fieldContext_CompositeResourceDefinitionNames_singular(ctx, field)
			case "shortNames":
				return ec.fieldContext_CompositeResourceDefinitionNames_shortNames(ctx, field)
			case "kind":
				return ec.fieldContext_CompositeResourceDefinitionNames_kind(ctx, field)
			case "listKind":
				return ec.fieldContext_CompositeResourceDefinitionNames_listKind(ctx, field)
			case "categories":
				return ec.fieldContext_CompositeResourceDefinitionNames_categories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceDefinitionNames", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionSpec_connectionSecretKeys(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionSpec_connectionSecretKeys(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionSecretKeys, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionSpec_connectionSecretKeys(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionSpec_defaultComposition(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionSpec_defaultComposition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceDefinitionSpec().DefaultComposition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Composition)
	fc.Result = res
	return ec.marshalOComposition2githubcomupboundxgqlinternalgraphmodelComposition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionSpec_defaultComposition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Composition_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_Composition_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_Composition_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_Composition_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_Composition_spec(ctx, field)
			case "status":
				return ec.fieldContext_Composition_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_Composition_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_Composition_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_Composition_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Composition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionSpec_enforcedComposition(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionSpec_enforcedComposition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceDefinitionSpec().EnforcedComposition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Composition)
	fc.Result = res
	return ec.marshalOComposition2githubcomupboundxgqlinternalgraphmodelComposition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionSpec_enforcedComposition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Composition_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_Composition_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_Composition_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_Composition_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_Composition_spec(ctx, field)
			case "status":
				return ec.fieldContext_Composition_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_Composition_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_Composition_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_Composition_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Composition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionSpec_versions(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionSpec_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.CompositeResourceDefinitionVersion)
	fc.Result = res
	return ec.marshalOCompositeResourceDefinitionVersion2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionSpec_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_CompositeResourceDefinitionVersion_name(ctx, field)
			case "referenceable":
				return ec.fieldContext_CompositeResourceDefinitionVersion_referenceable(ctx, field)
			case "served":
				return ec.fieldContext_CompositeResourceDefinitionVersion_served(ctx, field)
			case "schema":
				return ec.fieldContext_CompositeResourceDefinitionVersion_schema(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceDefinitionVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionStatus_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Condition)
	fc.Result = res
	return ec.marshalOCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionStatus_conditions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_Condition_type(ctx, field)
			case "status":
				return ec.fieldContext_Condition_status(ctx, field)
			case "lastTransitionTime":
				return ec.fieldContext_Condition_lastTransitionTime(ctx, field)
			case "reason":
				return ec.fieldContext_Condition_reason(ctx, field)
			case "message":
				return ec.fieldContext_Condition_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Condition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionStatus_controllers(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionStatus_controllers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Controllers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResourceDefinitionControllerStatus)
	fc.Result = res
	return ec.marshalOCompositeResourceDefinitionControllerStatus2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionControllerStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionStatus_controllers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "compositeResourceType":
				return ec.fieldContext_CompositeResourceDefinitionControllerStatus_compositeResourceType(ctx, field)
			case "compositeResourceClaimType":
				return ec.fieldContext_CompositeResourceDefinitionControllerStatus_compositeResourceClaimType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceDefinitionControllerStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionVersion_name(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionVersion_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionVersion_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionVersion_referenceable(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionVersion_referenceable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Referenceable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionVersion_referenceable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionVersion_served(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionVersion_served(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Served, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionVersion_served(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceDefinitionVersion_schema(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceDefinitionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceDefinitionVersion_schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResourceValidation)
	fc.Result = res
	return ec.marshalOCompositeResourceValidation2githubcomupboundxgqlinternalgraphmodelCompositeResourceValidation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceDefinitionVersion_schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceDefinitionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "openAPIV3Schema":
				return ec.fieldContext_CompositeResourceValidation_openAPIV3Schema(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceValidation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceSpec_composition(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceSpec_composition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceSpec().Composition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Composition)
	fc.Result = res
	return ec.marshalOComposition2githubcomupboundxgqlinternalgraphmodelComposition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceSpec_composition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Composition_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_Composition_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_Composition_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_Composition_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_Composition_spec(ctx, field)
			case "status":
				return ec.fieldContext_Composition_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_Composition_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_Composition_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_Composition_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Composition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceSpec_compositionRef(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceSpec_compositionRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceSpec().CompositionRef(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LocalObjectReference)
	fc.Result = res
	return ec.marshalOLocalObjectReference2githubcomupboundxgqlinternalgraphmodelLocalObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceSpec_compositionRef(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_LocalObjectReference_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocalObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceSpec_compositionSelector(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceSpec_compositionSelector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompositionSelector, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LabelSelector)
	fc.Result = res
	return ec.marshalOLabelSelector2githubcomupboundxgqlinternalgraphmodelLabelSelector(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceSpec_compositionSelector(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "matchLabels":
				return ec.fieldContext_LabelSelector_matchLabels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelSelector", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceSpec_claim(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceSpec_claim(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceSpec().Claim(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResourceClaim)
	fc.Result = res
	return ec.marshalOCompositeResourceClaim2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaim(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceSpec_claim(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CompositeResourceClaim_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_CompositeResourceClaim_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_CompositeResourceClaim_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_CompositeResourceClaim_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_CompositeResourceClaim_spec(ctx, field)
			case "status":
				return ec.fieldContext_CompositeResourceClaim_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_CompositeResourceClaim_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_CompositeResourceClaim_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_CompositeResourceClaim_events(ctx, field)
			case "definition":
				return ec.fieldContext_CompositeResourceClaim_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceClaim", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceSpec_claimRef(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceSpec_claimRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceSpec().ClaimRef(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObjectReference)
	fc.Result = res
	return ec.marshalOObjectReference2githubcomupboundxgqlinternalgraphmodelObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceSpec_claimRef(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext_ObjectReference_kind(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectReference_namespace(ctx, field)
			case "name":
				return ec.fieldContext_ObjectReference_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceSpec_connectionSecret(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceSpec_connectionSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceSpec().ConnectionSecret(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Secret)
	fc.Result = res
	return ec.marshalOSecret2githubcomupboundxgqlinternalgraphmodelSecret(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceSpec_connectionSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Secret_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_Secret_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_Secret_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_Secret_metadata(ctx, field)
			case "type":
				return ec.fieldContext_Secret_type(ctx, field)
			case "data":
				return ec.fieldContext_Secret_data(ctx, field)
			case "unstructured":
				return ec.fieldContext_Secret_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_Secret_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_Secret_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Secret", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceSpec_resourceRefs(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceSpec_resourceRefs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceSpec().ResourceRefs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ObjectReference)
	fc.Result = res
	return ec.marshalNObjectReference2githubcomupboundxgqlinternalgraphmodelObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceSpec_resourceRefs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext_ObjectReference_kind(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectReference_namespace(ctx, field)
			case "name":
				return ec.fieldContext_ObjectReference_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceSpec_resources(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceSpec_resources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceSpec().Resources(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResourceConnection)
	fc.Result = res
	return ec.marshalNKubernetesResourceConnection2githubcomupboundxgqlinternalgraphmodelKubernetesResourceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceSpec_resources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_KubernetesResourceConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_KubernetesResourceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KubernetesResourceConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceSpec_writeConnectionSecretToReference(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceSpec_writeConnectionSecretToReference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CompositeResourceSpec().WriteConnectionSecretToReference(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SecretReference)
	fc.Result = res
	return ec.marshalOSecretReference2githubcomupboundxgqlinternalgraphmodelSecretReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceSpec_writeConnectionSecretToReference(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SecretReference_name(ctx, field)
			case "namespace":
				return ec.fieldContext_SecretReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SecretReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceStatus_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Condition)
	fc.Result = res
	return ec.marshalOCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceStatus_conditions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_Condition_type(ctx, field)
			case "status":
				return ec.fieldContext_Condition_status(ctx, field)
			case "lastTransitionTime":
				return ec.fieldContext_Condition_lastTransitionTime(ctx, field)
			case "reason":
				return ec.fieldContext_Condition_reason(ctx, field)
			case "message":
				return ec.fieldContext_Condition_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Condition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceStatus_connectionDetails(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceStatus_connectionDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResourceConnectionDetails)
	fc.Result = res
	return ec.marshalOCompositeResourceConnectionDetails2githubcomupboundxgqlinternalgraphmodelCompositeResourceConnectionDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceStatus_connectionDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lastPublishedTime":
				return ec.fieldContext_CompositeResourceConnectionDetails_lastPublishedTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceConnectionDetails", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResourceValidation_openAPIV3Schema(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResourceValidation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResourceValidation_openAPIV3Schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OpenAPIV3Schema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResourceValidation_openAPIV3Schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResourceValidation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Composition_id(ctx context.Context, field graphql.CollectedField, obj *model.Composition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Composition_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Composition_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Composition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Composition_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.Composition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Composition_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Composition_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Composition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Composition_kind(ctx context.Context, field graphql.CollectedField, obj *model.Composition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Composition_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Composition_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Composition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Composition_metadata(ctx context.Context, field graphql.CollectedField, obj *model.Composition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Composition_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Composition_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Composition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Composition_spec(ctx context.Context, field graphql.CollectedField, obj *model.Composition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Composition_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CompositionSpec)
	fc.Result = res
	return ec.marshalNCompositionSpec2githubcomupboundxgqlinternalgraphmodelCompositionSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Composition_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Composition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "compositeTypeRef":
				return ec.fieldContext_CompositionSpec_compositeTypeRef(ctx, field)
			case "writeConnectionSecretsToNamespace":
				return ec.fieldContext_CompositionSpec_writeConnectionSecretsToNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositionSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Composition_status(ctx context.Context, field graphql.CollectedField, obj *model.Composition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Composition_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositionStatus)
	fc.Result = res
	return ec.marshalOCompositionStatus2githubcomupboundxgqlinternalgraphmodelCompositionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Composition_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Composition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conditions":
				return ec.fieldContext_CompositionStatus_conditions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositionStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Composition_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.Composition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Composition_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Composition_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Composition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Composition_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.Composition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Composition_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Composition_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Composition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Composition_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Composition_events(ctx context.Context, field graphql.CollectedField, obj *model.Composition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Composition_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Composition().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Composition_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Composition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositionConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.CompositionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositionConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Composition)
	fc.Result = res
	return ec.marshalOComposition2githubcomupboundxgqlinternalgraphmodelComposition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositionConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Composition_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_Composition_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_Composition_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_Composition_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_Composition_spec(ctx, field)
			case "status":
				return ec.fieldContext_Composition_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_Composition_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_Composition_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_Composition_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Composition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.CompositionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositionConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositionConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositionSpec_compositeTypeRef(ctx context.Context, field graphql.CollectedField, obj *model.CompositionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositionSpec_compositeTypeRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompositeTypeRef, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TypeReference)
	fc.Result = res
	return ec.marshalNTypeReference2githubcomupboundxgqlinternalgraphmodelTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositionSpec_compositeTypeRef(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiVersion":
				return ec.fieldContext_TypeReference_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_TypeReference_kind(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypeReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositionSpec_writeConnectionSecretsToNamespace(ctx context.Context, field graphql.CollectedField, obj *model.CompositionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositionSpec_writeConnectionSecretsToNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WriteConnectionSecretsToNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositionSpec_writeConnectionSecretsToNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositionStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *model.CompositionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositionStatus_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Condition)
	fc.Result = res
	return ec.marshalOCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositionStatus_conditions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_Condition_type(ctx, field)
			case "status":
				return ec.fieldContext_Condition_status(ctx, field)
			case "lastTransitionTime":
				return ec.fieldContext_Condition_lastTransitionTime(ctx, field)
			case "reason":
				return ec.fieldContext_Condition_reason(ctx, field)
			case "message":
				return ec.fieldContext_Condition_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Condition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_type(ctx context.Context, field graphql.CollectedField, obj *model.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_status(ctx context.Context, field graphql.CollectedField, obj *model.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConditionStatus)
	fc.Result = res
	return ec.marshalNConditionStatus2githubcomupboundxgqlinternalgraphmodelConditionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConditionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_lastTransitionTime(ctx context.Context, field graphql.CollectedField, obj *model.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_lastTransitionTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastTransitionTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_lastTransitionTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_reason(ctx context.Context, field graphql.CollectedField, obj *model.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_message(ctx context.Context, field graphql.CollectedField, obj *model.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigMap_id(ctx context.Context, field graphql.CollectedField, obj *model.ConfigMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigMap_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigMap_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigMap_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.ConfigMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigMap_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigMap_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigMap_kind(ctx context.Context, field graphql.CollectedField, obj *model.ConfigMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigMap_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigMap_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigMap_metadata(ctx context.Context, field graphql.CollectedField, obj *model.ConfigMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigMap_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigMap_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigMap_data(ctx context.Context, field graphql.CollectedField, obj *model.ConfigMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigMap_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data(fc.Args["keys"].([]string)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigMap_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigMap",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ConfigMap_data_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ConfigMap_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.ConfigMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigMap_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigMap_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigMap",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigMap_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.ConfigMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigMap_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigMap_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigMap",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ConfigMap_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ConfigMap_events(ctx context.Context, field graphql.CollectedField, obj *model.ConfigMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigMap_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ConfigMap().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigMap_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigMap",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Configuration_id(ctx context.Context, field graphql.CollectedField, obj *model.Configuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Configuration_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Configuration_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Configuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Configuration_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.Configuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Configuration_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Configuration_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Configuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Configuration_kind(ctx context.Context, field graphql.CollectedField, obj *model.Configuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Configuration_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Configuration_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Configuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Configuration_metadata(ctx context.Context, field graphql.CollectedField, obj *model.Configuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Configuration_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Configuration_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Configuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Configuration_spec(ctx context.Context, field graphql.CollectedField, obj *model.Configuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Configuration_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConfigurationSpec)
	fc.Result = res
	return ec.marshalNConfigurationSpec2githubcomupboundxgqlinternalgraphmodelConfigurationSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Configuration_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Configuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "package":
				return ec.fieldContext_ConfigurationSpec_package(ctx, field)
			case "revisionActivationPolicy":
				return ec.fieldContext_ConfigurationSpec_revisionActivationPolicy(ctx, field)
			case "revisionHistoryLimit":
				return ec.fieldContext_ConfigurationSpec_revisionHistoryLimit(ctx, field)
			case "packagePullPolicy":
				return ec.fieldContext_ConfigurationSpec_packagePullPolicy(ctx, field)
			case "ignoreCrossplaneConstraints":
				return ec.fieldContext_ConfigurationSpec_ignoreCrossplaneConstraints(ctx, field)
			case "skipDependencyResolution":
				return ec.fieldContext_ConfigurationSpec_skipDependencyResolution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigurationSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Configuration_status(ctx context.Context, field graphql.CollectedField, obj *model.Configuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Configuration_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConfigurationStatus)
	fc.Result = res
	return ec.marshalOConfigurationStatus2githubcomupboundxgqlinternalgraphmodelConfigurationStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Configuration_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Configuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conditions":
				return ec.fieldContext_ConfigurationStatus_conditions(ctx, field)
			case "currentRevision":
				return ec.fieldContext_ConfigurationStatus_currentRevision(ctx, field)
			case "currentIdentifier":
				return ec.fieldContext_ConfigurationStatus_currentIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigurationStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Configuration_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.Configuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Configuration_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Configuration_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Configuration",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Configuration_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.Configuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Configuration_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Configuration_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Configuration",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Configuration_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Configuration_events(ctx context.Context, field graphql.CollectedField, obj *model.Configuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Configuration_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Configuration().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Configuration_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Configuration",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Configuration_revisions(ctx context.Context, field graphql.CollectedField, obj *model.Configuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Configuration_revisions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Configuration().Revisions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConfigurationRevisionConnection)
	fc.Result = res
	return ec.marshalNConfigurationRevisionConnection2githubcomupboundxgqlinternalgraphmodelConfigurationRevisionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Configuration_revisions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Configuration",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_ConfigurationRevisionConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_ConfigurationRevisionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigurationRevisionConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Configuration_activeRevision(ctx context.Context, field graphql.CollectedField, obj *model.Configuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Configuration_activeRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Configuration().ActiveRevision(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConfigurationRevision)
	fc.Result = res
	return ec.marshalOConfigurationRevision2githubcomupboundxgqlinternalgraphmodelConfigurationRevision(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Configuration_activeRevision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Configuration",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ConfigurationRevision_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_ConfigurationRevision_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_ConfigurationRevision_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_ConfigurationRevision_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_ConfigurationRevision_spec(ctx, field)
			case "status":
				return ec.fieldContext_ConfigurationRevision_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_ConfigurationRevision_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_ConfigurationRevision_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_ConfigurationRevision_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigurationRevision", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Configuration)
	fc.Result = res
	return ec.marshalOConfiguration2githubcomupboundxgqlinternalgraphmodelConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Configuration_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_Configuration_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_Configuration_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_Configuration_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_Configuration_spec(ctx, field)
			case "status":
				return ec.fieldContext_Configuration_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_Configuration_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_Configuration_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_Configuration_events(ctx, field)
			case "revisions":
				return ec.fieldContext_Configuration_revisions(ctx, field)
			case "activeRevision":
				return ec.fieldContext_Configuration_activeRevision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Configuration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevision_id(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevision_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevision_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevision",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevision_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevision_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevision_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevision",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevision_kind(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevision_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevision_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevision",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevision_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevision_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevision",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevision_spec(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevision_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConfigurationRevisionSpec)
	fc.Result = res
	return ec.marshalNConfigurationRevisionSpec2githubcomupboundxgqlinternalgraphmodelConfigurationRevisionSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevision_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevision",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "desiredState":
				return ec.fieldContext_ConfigurationRevisionSpec_desiredState(ctx, field)
			case "package":
				return ec.fieldContext_ConfigurationRevisionSpec_package(ctx, field)
			case "packagePullPolicy":
				return ec.fieldContext_ConfigurationRevisionSpec_packagePullPolicy(ctx, field)
			case "revision":
				return ec.fieldContext_ConfigurationRevisionSpec_revision(ctx, field)
			case "ignoreCrossplaneConstraints":
				return ec.fieldContext_ConfigurationRevisionSpec_ignoreCrossplaneConstraints(ctx, field)
			case "skipDependencyResolution":
				return ec.fieldContext_ConfigurationRevisionSpec_skipDependencyResolution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigurationRevisionSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevision_status(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevision_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConfigurationRevisionStatus)
	fc.Result = res
	return ec.marshalOConfigurationRevisionStatus2githubcomupboundxgqlinternalgraphmodelConfigurationRevisionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevision_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevision",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conditions":
				return ec.fieldContext_ConfigurationRevisionStatus_conditions(ctx, field)
			case "foundDependencies":
				return ec.fieldContext_ConfigurationRevisionStatus_foundDependencies(ctx, field)
			case "installedDependencies":
				return ec.fieldContext_ConfigurationRevisionStatus_installedDependencies(ctx, field)
			case "invalidDependencies":
				return ec.fieldContext_ConfigurationRevisionStatus_invalidDependencies(ctx, field)
			case "permissionRequests":
				return ec.fieldContext_ConfigurationRevisionStatus_permissionRequests(ctx, field)
			case "objects":
				return ec.fieldContext_ConfigurationRevisionStatus_objects(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigurationRevisionStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevision_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevision_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevision_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevision",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevision_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevision_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevision_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevision",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ConfigurationRevision_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevision_events(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevision_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ConfigurationRevision().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevision_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevision",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.ConfigurationRevision)
	fc.Result = res
	return ec.marshalOConfigurationRevision2githubcomupboundxgqlinternalgraphmodelConfigurationRevision(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ConfigurationRevision_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_ConfigurationRevision_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_ConfigurationRevision_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_ConfigurationRevision_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_ConfigurationRevision_spec(ctx, field)
			case "status":
				return ec.fieldContext_ConfigurationRevision_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_ConfigurationRevision_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_ConfigurationRevision_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_ConfigurationRevision_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigurationRevision", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionSpec_desiredState(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionSpec_desiredState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DesiredState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PackageRevisionDesiredState)
	fc.Result = res
	return ec.marshalNPackageRevisionDesiredState2githubcomupboundxgqlinternalgraphmodelPackageRevisionDesiredState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionSpec_desiredState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PackageRevisionDesiredState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionSpec_package(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionSpec_package(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionSpec_package(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionSpec_packagePullPolicy(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionSpec_packagePullPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackagePullPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PackagePullPolicy)
	fc.Result = res
	return ec.marshalOPackagePullPolicy2githubcomupboundxgqlinternalgraphmodelPackagePullPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionSpec_packagePullPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PackagePullPolicy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionSpec_revision(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionSpec_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionSpec_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionSpec_ignoreCrossplaneConstraints(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionSpec_ignoreCrossplaneConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IgnoreCrossplaneConstraints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionSpec_ignoreCrossplaneConstraints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionSpec_skipDependencyResolution(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionSpec_skipDependencyResolution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipDependencyResolution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionSpec_skipDependencyResolution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionStatus_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Condition)
	fc.Result = res
	return ec.marshalOCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionStatus_conditions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_Condition_type(ctx, field)
			case "status":
				return ec.fieldContext_Condition_status(ctx, field)
			case "lastTransitionTime":
				return ec.fieldContext_Condition_lastTransitionTime(ctx, field)
			case "reason":
				return ec.fieldContext_Condition_reason(ctx, field)
			case "message":
				return ec.fieldContext_Condition_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Condition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionStatus_foundDependencies(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionStatus_foundDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FoundDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionStatus_foundDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionStatus_installedDependencies(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionStatus_installedDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstalledDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionStatus_installedDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionStatus_invalidDependencies(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionStatus_invalidDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InvalidDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionStatus_invalidDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionStatus_permissionRequests(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionStatus_permissionRequests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PermissionRequests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.PolicyRule)
	fc.Result = res
	return ec.marshalOPolicyRule2githubcomupboundxgqlinternalgraphmodelPolicyRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionStatus_permissionRequests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "verbs":
				return ec.fieldContext_PolicyRule_verbs(ctx, field)
			case "apiGroups":
				return ec.fieldContext_PolicyRule_apiGroups(ctx, field)
			case "resources":
				return ec.fieldContext_PolicyRule_resources(ctx, field)
			case "resourceNames":
				return ec.fieldContext_PolicyRule_resourceNames(ctx, field)
			case "nonResourceURLs":
				return ec.fieldContext_PolicyRule_nonResourceURLs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PolicyRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationRevisionStatus_objects(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationRevisionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationRevisionStatus_objects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ConfigurationRevisionStatus().Objects(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResourceConnection)
	fc.Result = res
	return ec.marshalNKubernetesResourceConnection2githubcomupboundxgqlinternalgraphmodelKubernetesResourceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationRevisionStatus_objects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationRevisionStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_KubernetesResourceConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_KubernetesResourceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KubernetesResourceConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationSpec_package(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationSpec_package(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationSpec_package(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationSpec_revisionActivationPolicy(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationSpec_revisionActivationPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RevisionActivationPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RevisionActivationPolicy)
	fc.Result = res
	return ec.marshalORevisionActivationPolicy2githubcomupboundxgqlinternalgraphmodelRevisionActivationPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationSpec_revisionActivationPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RevisionActivationPolicy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationSpec_revisionHistoryLimit(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationSpec_revisionHistoryLimit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RevisionHistoryLimit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationSpec_revisionHistoryLimit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationSpec_packagePullPolicy(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationSpec_packagePullPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackagePullPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PackagePullPolicy)
	fc.Result = res
	return ec.marshalOPackagePullPolicy2githubcomupboundxgqlinternalgraphmodelPackagePullPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationSpec_packagePullPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PackagePullPolicy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationSpec_ignoreCrossplaneConstraints(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationSpec_ignoreCrossplaneConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IgnoreCrossplaneConstraints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationSpec_ignoreCrossplaneConstraints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationSpec_skipDependencyResolution(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationSpec_skipDependencyResolution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipDependencyResolution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationSpec_skipDependencyResolution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationStatus_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Condition)
	fc.Result = res
	return ec.marshalOCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationStatus_conditions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_Condition_type(ctx, field)
			case "status":
				return ec.fieldContext_Condition_status(ctx, field)
			case "lastTransitionTime":
				return ec.fieldContext_Condition_lastTransitionTime(ctx, field)
			case "reason":
				return ec.fieldContext_Condition_reason(ctx, field)
			case "message":
				return ec.fieldContext_Condition_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Condition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationStatus_currentRevision(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationStatus_currentRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationStatus_currentRevision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigurationStatus_currentIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.ConfigurationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationStatus_currentIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationStatus_currentIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateKubernetesResourcePayload_resource(ctx context.Context, field graphql.CollectedField, obj *model.CreateKubernetesResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateKubernetesResourcePayload_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResource)
	fc.Result = res
	return ec.marshalOKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateKubernetesResourcePayload_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateKubernetesResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CrossplaneResourceTreeConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.CrossplaneResourceTreeConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CrossplaneResourceTreeConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.CrossplaneResourceTreeNode)
	fc.Result = res
	return ec.marshalOCrossplaneResourceTreeNode2githubcomupboundxgqlinternalgraphmodelCrossplaneResourceTreeNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CrossplaneResourceTreeConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CrossplaneResourceTreeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "parentId":
				return ec.fieldContext_CrossplaneResourceTreeNode_parentId(ctx, field)
			case "resource":
				return ec.fieldContext_CrossplaneResourceTreeNode_resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CrossplaneResourceTreeNode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CrossplaneResourceTreeConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.CrossplaneResourceTreeConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CrossplaneResourceTreeConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CrossplaneResourceTreeConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CrossplaneResourceTreeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CrossplaneResourceTreeNode_parentId(ctx context.Context, field graphql.CollectedField, obj *model.CrossplaneResourceTreeNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CrossplaneResourceTreeNode_parentId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ReferenceID)
	fc.Result = res
	return ec.marshalOID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CrossplaneResourceTreeNode_parentId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CrossplaneResourceTreeNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CrossplaneResourceTreeNode_resource(ctx context.Context, field graphql.CollectedField, obj *model.CrossplaneResourceTreeNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CrossplaneResourceTreeNode_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResource)
	fc.Result = res
	return ec.marshalNKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CrossplaneResourceTreeNode_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CrossplaneResourceTreeNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinition_id(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinition_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinition_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinition_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinition_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinition_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinition_kind(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinition_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinition_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinition_metadata(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinition_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinition_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinition_spec(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinition_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CustomResourceDefinitionSpec)
	fc.Result = res
	return ec.marshalNCustomResourceDefinitionSpec2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinitionSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinition_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "group":
				return ec.fieldContext_CustomResourceDefinitionSpec_group(ctx, field)
			case "names":
				return ec.fieldContext_CustomResourceDefinitionSpec_names(ctx, field)
			case "scope":
				return ec.fieldContext_CustomResourceDefinitionSpec_scope(ctx, field)
			case "versions":
				return ec.fieldContext_CustomResourceDefinitionSpec_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CustomResourceDefinitionSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinition_status(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinition_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CustomResourceDefinitionStatus)
	fc.Result = res
	return ec.marshalOCustomResourceDefinitionStatus2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinitionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinition_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conditions":
				return ec.fieldContext_CustomResourceDefinitionStatus_conditions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CustomResourceDefinitionStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinition_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinition_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinition_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinition_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinition_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinition_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CustomResourceDefinition_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinition_events(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinition_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CustomResourceDefinition().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinition_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinition_definedResources(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinition_definedResources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CustomResourceDefinition().DefinedResources(rctx, obj, fc.Args["version"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResourceConnection)
	fc.Result = res
	return ec.marshalNKubernetesResourceConnection2githubcomupboundxgqlinternalgraphmodelKubernetesResourceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinition_definedResources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_KubernetesResourceConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_KubernetesResourceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KubernetesResourceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CustomResourceDefinition_definedResources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.CustomResourceDefinition)
	fc.Result = res
	return ec.marshalOCustomResourceDefinition2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CustomResourceDefinition_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_CustomResourceDefinition_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_CustomResourceDefinition_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_CustomResourceDefinition_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_CustomResourceDefinition_spec(ctx, field)
			case "status":
				return ec.fieldContext_CustomResourceDefinition_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_CustomResourceDefinition_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_CustomResourceDefinition_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_CustomResourceDefinition_events(ctx, field)
			case "definedResources":
				return ec.fieldContext_CustomResourceDefinition_definedResources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CustomResourceDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionNames_plural(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionNames) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionNames_plural(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plural, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionNames_plural(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionNames",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionNames_singular(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionNames) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionNames_singular(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Singular, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionNames_singular(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionNames",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionNames_shortNames(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionNames) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionNames_shortNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionNames_shortNames(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionNames",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionNames_kind(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionNames) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionNames_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionNames_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionNames",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionNames_listKind(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionNames) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionNames_listKind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ListKind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionNames_listKind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionNames",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionNames_categories(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionNames) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionNames_categories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Categories, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionNames_categories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionNames",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionSpec_group(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionSpec_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionSpec_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionSpec_names(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionSpec_names(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Names, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CustomResourceDefinitionNames)
	fc.Result = res
	return ec.marshalNCustomResourceDefinitionNames2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinitionNames(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionSpec_names(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "plural":
				return ec.fieldContext_CustomResourceDefinitionNames_plural(ctx, field)
			case "singular":
				return ec.fieldContext_CustomResourceDefinitionNames_singular(ctx, field)
			case "shortNames":
				return ec.fieldContext_CustomResourceDefinitionNames_shortNames(ctx, field)
			case "kind":
				return ec.fieldContext_CustomResourceDefinitionNames_kind(ctx, field)
			case "listKind":
				return ec.fieldContext_CustomResourceDefinitionNames_listKind(ctx, field)
			case "categories":
				return ec.fieldContext_CustomResourceDefinitionNames_categories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CustomResourceDefinitionNames", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionSpec_scope(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionSpec_scope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceScope)
	fc.Result = res
	return ec.marshalNResourceScope2githubcomupboundxgqlinternalgraphmodelResourceScope(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionSpec_scope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceScope does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionSpec_versions(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionSpec_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.CustomResourceDefinitionVersion)
	fc.Result = res
	return ec.marshalOCustomResourceDefinitionVersion2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinitionVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionSpec_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_CustomResourceDefinitionVersion_name(ctx, field)
			case "served":
				return ec.fieldContext_CustomResourceDefinitionVersion_served(ctx, field)
			case "schema":
				return ec.fieldContext_CustomResourceDefinitionVersion_schema(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CustomResourceDefinitionVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionStatus_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Condition)
	fc.Result = res
	return ec.marshalOCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionStatus_conditions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_Condition_type(ctx, field)
			case "status":
				return ec.fieldContext_Condition_status(ctx, field)
			case "lastTransitionTime":
				return ec.fieldContext_Condition_lastTransitionTime(ctx, field)
			case "reason":
				return ec.fieldContext_Condition_reason(ctx, field)
			case "message":
				return ec.fieldContext_Condition_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Condition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionVersion_name(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionVersion_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionVersion_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionVersion_served(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionVersion_served(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Served, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionVersion_served(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceDefinitionVersion_schema(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceDefinitionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceDefinitionVersion_schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CustomResourceValidation)
	fc.Result = res
	return ec.marshalOCustomResourceValidation2githubcomupboundxgqlinternalgraphmodelCustomResourceValidation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceDefinitionVersion_schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceDefinitionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "openAPIV3Schema":
				return ec.fieldContext_CustomResourceValidation_openAPIV3Schema(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CustomResourceValidation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomResourceValidation_openAPIV3Schema(ctx context.Context, field graphql.CollectedField, obj *model.CustomResourceValidation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomResourceValidation_openAPIV3Schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OpenAPIV3Schema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomResourceValidation_openAPIV3Schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomResourceValidation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteKubernetesResourcePayload_resource(ctx context.Context, field graphql.CollectedField, obj *model.DeleteKubernetesResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteKubernetesResourcePayload_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResource)
	fc.Result = res
	return ec.marshalOKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteKubernetesResourcePayload_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteKubernetesResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_id(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_kind(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_metadata(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_involvedObject(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_involvedObject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().InvolvedObject(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResource)
	fc.Result = res
	return ec.marshalNKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_involvedObject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_type(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.EventType)
	fc.Result = res
	return ec.marshalOEventType2githubcomupboundxgqlinternalgraphmodelEventType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_reason(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_message(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_source(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.EventSource)
	fc.Result = res
	return ec.marshalOEventSource2githubcomupboundxgqlinternalgraphmodelEventSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "component":
				return ec.fieldContext_EventSource_component(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventSource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_count(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_firstTime(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_firstTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_firstTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_lastTime(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_lastTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_lastTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Event_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _EventConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.EventConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Event)
	fc.Result = res
	return ec.marshalOEvent2githubcomupboundxgqlinternalgraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_Event_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_Event_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_Event_metadata(ctx, field)
			case "involvedObject":
				return ec.fieldContext_Event_involvedObject(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "reason":
				return ec.fieldContext_Event_reason(ctx, field)
			case "message":
				return ec.fieldContext_Event_message(ctx, field)
			case "source":
				return ec.fieldContext_Event_source(ctx, field)
			case "count":
				return ec.fieldContext_Event_count(ctx, field)
			case "firstTime":
				return ec.fieldContext_Event_firstTime(ctx, field)
			case "lastTime":
				return ec.fieldContext_Event_lastTime(ctx, field)
			case "unstructured":
				return ec.fieldContext_Event_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_Event_fieldPath(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.EventConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventSource_component(ctx context.Context, field graphql.CollectedField, obj *model.EventSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventSource_component(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Component, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventSource_component(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GenericResource_id(ctx context.Context, field graphql.CollectedField, obj *model.GenericResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GenericResource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GenericResource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GenericResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GenericResource_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.GenericResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GenericResource_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GenericResource_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GenericResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GenericResource_kind(ctx context.Context, field graphql.CollectedField, obj *model.GenericResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GenericResource_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GenericResource_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GenericResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GenericResource_metadata(ctx context.Context, field graphql.CollectedField, obj *model.GenericResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GenericResource_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GenericResource_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GenericResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GenericResource_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.GenericResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GenericResource_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GenericResource_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GenericResource",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GenericResource_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.GenericResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GenericResource_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GenericResource_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GenericResource",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_GenericResource_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _GenericResource_events(ctx context.Context, field graphql.CollectedField, obj *model.GenericResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GenericResource_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GenericResource().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GenericResource_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GenericResource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KubernetesResourceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.KubernetesResourceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KubernetesResourceConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.KubernetesResource)
	fc.Result = res
	return ec.marshalOKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KubernetesResourceConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KubernetesResourceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KubernetesResourceConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.KubernetesResourceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KubernetesResourceConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KubernetesResourceConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KubernetesResourceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelSelector_matchLabels(ctx context.Context, field graphql.CollectedField, obj *model.LabelSelector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelSelector_matchLabels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchLabels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelSelector_matchLabels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelSelector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocalObjectReference_name(ctx context.Context, field graphql.CollectedField, obj *model.LocalObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocalObjectReference_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocalObjectReference_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocalObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResource_id(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResource_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResource_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResource_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResource_kind(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResource_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResource_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResource_metadata(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResource_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResource_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResource_spec(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResource_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ManagedResourceSpec)
	fc.Result = res
	return ec.marshalNManagedResourceSpec2githubcomupboundxgqlinternalgraphmodelManagedResourceSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResource_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "connectionSecret":
				return ec.fieldContext_ManagedResourceSpec_connectionSecret(ctx, field)
			case "providerConfigRef":
				return ec.fieldContext_ManagedResourceSpec_providerConfigRef(ctx, field)
			case "deletionPolicy":
				return ec.fieldContext_ManagedResourceSpec_deletionPolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ManagedResourceSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResource_status(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResource_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ManagedResourceStatus)
	fc.Result = res
	return ec.marshalOManagedResourceStatus2githubcomupboundxgqlinternalgraphmodelManagedResourceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResource_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conditions":
				return ec.fieldContext_ManagedResourceStatus_conditions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ManagedResourceStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResource_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResource_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResource_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResource",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResource_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResource_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResource_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResource",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ManagedResource_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResource_events(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResource_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ManagedResource().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResource_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResource_definition(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResource_definition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ManagedResource().Definition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ManagedResourceDefinition)
	fc.Result = res
	return ec.marshalOManagedResourceDefinition2githubcomupboundxgqlinternalgraphmodelManagedResourceDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResource_definition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ManagedResourceDefinition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResourceSpec_connectionSecret(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResourceSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResourceSpec_connectionSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ManagedResourceSpec().ConnectionSecret(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Secret)
	fc.Result = res
	return ec.marshalOSecret2githubcomupboundxgqlinternalgraphmodelSecret(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResourceSpec_connectionSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResourceSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Secret_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_Secret_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_Secret_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_Secret_metadata(ctx, field)
			case "type":
				return ec.fieldContext_Secret_type(ctx, field)
			case "data":
				return ec.fieldContext_Secret_data(ctx, field)
			case "unstructured":
				return ec.fieldContext_Secret_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_Secret_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_Secret_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Secret", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResourceSpec_providerConfigRef(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResourceSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResourceSpec_providerConfigRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderConfigRef, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ProviderConfigReference)
	fc.Result = res
	return ec.marshalOProviderConfigReference2githubcomupboundxgqlinternalgraphmodelProviderConfigReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResourceSpec_providerConfigRef(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResourceSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ProviderConfigReference_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderConfigReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResourceSpec_deletionPolicy(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResourceSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResourceSpec_deletionPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletionPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeletionPolicy)
	fc.Result = res
	return ec.marshalODeletionPolicy2githubcomupboundxgqlinternalgraphmodelDeletionPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResourceSpec_deletionPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResourceSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletionPolicy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ManagedResourceStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *model.ManagedResourceStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ManagedResourceStatus_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Condition)
	fc.Result = res
	return ec.marshalOCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ManagedResourceStatus_conditions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ManagedResourceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_Condition_type(ctx, field)
			case "status":
				return ec.fieldContext_Condition_status(ctx, field)
			case "lastTransitionTime":
				return ec.fieldContext_Condition_lastTransitionTime(ctx, field)
			case "reason":
				return ec.fieldContext_Condition_reason(ctx, field)
			case "message":
				return ec.fieldContext_Condition_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Condition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createKubernetesResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createKubernetesResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateKubernetesResource(rctx, fc.Args["input"].(model.CreateKubernetesResourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateKubernetesResourcePayload)
	fc.Result = res
	return ec.marshalNCreateKubernetesResourcePayload2githubcomupboundxgqlinternalgraphmodelCreateKubernetesResourcePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createKubernetesResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resource":
				return ec.fieldContext_CreateKubernetesResourcePayload_resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateKubernetesResourcePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createKubernetesResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateKubernetesResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateKubernetesResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateKubernetesResource(rctx, fc.Args["id"].(model.ReferenceID), fc.Args["input"].(model.UpdateKubernetesResourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateKubernetesResourcePayload)
	fc.Result = res
	return ec.marshalNUpdateKubernetesResourcePayload2githubcomupboundxgqlinternalgraphmodelUpdateKubernetesResourcePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateKubernetesResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resource":
				return ec.fieldContext_UpdateKubernetesResourcePayload_resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateKubernetesResourcePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateKubernetesResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteKubernetesResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteKubernetesResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteKubernetesResource(rctx, fc.Args["id"].(model.ReferenceID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DeleteKubernetesResourcePayload)
	fc.Result = res
	return ec.marshalNDeleteKubernetesResourcePayload2githubcomupboundxgqlinternalgraphmodelDeleteKubernetesResourcePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteKubernetesResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resource":
				return ec.fieldContext_DeleteKubernetesResourcePayload_resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteKubernetesResourcePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteKubernetesResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ObjectMeta_name(ctx context.Context, field graphql.CollectedField, obj *model.ObjectMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectMeta_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectMeta_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectMeta_generateName(ctx context.Context, field graphql.CollectedField, obj *model.ObjectMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectMeta_generateName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenerateName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectMeta_generateName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectMeta_namespace(ctx context.Context, field graphql.CollectedField, obj *model.ObjectMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectMeta_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectMeta_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectMeta_uid(ctx context.Context, field graphql.CollectedField, obj *model.ObjectMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectMeta_uid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectMeta_uid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectMeta_resourceVersion(ctx context.Context, field graphql.CollectedField, obj *model.ObjectMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectMeta_resourceVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectMeta_generation(ctx context.Context, field graphql.CollectedField, obj *model.ObjectMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectMeta_generation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Generation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectMeta_generation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectMeta_creationTime(ctx context.Context, field graphql.CollectedField, obj *model.ObjectMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectMeta_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectMeta_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectMeta_deletionTime(ctx context.Context, field graphql.CollectedField, obj *model.ObjectMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletionTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectMeta_deletionTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectMeta_labels(ctx context.Context, field graphql.CollectedField, obj *model.ObjectMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectMeta_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels(fc.Args["keys"].([]string)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectMeta_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectMeta",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ObjectMeta_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ObjectMeta_annotations(ctx context.Context, field graphql.CollectedField, obj *model.ObjectMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectMeta_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations(fc.Args["keys"].([]string)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectMeta_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectMeta",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ObjectMeta_annotations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ObjectMeta_owners(ctx context.Context, field graphql.CollectedField, obj *model.ObjectMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectMeta_owners(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObjectMeta().Owners(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.OwnerConnection)
	fc.Result = res
	return ec.marshalNOwnerConnection2githubcomupboundxgqlinternalgraphmodelOwnerConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectMeta_owners(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectMeta",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_OwnerConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_OwnerConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OwnerConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectMeta_controller(ctx context.Context, field graphql.CollectedField, obj *model.ObjectMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectMeta_controller(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObjectMeta().Controller(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResource)
	fc.Result = res
	return ec.marshalOKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectMeta_controller(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectMeta",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectReference_kind(ctx context.Context, field graphql.CollectedField, obj *model.ObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectReference_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectReference_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectReference_namespace(ctx context.Context, field graphql.CollectedField, obj *model.ObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectReference_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectReference_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectReference_name(ctx context.Context, field graphql.CollectedField, obj *model.ObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectReference_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectReference_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Owner_resource(ctx context.Context, field graphql.CollectedField, obj *model.Owner) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Owner_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResource)
	fc.Result = res
	return ec.marshalNKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Owner_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Owner",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Owner_controller(ctx context.Context, field graphql.CollectedField, obj *model.Owner) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Owner_controller(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Controller, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Owner_controller(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Owner",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OwnerConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.OwnerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OwnerConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Owner)
	fc.Result = res
	return ec.marshalOOwner2githubcomupboundxgqlinternalgraphmodelOwner(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OwnerConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OwnerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resource":
				return ec.fieldContext_Owner_resource(ctx, field)
			case "controller":
				return ec.fieldContext_Owner_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Owner", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OwnerConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.OwnerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OwnerConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OwnerConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OwnerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PolicyRule_verbs(ctx context.Context, field graphql.CollectedField, obj *model.PolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PolicyRule_verbs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Verbs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PolicyRule_verbs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PolicyRule_apiGroups(ctx context.Context, field graphql.CollectedField, obj *model.PolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PolicyRule_apiGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PolicyRule_apiGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PolicyRule_resources(ctx context.Context, field graphql.CollectedField, obj *model.PolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PolicyRule_resources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PolicyRule_resources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PolicyRule_resourceNames(ctx context.Context, field graphql.CollectedField, obj *model.PolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PolicyRule_resourceNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PolicyRule_resourceNames(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PolicyRule_nonResourceURLs(ctx context.Context, field graphql.CollectedField, obj *model.PolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PolicyRule_nonResourceURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NonResourceURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PolicyRule_nonResourceURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_id(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Provider_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Provider_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Provider_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Provider_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_kind(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Provider_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Provider_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_metadata(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Provider_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Provider_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_spec(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Provider_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProviderSpec)
	fc.Result = res
	return ec.marshalNProviderSpec2githubcomupboundxgqlinternalgraphmodelProviderSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Provider_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "package":
				return ec.fieldContext_ProviderSpec_package(ctx, field)
			case "revisionActivationPolicy":
				return ec.fieldContext_ProviderSpec_revisionActivationPolicy(ctx, field)
			case "revisionHistoryLimit":
				return ec.fieldContext_ProviderSpec_revisionHistoryLimit(ctx, field)
			case "packagePullPolicy":
				return ec.fieldContext_ProviderSpec_packagePullPolicy(ctx, field)
			case "ignoreCrossplaneConstraints":
				return ec.fieldContext_ProviderSpec_ignoreCrossplaneConstraints(ctx, field)
			case "skipDependencyResolution":
				return ec.fieldContext_ProviderSpec_skipDependencyResolution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_status(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Provider_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ProviderStatus)
	fc.Result = res
	return ec.marshalOProviderStatus2githubcomupboundxgqlinternalgraphmodelProviderStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Provider_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conditions":
				return ec.fieldContext_ProviderStatus_conditions(ctx, field)
			case "currentRevision":
				return ec.fieldContext_ProviderStatus_currentRevision(ctx, field)
			case "currentIdentifier":
				return ec.fieldContext_ProviderStatus_currentIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Provider_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Provider_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Provider_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Provider_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Provider_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Provider_events(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Provider_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Provider().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Provider_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_revisions(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Provider_revisions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Provider().Revisions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProviderRevisionConnection)
	fc.Result = res
	return ec.marshalNProviderRevisionConnection2githubcomupboundxgqlinternalgraphmodelProviderRevisionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Provider_revisions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_ProviderRevisionConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_ProviderRevisionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderRevisionConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_activeRevision(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Provider_activeRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Provider().ActiveRevision(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ProviderRevision)
	fc.Result = res
	return ec.marshalOProviderRevision2githubcomupboundxgqlinternalgraphmodelProviderRevision(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Provider_activeRevision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProviderRevision_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_ProviderRevision_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_ProviderRevision_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_ProviderRevision_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_ProviderRevision_spec(ctx, field)
			case "status":
				return ec.fieldContext_ProviderRevision_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_ProviderRevision_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_ProviderRevision_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_ProviderRevision_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderRevision", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConfig_id(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConfig_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConfig_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConfig_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConfig_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConfig_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConfig_kind(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConfig_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConfig_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConfig_metadata(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConfig_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConfig_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConfig_status(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConfig_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ProviderConfigStatus)
	fc.Result = res
	return ec.marshalOProviderConfigStatus2githubcomupboundxgqlinternalgraphmodelProviderConfigStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConfig_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conditions":
				return ec.fieldContext_ProviderConfigStatus_conditions(ctx, field)
			case "users":
				return ec.fieldContext_ProviderConfigStatus_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderConfigStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConfig_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConfig_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConfig_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConfig",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConfig_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConfig_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConfig_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConfig",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ProviderConfig_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConfig_events(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConfig_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProviderConfig().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConfig_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConfig",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConfig_definition(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConfig_definition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProviderConfig().Definition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ProviderConfigDefinition)
	fc.Result = res
	return ec.marshalOProviderConfigDefinition2githubcomupboundxgqlinternalgraphmodelProviderConfigDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConfig_definition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConfig",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProviderConfigDefinition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConfigReference_name(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConfigReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConfigReference_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConfigReference_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConfigReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConfigStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConfigStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConfigStatus_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Condition)
	fc.Result = res
	return ec.marshalOCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConfigStatus_conditions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConfigStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_Condition_type(ctx, field)
			case "status":
				return ec.fieldContext_Condition_status(ctx, field)
			case "lastTransitionTime":
				return ec.fieldContext_Condition_lastTransitionTime(ctx, field)
			case "reason":
				return ec.fieldContext_Condition_reason(ctx, field)
			case "message":
				return ec.fieldContext_Condition_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Condition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConfigStatus_users(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConfigStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConfigStatus_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConfigStatus_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConfigStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Provider)
	fc.Result = res
	return ec.marshalOProvider2githubcomupboundxgqlinternalgraphmodelProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Provider_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_Provider_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_Provider_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_Provider_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_Provider_spec(ctx, field)
			case "status":
				return ec.fieldContext_Provider_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_Provider_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_Provider_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_Provider_events(ctx, field)
			case "revisions":
				return ec.fieldContext_Provider_revisions(ctx, field)
			case "activeRevision":
				return ec.fieldContext_Provider_activeRevision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Provider", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.ProviderConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevision_id(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevision_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevision_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevision",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevision_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevision_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevision_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevision",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevision_kind(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevision_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevision_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevision",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevision_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevision_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevision",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevision_spec(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevision_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProviderRevisionSpec)
	fc.Result = res
	return ec.marshalNProviderRevisionSpec2githubcomupboundxgqlinternalgraphmodelProviderRevisionSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevision_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevision",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "desiredState":
				return ec.fieldContext_ProviderRevisionSpec_desiredState(ctx, field)
			case "package":
				return ec.fieldContext_ProviderRevisionSpec_package(ctx, field)
			case "packagePullPolicy":
				return ec.fieldContext_ProviderRevisionSpec_packagePullPolicy(ctx, field)
			case "revision":
				return ec.fieldContext_ProviderRevisionSpec_revision(ctx, field)
			case "ignoreCrossplaneConstraints":
				return ec.fieldContext_ProviderRevisionSpec_ignoreCrossplaneConstraints(ctx, field)
			case "skipDependencyResolution":
				return ec.fieldContext_ProviderRevisionSpec_skipDependencyResolution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderRevisionSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevision_status(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevision_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ProviderRevisionStatus)
	fc.Result = res
	return ec.marshalOProviderRevisionStatus2githubcomupboundxgqlinternalgraphmodelProviderRevisionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevision_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevision",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conditions":
				return ec.fieldContext_ProviderRevisionStatus_conditions(ctx, field)
			case "foundDependencies":
				return ec.fieldContext_ProviderRevisionStatus_foundDependencies(ctx, field)
			case "installedDependencies":
				return ec.fieldContext_ProviderRevisionStatus_installedDependencies(ctx, field)
			case "invalidDependencies":
				return ec.fieldContext_ProviderRevisionStatus_invalidDependencies(ctx, field)
			case "permissionRequests":
				return ec.fieldContext_ProviderRevisionStatus_permissionRequests(ctx, field)
			case "objects":
				return ec.fieldContext_ProviderRevisionStatus_objects(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderRevisionStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevision_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevision_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevision_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevision",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevision_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevision_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevision_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevision",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ProviderRevision_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevision_events(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevision) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevision_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProviderRevision().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevision_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevision",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.ProviderRevision)
	fc.Result = res
	return ec.marshalOProviderRevision2githubcomupboundxgqlinternalgraphmodelProviderRevision(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionConnection_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProviderRevision_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_ProviderRevision_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_ProviderRevision_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_ProviderRevision_metadata(ctx, field)
			case "spec":
				return ec.fieldContext_ProviderRevision_spec(ctx, field)
			case "status":
				return ec.fieldContext_ProviderRevision_status(ctx, field)
			case "unstructured":
				return ec.fieldContext_ProviderRevision_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_ProviderRevision_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_ProviderRevision_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderRevision", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionSpec_desiredState(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionSpec_desiredState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DesiredState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PackageRevisionDesiredState)
	fc.Result = res
	return ec.marshalNPackageRevisionDesiredState2githubcomupboundxgqlinternalgraphmodelPackageRevisionDesiredState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionSpec_desiredState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PackageRevisionDesiredState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionSpec_package(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionSpec_package(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionSpec_package(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionSpec_packagePullPolicy(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionSpec_packagePullPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackagePullPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PackagePullPolicy)
	fc.Result = res
	return ec.marshalOPackagePullPolicy2githubcomupboundxgqlinternalgraphmodelPackagePullPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionSpec_packagePullPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PackagePullPolicy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionSpec_revision(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionSpec_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionSpec_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionSpec_ignoreCrossplaneConstraints(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionSpec_ignoreCrossplaneConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IgnoreCrossplaneConstraints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionSpec_ignoreCrossplaneConstraints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionSpec_skipDependencyResolution(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionSpec_skipDependencyResolution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipDependencyResolution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionSpec_skipDependencyResolution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionStatus_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Condition)
	fc.Result = res
	return ec.marshalOCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionStatus_conditions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_Condition_type(ctx, field)
			case "status":
				return ec.fieldContext_Condition_status(ctx, field)
			case "lastTransitionTime":
				return ec.fieldContext_Condition_lastTransitionTime(ctx, field)
			case "reason":
				return ec.fieldContext_Condition_reason(ctx, field)
			case "message":
				return ec.fieldContext_Condition_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Condition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionStatus_foundDependencies(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionStatus_foundDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FoundDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionStatus_foundDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionStatus_installedDependencies(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionStatus_installedDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstalledDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionStatus_installedDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionStatus_invalidDependencies(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionStatus_invalidDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InvalidDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionStatus_invalidDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionStatus_permissionRequests(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionStatus_permissionRequests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PermissionRequests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.PolicyRule)
	fc.Result = res
	return ec.marshalOPolicyRule2githubcomupboundxgqlinternalgraphmodelPolicyRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionStatus_permissionRequests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "verbs":
				return ec.fieldContext_PolicyRule_verbs(ctx, field)
			case "apiGroups":
				return ec.fieldContext_PolicyRule_apiGroups(ctx, field)
			case "resources":
				return ec.fieldContext_PolicyRule_resources(ctx, field)
			case "resourceNames":
				return ec.fieldContext_PolicyRule_resourceNames(ctx, field)
			case "nonResourceURLs":
				return ec.fieldContext_PolicyRule_nonResourceURLs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PolicyRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderRevisionStatus_objects(ctx context.Context, field graphql.CollectedField, obj *model.ProviderRevisionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderRevisionStatus_objects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProviderRevisionStatus().Objects(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResourceConnection)
	fc.Result = res
	return ec.marshalNKubernetesResourceConnection2githubcomupboundxgqlinternalgraphmodelKubernetesResourceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderRevisionStatus_objects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderRevisionStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_KubernetesResourceConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_KubernetesResourceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KubernetesResourceConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderSpec_package(ctx context.Context, field graphql.CollectedField, obj *model.ProviderSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderSpec_package(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderSpec_package(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderSpec_revisionActivationPolicy(ctx context.Context, field graphql.CollectedField, obj *model.ProviderSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderSpec_revisionActivationPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RevisionActivationPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RevisionActivationPolicy)
	fc.Result = res
	return ec.marshalORevisionActivationPolicy2githubcomupboundxgqlinternalgraphmodelRevisionActivationPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderSpec_revisionActivationPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RevisionActivationPolicy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderSpec_revisionHistoryLimit(ctx context.Context, field graphql.CollectedField, obj *model.ProviderSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderSpec_revisionHistoryLimit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RevisionHistoryLimit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderSpec_revisionHistoryLimit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderSpec_packagePullPolicy(ctx context.Context, field graphql.CollectedField, obj *model.ProviderSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderSpec_packagePullPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackagePullPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PackagePullPolicy)
	fc.Result = res
	return ec.marshalOPackagePullPolicy2githubcomupboundxgqlinternalgraphmodelPackagePullPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderSpec_packagePullPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PackagePullPolicy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderSpec_ignoreCrossplaneConstraints(ctx context.Context, field graphql.CollectedField, obj *model.ProviderSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderSpec_ignoreCrossplaneConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IgnoreCrossplaneConstraints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderSpec_ignoreCrossplaneConstraints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderSpec_skipDependencyResolution(ctx context.Context, field graphql.CollectedField, obj *model.ProviderSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderSpec_skipDependencyResolution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipDependencyResolution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderSpec_skipDependencyResolution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *model.ProviderStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderStatus_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Condition)
	fc.Result = res
	return ec.marshalOCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderStatus_conditions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_Condition_type(ctx, field)
			case "status":
				return ec.fieldContext_Condition_status(ctx, field)
			case "lastTransitionTime":
				return ec.fieldContext_Condition_lastTransitionTime(ctx, field)
			case "reason":
				return ec.fieldContext_Condition_reason(ctx, field)
			case "message":
				return ec.fieldContext_Condition_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Condition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderStatus_currentRevision(ctx context.Context, field graphql.CollectedField, obj *model.ProviderStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderStatus_currentRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderStatus_currentRevision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderStatus_currentIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.ProviderStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProviderStatus_currentIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProviderStatus_currentIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_kubernetesResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_kubernetesResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().KubernetesResource(rctx, fc.Args["id"].(model.ReferenceID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResource)
	fc.Result = res
	return ec.marshalOKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_kubernetesResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_kubernetesResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_kubernetesResources(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_kubernetesResources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().KubernetesResources(rctx, fc.Args["apiVersion"].(string), fc.Args["kind"].(string), fc.Args["listKind"].(*string), fc.Args["namespace"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResourceConnection)
	fc.Result = res
	return ec.marshalNKubernetesResourceConnection2githubcomupboundxgqlinternalgraphmodelKubernetesResourceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_kubernetesResources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_KubernetesResourceConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_KubernetesResourceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KubernetesResourceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_kubernetesResources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_events(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Events(rctx, fc.Args["involved"].(*model.ReferenceID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_secret(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Secret(rctx, fc.Args["namespace"].(string), fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Secret)
	fc.Result = res
	return ec.marshalOSecret2githubcomupboundxgqlinternalgraphmodelSecret(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_secret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Secret_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_Secret_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_Secret_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_Secret_metadata(ctx, field)
			case "type":
				return ec.fieldContext_Secret_type(ctx, field)
			case "data":
				return ec.fieldContext_Secret_data(ctx, field)
			case "unstructured":
				return ec.fieldContext_Secret_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_Secret_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_Secret_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Secret", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_secret_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_configMap(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_configMap(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConfigMap(rctx, fc.Args["namespace"].(string), fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConfigMap)
	fc.Result = res
	return ec.marshalOConfigMap2githubcomupboundxgqlinternalgraphmodelConfigMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_configMap(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ConfigMap_id(ctx, field)
			case "apiVersion":
				return ec.fieldContext_ConfigMap_apiVersion(ctx, field)
			case "kind":
				return ec.fieldContext_ConfigMap_kind(ctx, field)
			case "metadata":
				return ec.fieldContext_ConfigMap_metadata(ctx, field)
			case "data":
				return ec.fieldContext_ConfigMap_data(ctx, field)
			case "unstructured":
				return ec.fieldContext_ConfigMap_unstructured(ctx, field)
			case "fieldPath":
				return ec.fieldContext_ConfigMap_fieldPath(ctx, field)
			case "events":
				return ec.fieldContext_ConfigMap_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigMap", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_configMap_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_providers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_providers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Providers(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProviderConnection)
	fc.Result = res
	return ec.marshalNProviderConnection2githubcomupboundxgqlinternalgraphmodelProviderConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_providers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_ProviderConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_ProviderConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_providerRevisions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_providerRevisions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ProviderRevisions(rctx, fc.Args["provider"].(*model.ReferenceID), fc.Args["active"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProviderRevisionConnection)
	fc.Result = res
	return ec.marshalNProviderRevisionConnection2githubcomupboundxgqlinternalgraphmodelProviderRevisionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_providerRevisions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_ProviderRevisionConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_ProviderRevisionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderRevisionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_providerRevisions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_customResourceDefinitions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_customResourceDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CustomResourceDefinitions(rctx, fc.Args["revision"].(*model.ReferenceID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CustomResourceDefinitionConnection)
	fc.Result = res
	return ec.marshalNCustomResourceDefinitionConnection2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinitionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_customResourceDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_CustomResourceDefinitionConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_CustomResourceDefinitionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CustomResourceDefinitionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_customResourceDefinitions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_configurations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_configurations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Configurations(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConfigurationConnection)
	fc.Result = res
	return ec.marshalNConfigurationConnection2githubcomupboundxgqlinternalgraphmodelConfigurationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_configurations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_ConfigurationConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_ConfigurationConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigurationConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_configurationRevisions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_configurationRevisions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConfigurationRevisions(rctx, fc.Args["configuration"].(*model.ReferenceID), fc.Args["active"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConfigurationRevisionConnection)
	fc.Result = res
	return ec.marshalNConfigurationRevisionConnection2githubcomupboundxgqlinternalgraphmodelConfigurationRevisionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_configurationRevisions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_ConfigurationRevisionConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_ConfigurationRevisionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigurationRevisionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_configurationRevisions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_compositeResourceDefinitions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_compositeResourceDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CompositeResourceDefinitions(rctx, fc.Args["revision"].(*model.ReferenceID), fc.Args["dangling"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CompositeResourceDefinitionConnection)
	fc.Result = res
	return ec.marshalNCompositeResourceDefinitionConnection2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_compositeResourceDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_CompositeResourceDefinitionConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_CompositeResourceDefinitionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResourceDefinitionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_compositeResourceDefinitions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_compositions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_compositions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Compositions(rctx, fc.Args["revision"].(*model.ReferenceID), fc.Args["dangling"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CompositionConnection)
	fc.Result = res
	return ec.marshalNCompositionConnection2githubcomupboundxgqlinternalgraphmodelCompositionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_compositions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_CompositionConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_CompositionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_compositions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_crossplaneResourceTree(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_crossplaneResourceTree(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CrossplaneResourceTree(rctx, fc.Args["id"].(model.ReferenceID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CrossplaneResourceTreeConnection)
	fc.Result = res
	return ec.marshalNCrossplaneResourceTreeConnection2githubcomupboundxgqlinternalgraphmodelCrossplaneResourceTreeConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_crossplaneResourceTree(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_CrossplaneResourceTreeConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_CrossplaneResourceTreeConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CrossplaneResourceTreeConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_crossplaneResourceTree_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_id(ctx context.Context, field graphql.CollectedField, obj *model.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ReferenceID)
	fc.Result = res
	return ec.marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_kind(ctx context.Context, field graphql.CollectedField, obj *model.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_metadata(ctx context.Context, field graphql.CollectedField, obj *model.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ObjectMeta)
	fc.Result = res
	return ec.marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObjectMeta_name(ctx, field)
			case "generateName":
				return ec.fieldContext_ObjectMeta_generateName(ctx, field)
			case "namespace":
				return ec.fieldContext_ObjectMeta_namespace(ctx, field)
			case "uid":
				return ec.fieldContext_ObjectMeta_uid(ctx, field)
			case "resourceVersion":
				return ec.fieldContext_ObjectMeta_resourceVersion(ctx, field)
			case "generation":
				return ec.fieldContext_ObjectMeta_generation(ctx, field)
			case "creationTime":
				return ec.fieldContext_ObjectMeta_creationTime(ctx, field)
			case "deletionTime":
				return ec.fieldContext_ObjectMeta_deletionTime(ctx, field)
			case "labels":
				return ec.fieldContext_ObjectMeta_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ObjectMeta_annotations(ctx, field)
			case "owners":
				return ec.fieldContext_ObjectMeta_owners(ctx, field)
			case "controller":
				return ec.fieldContext_ObjectMeta_controller(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_type(ctx context.Context, field graphql.CollectedField, obj *model.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_data(ctx context.Context, field graphql.CollectedField, obj *model.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data(fc.Args["keys"].([]string)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Secret_data_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Secret_unstructured(ctx context.Context, field graphql.CollectedField, obj *model.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_unstructured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unstructured(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_unstructured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_fieldPath(ctx context.Context, field graphql.CollectedField, obj *model.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_fieldPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldPath(fc.Args["path"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNJSON2byte(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_fieldPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Secret_fieldPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Secret_events(ctx context.Context, field graphql.CollectedField, obj *model.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Secret().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_EventConnection_nodes(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretReference_name(ctx context.Context, field graphql.CollectedField, obj *model.SecretReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretReference_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretReference_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretReference_namespace(ctx context.Context, field graphql.CollectedField, obj *model.SecretReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretReference_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretReference_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeReference_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.TypeReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeReference_apiVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeReference_apiVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeReference_kind(ctx context.Context, field graphql.CollectedField, obj *model.TypeReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeReference_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeReference_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateKubernetesResourcePayload_resource(ctx context.Context, field graphql.CollectedField, obj *model.UpdateKubernetesResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateKubernetesResourcePayload_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.KubernetesResource)
	fc.Result = res
	return ec.marshalOKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateKubernetesResourcePayload_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateKubernetesResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCreateKubernetesResourceInput(ctx context.Context, obj interface{}) (model.CreateKubernetesResourceInput, error) {
	var it model.CreateKubernetesResourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"unstructured", "patches"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "unstructured":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unstructured"))
			data, err := ec.unmarshalNJSON2byte(ctx, v)
			if err != nil {
				return it, err
			}
			it.Unstructured = data
		case "patches":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patches"))
			data, err := ec.unmarshalOPatch2githubcomupboundxgqlinternalgraphmodelPatch(ctx, v)
			if err != nil {
				return it, err
			}
			it.Patches = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDefinedCompositeResourceClaimOptionsInput(ctx context.Context, obj interface{}) (model.DefinedCompositeResourceClaimOptionsInput, error) {
	var it model.DefinedCompositeResourceClaimOptionsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version", "namespace", "ready"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "ready":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ready"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ready = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDefinedCompositeResourceOptionsInput(ctx context.Context, obj interface{}) (model.DefinedCompositeResourceOptionsInput, error) {
	var it model.DefinedCompositeResourceOptionsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version", "ready"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "ready":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ready"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ready = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatch(ctx context.Context, obj interface{}) (model.Patch, error) {
	var it model.Patch
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fieldPath", "unstructured"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fieldPath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldPath"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldPath = data
		case "unstructured":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unstructured"))
			data, err := ec.unmarshalNJSON2byte(ctx, v)
			if err != nil {
				return it, err
			}
			it.Unstructured = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateKubernetesResourceInput(ctx context.Context, obj interface{}) (model.UpdateKubernetesResourceInput, error) {
	var it model.UpdateKubernetesResourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"unstructured", "patches"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "unstructured":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unstructured"))
			data, err := ec.unmarshalNJSON2byte(ctx, v)
			if err != nil {
				return it, err
			}
			it.Unstructured = data
		case "patches":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patches"))
			data, err := ec.unmarshalOPatch2githubcomupboundxgqlinternalgraphmodelPatch(ctx, v)
			if err != nil {
				return it, err
			}
			it.Patches = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _ConditionedStatus(ctx context.Context, sel ast.SelectionSet, obj model.ConditionedStatus) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.CompositeResourceDefinitionStatus:
		return ec._CompositeResourceDefinitionStatus(ctx, sel, &obj)
	case *model.CompositeResourceDefinitionStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._CompositeResourceDefinitionStatus(ctx, sel, obj)
	case model.CompositionStatus:
		return ec._CompositionStatus(ctx, sel, &obj)
	case *model.CompositionStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._CompositionStatus(ctx, sel, obj)
	case model.CustomResourceDefinitionStatus:
		return ec._CustomResourceDefinitionStatus(ctx, sel, &obj)
	case *model.CustomResourceDefinitionStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._CustomResourceDefinitionStatus(ctx, sel, obj)
	case model.CompositeResourceStatus:
		return ec._CompositeResourceStatus(ctx, sel, &obj)
	case *model.CompositeResourceStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._CompositeResourceStatus(ctx, sel, obj)
	case model.CompositeResourceClaimStatus:
		return ec._CompositeResourceClaimStatus(ctx, sel, &obj)
	case *model.CompositeResourceClaimStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._CompositeResourceClaimStatus(ctx, sel, obj)
	case model.ConfigurationStatus:
		return ec._ConfigurationStatus(ctx, sel, &obj)
	case *model.ConfigurationStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._ConfigurationStatus(ctx, sel, obj)
	case model.ConfigurationRevisionStatus:
		return ec._ConfigurationRevisionStatus(ctx, sel, &obj)
	case *model.ConfigurationRevisionStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._ConfigurationRevisionStatus(ctx, sel, obj)
	case model.ManagedResourceStatus:
		return ec._ManagedResourceStatus(ctx, sel, &obj)
	case *model.ManagedResourceStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._ManagedResourceStatus(ctx, sel, obj)
	case model.ProviderStatus:
		return ec._ProviderStatus(ctx, sel, &obj)
	case *model.ProviderStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProviderStatus(ctx, sel, obj)
	case model.ProviderRevisionStatus:
		return ec._ProviderRevisionStatus(ctx, sel, &obj)
	case *model.ProviderRevisionStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProviderRevisionStatus(ctx, sel, obj)
	case model.ProviderConfigStatus:
		return ec._ProviderConfigStatus(ctx, sel, &obj)
	case *model.ProviderConfigStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProviderConfigStatus(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _KubernetesResource(ctx context.Context, sel ast.SelectionSet, obj model.KubernetesResource) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.CompositeResourceDefinition:
		return ec._CompositeResourceDefinition(ctx, sel, &obj)
	case *model.CompositeResourceDefinition:
		if obj == nil {
			return graphql.Null
		}
		return ec._CompositeResourceDefinition(ctx, sel, obj)
	case model.Composition:
		return ec._Composition(ctx, sel, &obj)
	case *model.Composition:
		if obj == nil {
			return graphql.Null
		}
		return ec._Composition(ctx, sel, obj)
	case model.GenericResource:
		return ec._GenericResource(ctx, sel, &obj)
	case *model.GenericResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._GenericResource(ctx, sel, obj)
	case model.Secret:
		return ec._Secret(ctx, sel, &obj)
	case *model.Secret:
		if obj == nil {
			return graphql.Null
		}
		return ec._Secret(ctx, sel, obj)
	case model.ConfigMap:
		return ec._ConfigMap(ctx, sel, &obj)
	case *model.ConfigMap:
		if obj == nil {
			return graphql.Null
		}
		return ec._ConfigMap(ctx, sel, obj)
	case model.CustomResourceDefinition:
		return ec._CustomResourceDefinition(ctx, sel, &obj)
	case *model.CustomResourceDefinition:
		if obj == nil {
			return graphql.Null
		}
		return ec._CustomResourceDefinition(ctx, sel, obj)
	case model.CompositeResource:
		return ec._CompositeResource(ctx, sel, &obj)
	case *model.CompositeResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._CompositeResource(ctx, sel, obj)
	case model.CompositeResourceClaim:
		return ec._CompositeResourceClaim(ctx, sel, &obj)
	case *model.CompositeResourceClaim:
		if obj == nil {
			return graphql.Null
		}
		return ec._CompositeResourceClaim(ctx, sel, obj)
	case model.Configuration:
		return ec._Configuration(ctx, sel, &obj)
	case *model.Configuration:
		if obj == nil {
			return graphql.Null
		}
		return ec._Configuration(ctx, sel, obj)
	case model.ConfigurationRevision:
		return ec._ConfigurationRevision(ctx, sel, &obj)
	case *model.ConfigurationRevision:
		if obj == nil {
			return graphql.Null
		}
		return ec._ConfigurationRevision(ctx, sel, obj)
	case model.ManagedResource:
		return ec._ManagedResource(ctx, sel, &obj)
	case *model.ManagedResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._ManagedResource(ctx, sel, obj)
	case model.Provider:
		return ec._Provider(ctx, sel, &obj)
	case *model.Provider:
		if obj == nil {
			return graphql.Null
		}
		return ec._Provider(ctx, sel, obj)
	case model.ProviderRevision:
		return ec._ProviderRevision(ctx, sel, &obj)
	case *model.ProviderRevision:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProviderRevision(ctx, sel, obj)
	case model.ProviderConfig:
		return ec._ProviderConfig(ctx, sel, &obj)
	case *model.ProviderConfig:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProviderConfig(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ManagedResourceDefinition(ctx context.Context, sel ast.SelectionSet, obj model.ManagedResourceDefinition) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.CustomResourceDefinition:
		return ec._CustomResourceDefinition(ctx, sel, &obj)
	case *model.CustomResourceDefinition:
		if obj == nil {
			return graphql.Null
		}
		return ec._CustomResourceDefinition(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj model.Node) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.CompositeResourceDefinition:
		return ec._CompositeResourceDefinition(ctx, sel, &obj)
	case *model.CompositeResourceDefinition:
		if obj == nil {
			return graphql.Null
		}
		return ec._CompositeResourceDefinition(ctx, sel, obj)
	case model.Composition:
		return ec._Composition(ctx, sel, &obj)
	case *model.Composition:
		if obj == nil {
			return graphql.Null
		}
		return ec._Composition(ctx, sel, obj)
	case model.GenericResource:
		return ec._GenericResource(ctx, sel, &obj)
	case *model.GenericResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._GenericResource(ctx, sel, obj)
	case model.Event:
		return ec._Event(ctx, sel, &obj)
	case *model.Event:
		if obj == nil {
			return graphql.Null
		}
		return ec._Event(ctx, sel, obj)
	case model.Secret:
		return ec._Secret(ctx, sel, &obj)
	case *model.Secret:
		if obj == nil {
			return graphql.Null
		}
		return ec._Secret(ctx, sel, obj)
	case model.ConfigMap:
		return ec._ConfigMap(ctx, sel, &obj)
	case *model.ConfigMap:
		if obj == nil {
			return graphql.Null
		}
		return ec._ConfigMap(ctx, sel, obj)
	case model.CustomResourceDefinition:
		return ec._CustomResourceDefinition(ctx, sel, &obj)
	case *model.CustomResourceDefinition:
		if obj == nil {
			return graphql.Null
		}
		return ec._CustomResourceDefinition(ctx, sel, obj)
	case model.CompositeResource:
		return ec._CompositeResource(ctx, sel, &obj)
	case *model.CompositeResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._CompositeResource(ctx, sel, obj)
	case model.CompositeResourceClaim:
		return ec._CompositeResourceClaim(ctx, sel, &obj)
	case *model.CompositeResourceClaim:
		if obj == nil {
			return graphql.Null
		}
		return ec._CompositeResourceClaim(ctx, sel, obj)
	case model.Configuration:
		return ec._Configuration(ctx, sel, &obj)
	case *model.Configuration:
		if obj == nil {
			return graphql.Null
		}
		return ec._Configuration(ctx, sel, obj)
	case model.ConfigurationRevision:
		return ec._ConfigurationRevision(ctx, sel, &obj)
	case *model.ConfigurationRevision:
		if obj == nil {
			return graphql.Null
		}
		return ec._ConfigurationRevision(ctx, sel, obj)
	case model.ManagedResource:
		return ec._ManagedResource(ctx, sel, &obj)
	case *model.ManagedResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._ManagedResource(ctx, sel, obj)
	case model.Provider:
		return ec._Provider(ctx, sel, &obj)
	case *model.Provider:
		if obj == nil {
			return graphql.Null
		}
		return ec._Provider(ctx, sel, obj)
	case model.ProviderRevision:
		return ec._ProviderRevision(ctx, sel, &obj)
	case *model.ProviderRevision:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProviderRevision(ctx, sel, obj)
	case model.ProviderConfig:
		return ec._ProviderConfig(ctx, sel, &obj)
	case *model.ProviderConfig:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProviderConfig(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ProviderConfigDefinition(ctx context.Context, sel ast.SelectionSet, obj model.ProviderConfigDefinition) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.CustomResourceDefinition:
		return ec._CustomResourceDefinition(ctx, sel, &obj)
	case *model.CustomResourceDefinition:
		if obj == nil {
			return graphql.Null
		}
		return ec._CustomResourceDefinition(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var compositeResourceImplementors = []string{"CompositeResource", "Node", "KubernetesResource"}

func (ec *executionContext) _CompositeResource(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResource")
		case "id":
			out.Values[i] = ec._CompositeResource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._CompositeResource_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._CompositeResource_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._CompositeResource_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._CompositeResource_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._CompositeResource_status(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._CompositeResource_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._CompositeResource_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResource_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "definition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResource_definition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceClaimImplementors = []string{"CompositeResourceClaim", "Node", "KubernetesResource"}

func (ec *executionContext) _CompositeResourceClaim(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceClaim) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceClaimImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceClaim")
		case "id":
			out.Values[i] = ec._CompositeResourceClaim_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._CompositeResourceClaim_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._CompositeResourceClaim_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._CompositeResourceClaim_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._CompositeResourceClaim_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._CompositeResourceClaim_status(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._CompositeResourceClaim_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._CompositeResourceClaim_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceClaim_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "definition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceClaim_definition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceClaimConnectionImplementors = []string{"CompositeResourceClaimConnection"}

func (ec *executionContext) _CompositeResourceClaimConnection(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceClaimConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceClaimConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceClaimConnection")
		case "nodes":
			out.Values[i] = ec._CompositeResourceClaimConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._CompositeResourceClaimConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceClaimConnectionDetailsImplementors = []string{"CompositeResourceClaimConnectionDetails"}

func (ec *executionContext) _CompositeResourceClaimConnectionDetails(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceClaimConnectionDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceClaimConnectionDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceClaimConnectionDetails")
		case "lastPublishedTime":
			out.Values[i] = ec._CompositeResourceClaimConnectionDetails_lastPublishedTime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceClaimSpecImplementors = []string{"CompositeResourceClaimSpec"}

func (ec *executionContext) _CompositeResourceClaimSpec(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceClaimSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceClaimSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceClaimSpec")
		case "composition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceClaimSpec_composition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "compositionRef":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceClaimSpec_compositionRef(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "compositionSelector":
			out.Values[i] = ec._CompositeResourceClaimSpec_compositionSelector(ctx, field, obj)
		case "resource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceClaimSpec_resource(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "resourceRef":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceClaimSpec_resourceRef(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "connectionSecret":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceClaimSpec_connectionSecret(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "writeConnectionSecretToReference":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceClaimSpec_writeConnectionSecretToReference(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceClaimStatusImplementors = []string{"CompositeResourceClaimStatus", "ConditionedStatus"}

func (ec *executionContext) _CompositeResourceClaimStatus(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceClaimStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceClaimStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceClaimStatus")
		case "conditions":
			out.Values[i] = ec._CompositeResourceClaimStatus_conditions(ctx, field, obj)
		case "connectionDetails":
			out.Values[i] = ec._CompositeResourceClaimStatus_connectionDetails(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceConnectionImplementors = []string{"CompositeResourceConnection"}

func (ec *executionContext) _CompositeResourceConnection(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceConnection")
		case "nodes":
			out.Values[i] = ec._CompositeResourceConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._CompositeResourceConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceConnectionDetailsImplementors = []string{"CompositeResourceConnectionDetails"}

func (ec *executionContext) _CompositeResourceConnectionDetails(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceConnectionDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceConnectionDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceConnectionDetails")
		case "lastPublishedTime":
			out.Values[i] = ec._CompositeResourceConnectionDetails_lastPublishedTime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceDefinitionImplementors = []string{"CompositeResourceDefinition", "Node", "KubernetesResource"}

func (ec *executionContext) _CompositeResourceDefinition(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceDefinition")
		case "id":
			out.Values[i] = ec._CompositeResourceDefinition_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._CompositeResourceDefinition_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._CompositeResourceDefinition_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._CompositeResourceDefinition_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._CompositeResourceDefinition_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._CompositeResourceDefinition_status(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._CompositeResourceDefinition_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._CompositeResourceDefinition_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceDefinition_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "compositeResourceCRD":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceDefinition_compositeResourceCRD(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "compositeResourceClaimCRD":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceDefinition_compositeResourceClaimCRD(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "definedCompositeResources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceDefinition_definedCompositeResources(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "definedCompositeResourceClaims":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceDefinition_definedCompositeResourceClaims(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceDefinitionConnectionImplementors = []string{"CompositeResourceDefinitionConnection"}

func (ec *executionContext) _CompositeResourceDefinitionConnection(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceDefinitionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceDefinitionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceDefinitionConnection")
		case "nodes":
			out.Values[i] = ec._CompositeResourceDefinitionConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._CompositeResourceDefinitionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceDefinitionControllerStatusImplementors = []string{"CompositeResourceDefinitionControllerStatus"}

func (ec *executionContext) _CompositeResourceDefinitionControllerStatus(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceDefinitionControllerStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceDefinitionControllerStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceDefinitionControllerStatus")
		case "compositeResourceType":
			out.Values[i] = ec._CompositeResourceDefinitionControllerStatus_compositeResourceType(ctx, field, obj)
		case "compositeResourceClaimType":
			out.Values[i] = ec._CompositeResourceDefinitionControllerStatus_compositeResourceClaimType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceDefinitionNamesImplementors = []string{"CompositeResourceDefinitionNames"}

func (ec *executionContext) _CompositeResourceDefinitionNames(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceDefinitionNames) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceDefinitionNamesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceDefinitionNames")
		case "plural":
			out.Values[i] = ec._CompositeResourceDefinitionNames_plural(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "singular":
			out.Values[i] = ec._CompositeResourceDefinitionNames_singular(ctx, field, obj)
		case "shortNames":
			out.Values[i] = ec._CompositeResourceDefinitionNames_shortNames(ctx, field, obj)
		case "kind":
			out.Values[i] = ec._CompositeResourceDefinitionNames_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "listKind":
			out.Values[i] = ec._CompositeResourceDefinitionNames_listKind(ctx, field, obj)
		case "categories":
			out.Values[i] = ec._CompositeResourceDefinitionNames_categories(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceDefinitionSpecImplementors = []string{"CompositeResourceDefinitionSpec"}

func (ec *executionContext) _CompositeResourceDefinitionSpec(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceDefinitionSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceDefinitionSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceDefinitionSpec")
		case "group":
			out.Values[i] = ec._CompositeResourceDefinitionSpec_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "names":
			out.Values[i] = ec._CompositeResourceDefinitionSpec_names(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "claimNames":
			out.Values[i] = ec._CompositeResourceDefinitionSpec_claimNames(ctx, field, obj)
		case "connectionSecretKeys":
			out.Values[i] = ec._CompositeResourceDefinitionSpec_connectionSecretKeys(ctx, field, obj)
		case "defaultComposition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceDefinitionSpec_defaultComposition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "enforcedComposition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceDefinitionSpec_enforcedComposition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "versions":
			out.Values[i] = ec._CompositeResourceDefinitionSpec_versions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceDefinitionStatusImplementors = []string{"CompositeResourceDefinitionStatus", "ConditionedStatus"}

func (ec *executionContext) _CompositeResourceDefinitionStatus(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceDefinitionStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceDefinitionStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceDefinitionStatus")
		case "conditions":
			out.Values[i] = ec._CompositeResourceDefinitionStatus_conditions(ctx, field, obj)
		case "controllers":
			out.Values[i] = ec._CompositeResourceDefinitionStatus_controllers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceDefinitionVersionImplementors = []string{"CompositeResourceDefinitionVersion"}

func (ec *executionContext) _CompositeResourceDefinitionVersion(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceDefinitionVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceDefinitionVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceDefinitionVersion")
		case "name":
			out.Values[i] = ec._CompositeResourceDefinitionVersion_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "referenceable":
			out.Values[i] = ec._CompositeResourceDefinitionVersion_referenceable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "served":
			out.Values[i] = ec._CompositeResourceDefinitionVersion_served(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "schema":
			out.Values[i] = ec._CompositeResourceDefinitionVersion_schema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceSpecImplementors = []string{"CompositeResourceSpec"}

func (ec *executionContext) _CompositeResourceSpec(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceSpec")
		case "composition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceSpec_composition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "compositionRef":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceSpec_compositionRef(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "compositionSelector":
			out.Values[i] = ec._CompositeResourceSpec_compositionSelector(ctx, field, obj)
		case "claim":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceSpec_claim(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "claimRef":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceSpec_claimRef(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "connectionSecret":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceSpec_connectionSecret(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "resourceRefs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceSpec_resourceRefs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "resources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceSpec_resources(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "writeConnectionSecretToReference":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompositeResourceSpec_writeConnectionSecretToReference(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceStatusImplementors = []string{"CompositeResourceStatus", "ConditionedStatus"}

func (ec *executionContext) _CompositeResourceStatus(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceStatus")
		case "conditions":
			out.Values[i] = ec._CompositeResourceStatus_conditions(ctx, field, obj)
		case "connectionDetails":
			out.Values[i] = ec._CompositeResourceStatus_connectionDetails(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceValidationImplementors = []string{"CompositeResourceValidation"}

func (ec *executionContext) _CompositeResourceValidation(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResourceValidation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceValidationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResourceValidation")
		case "openAPIV3Schema":
			out.Values[i] = ec._CompositeResourceValidation_openAPIV3Schema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositionImplementors = []string{"Composition", "Node", "KubernetesResource"}

func (ec *executionContext) _Composition(ctx context.Context, sel ast.SelectionSet, obj *model.Composition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Composition")
		case "id":
			out.Values[i] = ec._Composition_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._Composition_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._Composition_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._Composition_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._Composition_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Composition_status(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._Composition_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._Composition_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Composition_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositionConnectionImplementors = []string{"CompositionConnection"}

func (ec *executionContext) _CompositionConnection(ctx context.Context, sel ast.SelectionSet, obj *model.CompositionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositionConnection")
		case "nodes":
			out.Values[i] = ec._CompositionConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._CompositionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositionSpecImplementors = []string{"CompositionSpec"}

func (ec *executionContext) _CompositionSpec(ctx context.Context, sel ast.SelectionSet, obj *model.CompositionSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositionSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositionSpec")
		case "compositeTypeRef":
			out.Values[i] = ec._CompositionSpec_compositeTypeRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "writeConnectionSecretsToNamespace":
			out.Values[i] = ec._CompositionSpec_writeConnectionSecretsToNamespace(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositionStatusImplementors = []string{"CompositionStatus", "ConditionedStatus"}

func (ec *executionContext) _CompositionStatus(ctx context.Context, sel ast.SelectionSet, obj *model.CompositionStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositionStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositionStatus")
		case "conditions":
			out.Values[i] = ec._CompositionStatus_conditions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var conditionImplementors = []string{"Condition"}

func (ec *executionContext) _Condition(ctx context.Context, sel ast.SelectionSet, obj *model.Condition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, conditionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Condition")
		case "type":
			out.Values[i] = ec._Condition_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Condition_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastTransitionTime":
			out.Values[i] = ec._Condition_lastTransitionTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reason":
			out.Values[i] = ec._Condition_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._Condition_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configMapImplementors = []string{"ConfigMap", "Node", "KubernetesResource"}

func (ec *executionContext) _ConfigMap(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configMapImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigMap")
		case "id":
			out.Values[i] = ec._ConfigMap_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._ConfigMap_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._ConfigMap_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._ConfigMap_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "data":
			out.Values[i] = ec._ConfigMap_data(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._ConfigMap_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._ConfigMap_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConfigMap_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configurationImplementors = []string{"Configuration", "Node", "KubernetesResource"}

func (ec *executionContext) _Configuration(ctx context.Context, sel ast.SelectionSet, obj *model.Configuration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configurationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Configuration")
		case "id":
			out.Values[i] = ec._Configuration_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._Configuration_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._Configuration_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._Configuration_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._Configuration_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Configuration_status(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._Configuration_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._Configuration_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Configuration_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "revisions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Configuration_revisions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "activeRevision":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Configuration_activeRevision(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configurationConnectionImplementors = []string{"ConfigurationConnection"}

func (ec *executionContext) _ConfigurationConnection(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigurationConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configurationConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigurationConnection")
		case "nodes":
			out.Values[i] = ec._ConfigurationConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._ConfigurationConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configurationRevisionImplementors = []string{"ConfigurationRevision", "Node", "KubernetesResource"}

func (ec *executionContext) _ConfigurationRevision(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigurationRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configurationRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigurationRevision")
		case "id":
			out.Values[i] = ec._ConfigurationRevision_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._ConfigurationRevision_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._ConfigurationRevision_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._ConfigurationRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._ConfigurationRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._ConfigurationRevision_status(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._ConfigurationRevision_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._ConfigurationRevision_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConfigurationRevision_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configurationRevisionConnectionImplementors = []string{"ConfigurationRevisionConnection"}

func (ec *executionContext) _ConfigurationRevisionConnection(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigurationRevisionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configurationRevisionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigurationRevisionConnection")
		case "nodes":
			out.Values[i] = ec._ConfigurationRevisionConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._ConfigurationRevisionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configurationRevisionSpecImplementors = []string{"ConfigurationRevisionSpec"}

func (ec *executionContext) _ConfigurationRevisionSpec(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigurationRevisionSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configurationRevisionSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigurationRevisionSpec")
		case "desiredState":
			out.Values[i] = ec._ConfigurationRevisionSpec_desiredState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "package":
			out.Values[i] = ec._ConfigurationRevisionSpec_package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "packagePullPolicy":
			out.Values[i] = ec._ConfigurationRevisionSpec_packagePullPolicy(ctx, field, obj)
		case "revision":
			out.Values[i] = ec._ConfigurationRevisionSpec_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ignoreCrossplaneConstraints":
			out.Values[i] = ec._ConfigurationRevisionSpec_ignoreCrossplaneConstraints(ctx, field, obj)
		case "skipDependencyResolution":
			out.Values[i] = ec._ConfigurationRevisionSpec_skipDependencyResolution(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configurationRevisionStatusImplementors = []string{"ConfigurationRevisionStatus", "ConditionedStatus"}

func (ec *executionContext) _ConfigurationRevisionStatus(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigurationRevisionStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configurationRevisionStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigurationRevisionStatus")
		case "conditions":
			out.Values[i] = ec._ConfigurationRevisionStatus_conditions(ctx, field, obj)
		case "foundDependencies":
			out.Values[i] = ec._ConfigurationRevisionStatus_foundDependencies(ctx, field, obj)
		case "installedDependencies":
			out.Values[i] = ec._ConfigurationRevisionStatus_installedDependencies(ctx, field, obj)
		case "invalidDependencies":
			out.Values[i] = ec._ConfigurationRevisionStatus_invalidDependencies(ctx, field, obj)
		case "permissionRequests":
			out.Values[i] = ec._ConfigurationRevisionStatus_permissionRequests(ctx, field, obj)
		case "objects":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConfigurationRevisionStatus_objects(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configurationSpecImplementors = []string{"ConfigurationSpec"}

func (ec *executionContext) _ConfigurationSpec(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigurationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configurationSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigurationSpec")
		case "package":
			out.Values[i] = ec._ConfigurationSpec_package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revisionActivationPolicy":
			out.Values[i] = ec._ConfigurationSpec_revisionActivationPolicy(ctx, field, obj)
		case "revisionHistoryLimit":
			out.Values[i] = ec._ConfigurationSpec_revisionHistoryLimit(ctx, field, obj)
		case "packagePullPolicy":
			out.Values[i] = ec._ConfigurationSpec_packagePullPolicy(ctx, field, obj)
		case "ignoreCrossplaneConstraints":
			out.Values[i] = ec._ConfigurationSpec_ignoreCrossplaneConstraints(ctx, field, obj)
		case "skipDependencyResolution":
			out.Values[i] = ec._ConfigurationSpec_skipDependencyResolution(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configurationStatusImplementors = []string{"ConfigurationStatus", "ConditionedStatus"}

func (ec *executionContext) _ConfigurationStatus(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigurationStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configurationStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigurationStatus")
		case "conditions":
			out.Values[i] = ec._ConfigurationStatus_conditions(ctx, field, obj)
		case "currentRevision":
			out.Values[i] = ec._ConfigurationStatus_currentRevision(ctx, field, obj)
		case "currentIdentifier":
			out.Values[i] = ec._ConfigurationStatus_currentIdentifier(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createKubernetesResourcePayloadImplementors = []string{"CreateKubernetesResourcePayload"}

func (ec *executionContext) _CreateKubernetesResourcePayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateKubernetesResourcePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createKubernetesResourcePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateKubernetesResourcePayload")
		case "resource":
			out.Values[i] = ec._CreateKubernetesResourcePayload_resource(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var crossplaneResourceTreeConnectionImplementors = []string{"CrossplaneResourceTreeConnection"}

func (ec *executionContext) _CrossplaneResourceTreeConnection(ctx context.Context, sel ast.SelectionSet, obj *model.CrossplaneResourceTreeConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, crossplaneResourceTreeConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CrossplaneResourceTreeConnection")
		case "nodes":
			out.Values[i] = ec._CrossplaneResourceTreeConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._CrossplaneResourceTreeConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var crossplaneResourceTreeNodeImplementors = []string{"CrossplaneResourceTreeNode"}

func (ec *executionContext) _CrossplaneResourceTreeNode(ctx context.Context, sel ast.SelectionSet, obj *model.CrossplaneResourceTreeNode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, crossplaneResourceTreeNodeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CrossplaneResourceTreeNode")
		case "parentId":
			out.Values[i] = ec._CrossplaneResourceTreeNode_parentId(ctx, field, obj)
		case "resource":
			out.Values[i] = ec._CrossplaneResourceTreeNode_resource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var customResourceDefinitionImplementors = []string{"CustomResourceDefinition", "Node", "KubernetesResource", "ManagedResourceDefinition", "ProviderConfigDefinition"}

func (ec *executionContext) _CustomResourceDefinition(ctx context.Context, sel ast.SelectionSet, obj *model.CustomResourceDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, customResourceDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CustomResourceDefinition")
		case "id":
			out.Values[i] = ec._CustomResourceDefinition_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._CustomResourceDefinition_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._CustomResourceDefinition_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._CustomResourceDefinition_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._CustomResourceDefinition_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._CustomResourceDefinition_status(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._CustomResourceDefinition_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._CustomResourceDefinition_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CustomResourceDefinition_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "definedResources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CustomResourceDefinition_definedResources(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var customResourceDefinitionConnectionImplementors = []string{"CustomResourceDefinitionConnection"}

func (ec *executionContext) _CustomResourceDefinitionConnection(ctx context.Context, sel ast.SelectionSet, obj *model.CustomResourceDefinitionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, customResourceDefinitionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CustomResourceDefinitionConnection")
		case "nodes":
			out.Values[i] = ec._CustomResourceDefinitionConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._CustomResourceDefinitionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var customResourceDefinitionNamesImplementors = []string{"CustomResourceDefinitionNames"}

func (ec *executionContext) _CustomResourceDefinitionNames(ctx context.Context, sel ast.SelectionSet, obj *model.CustomResourceDefinitionNames) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, customResourceDefinitionNamesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CustomResourceDefinitionNames")
		case "plural":
			out.Values[i] = ec._CustomResourceDefinitionNames_plural(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "singular":
			out.Values[i] = ec._CustomResourceDefinitionNames_singular(ctx, field, obj)
		case "shortNames":
			out.Values[i] = ec._CustomResourceDefinitionNames_shortNames(ctx, field, obj)
		case "kind":
			out.Values[i] = ec._CustomResourceDefinitionNames_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "listKind":
			out.Values[i] = ec._CustomResourceDefinitionNames_listKind(ctx, field, obj)
		case "categories":
			out.Values[i] = ec._CustomResourceDefinitionNames_categories(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var customResourceDefinitionSpecImplementors = []string{"CustomResourceDefinitionSpec"}

func (ec *executionContext) _CustomResourceDefinitionSpec(ctx context.Context, sel ast.SelectionSet, obj *model.CustomResourceDefinitionSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, customResourceDefinitionSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CustomResourceDefinitionSpec")
		case "group":
			out.Values[i] = ec._CustomResourceDefinitionSpec_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "names":
			out.Values[i] = ec._CustomResourceDefinitionSpec_names(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scope":
			out.Values[i] = ec._CustomResourceDefinitionSpec_scope(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versions":
			out.Values[i] = ec._CustomResourceDefinitionSpec_versions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var customResourceDefinitionStatusImplementors = []string{"CustomResourceDefinitionStatus", "ConditionedStatus"}

func (ec *executionContext) _CustomResourceDefinitionStatus(ctx context.Context, sel ast.SelectionSet, obj *model.CustomResourceDefinitionStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, customResourceDefinitionStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CustomResourceDefinitionStatus")
		case "conditions":
			out.Values[i] = ec._CustomResourceDefinitionStatus_conditions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var customResourceDefinitionVersionImplementors = []string{"CustomResourceDefinitionVersion"}

func (ec *executionContext) _CustomResourceDefinitionVersion(ctx context.Context, sel ast.SelectionSet, obj *model.CustomResourceDefinitionVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, customResourceDefinitionVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CustomResourceDefinitionVersion")
		case "name":
			out.Values[i] = ec._CustomResourceDefinitionVersion_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "served":
			out.Values[i] = ec._CustomResourceDefinitionVersion_served(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "schema":
			out.Values[i] = ec._CustomResourceDefinitionVersion_schema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var customResourceValidationImplementors = []string{"CustomResourceValidation"}

func (ec *executionContext) _CustomResourceValidation(ctx context.Context, sel ast.SelectionSet, obj *model.CustomResourceValidation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, customResourceValidationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CustomResourceValidation")
		case "openAPIV3Schema":
			out.Values[i] = ec._CustomResourceValidation_openAPIV3Schema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteKubernetesResourcePayloadImplementors = []string{"DeleteKubernetesResourcePayload"}

func (ec *executionContext) _DeleteKubernetesResourcePayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteKubernetesResourcePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteKubernetesResourcePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteKubernetesResourcePayload")
		case "resource":
			out.Values[i] = ec._DeleteKubernetesResourcePayload_resource(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventImplementors = []string{"Event", "Node"}

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj *model.Event) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Event")
		case "id":
			out.Values[i] = ec._Event_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._Event_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._Event_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._Event_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "involvedObject":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_involvedObject(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._Event_type(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._Event_reason(ctx, field, obj)
		case "message":
			out.Values[i] = ec._Event_message(ctx, field, obj)
		case "source":
			out.Values[i] = ec._Event_source(ctx, field, obj)
		case "count":
			out.Values[i] = ec._Event_count(ctx, field, obj)
		case "firstTime":
			out.Values[i] = ec._Event_firstTime(ctx, field, obj)
		case "lastTime":
			out.Values[i] = ec._Event_lastTime(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._Event_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._Event_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventConnectionImplementors = []string{"EventConnection"}

func (ec *executionContext) _EventConnection(ctx context.Context, sel ast.SelectionSet, obj *model.EventConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventConnection")
		case "nodes":
			out.Values[i] = ec._EventConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._EventConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventSourceImplementors = []string{"EventSource"}

func (ec *executionContext) _EventSource(ctx context.Context, sel ast.SelectionSet, obj *model.EventSource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventSourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventSource")
		case "component":
			out.Values[i] = ec._EventSource_component(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var genericResourceImplementors = []string{"GenericResource", "Node", "KubernetesResource"}

func (ec *executionContext) _GenericResource(ctx context.Context, sel ast.SelectionSet, obj *model.GenericResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, genericResourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GenericResource")
		case "id":
			out.Values[i] = ec._GenericResource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._GenericResource_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._GenericResource_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._GenericResource_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "unstructured":
			out.Values[i] = ec._GenericResource_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._GenericResource_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GenericResource_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kubernetesResourceConnectionImplementors = []string{"KubernetesResourceConnection"}

func (ec *executionContext) _KubernetesResourceConnection(ctx context.Context, sel ast.SelectionSet, obj *model.KubernetesResourceConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kubernetesResourceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KubernetesResourceConnection")
		case "nodes":
			out.Values[i] = ec._KubernetesResourceConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._KubernetesResourceConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var labelSelectorImplementors = []string{"LabelSelector"}

func (ec *executionContext) _LabelSelector(ctx context.Context, sel ast.SelectionSet, obj *model.LabelSelector) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, labelSelectorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelSelector")
		case "matchLabels":
			out.Values[i] = ec._LabelSelector_matchLabels(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var localObjectReferenceImplementors = []string{"LocalObjectReference"}

func (ec *executionContext) _LocalObjectReference(ctx context.Context, sel ast.SelectionSet, obj *model.LocalObjectReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, localObjectReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LocalObjectReference")
		case "name":
			out.Values[i] = ec._LocalObjectReference_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var managedResourceImplementors = []string{"ManagedResource", "Node", "KubernetesResource"}

func (ec *executionContext) _ManagedResource(ctx context.Context, sel ast.SelectionSet, obj *model.ManagedResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, managedResourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ManagedResource")
		case "id":
			out.Values[i] = ec._ManagedResource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._ManagedResource_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._ManagedResource_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._ManagedResource_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._ManagedResource_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._ManagedResource_status(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._ManagedResource_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._ManagedResource_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ManagedResource_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "definition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ManagedResource_definition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var managedResourceSpecImplementors = []string{"ManagedResourceSpec"}

func (ec *executionContext) _ManagedResourceSpec(ctx context.Context, sel ast.SelectionSet, obj *model.ManagedResourceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, managedResourceSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ManagedResourceSpec")
		case "connectionSecret":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ManagedResourceSpec_connectionSecret(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "providerConfigRef":
			out.Values[i] = ec._ManagedResourceSpec_providerConfigRef(ctx, field, obj)
		case "deletionPolicy":
			out.Values[i] = ec._ManagedResourceSpec_deletionPolicy(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var managedResourceStatusImplementors = []string{"ManagedResourceStatus", "ConditionedStatus"}

func (ec *executionContext) _ManagedResourceStatus(ctx context.Context, sel ast.SelectionSet, obj *model.ManagedResourceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, managedResourceStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ManagedResourceStatus")
		case "conditions":
			out.Values[i] = ec._ManagedResourceStatus_conditions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createKubernetesResource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createKubernetesResource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateKubernetesResource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateKubernetesResource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteKubernetesResource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteKubernetesResource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var objectMetaImplementors = []string{"ObjectMeta"}

func (ec *executionContext) _ObjectMeta(ctx context.Context, sel ast.SelectionSet, obj *model.ObjectMeta) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, objectMetaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObjectMeta")
		case "name":
			out.Values[i] = ec._ObjectMeta_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "generateName":
			out.Values[i] = ec._ObjectMeta_generateName(ctx, field, obj)
		case "namespace":
			out.Values[i] = ec._ObjectMeta_namespace(ctx, field, obj)
		case "uid":
			out.Values[i] = ec._ObjectMeta_uid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resourceVersion":
			out.Values[i] = ec._ObjectMeta_resourceVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "generation":
			out.Values[i] = ec._ObjectMeta_generation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "creationTime":
			out.Values[i] = ec._ObjectMeta_creationTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletionTime":
			out.Values[i] = ec._ObjectMeta_deletionTime(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._ObjectMeta_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._ObjectMeta_annotations(ctx, field, obj)
		case "owners":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObjectMeta_owners(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "controller":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObjectMeta_controller(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var objectReferenceImplementors = []string{"ObjectReference"}

func (ec *executionContext) _ObjectReference(ctx context.Context, sel ast.SelectionSet, obj *model.ObjectReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, objectReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObjectReference")
		case "kind":
			out.Values[i] = ec._ObjectReference_kind(ctx, field, obj)
		case "namespace":
			out.Values[i] = ec._ObjectReference_namespace(ctx, field, obj)
		case "name":
			out.Values[i] = ec._ObjectReference_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ownerImplementors = []string{"Owner"}

func (ec *executionContext) _Owner(ctx context.Context, sel ast.SelectionSet, obj *model.Owner) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ownerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Owner")
		case "resource":
			out.Values[i] = ec._Owner_resource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "controller":
			out.Values[i] = ec._Owner_controller(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ownerConnectionImplementors = []string{"OwnerConnection"}

func (ec *executionContext) _OwnerConnection(ctx context.Context, sel ast.SelectionSet, obj *model.OwnerConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ownerConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OwnerConnection")
		case "nodes":
			out.Values[i] = ec._OwnerConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._OwnerConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var policyRuleImplementors = []string{"PolicyRule"}

func (ec *executionContext) _PolicyRule(ctx context.Context, sel ast.SelectionSet, obj *model.PolicyRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, policyRuleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PolicyRule")
		case "verbs":
			out.Values[i] = ec._PolicyRule_verbs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "apiGroups":
			out.Values[i] = ec._PolicyRule_apiGroups(ctx, field, obj)
		case "resources":
			out.Values[i] = ec._PolicyRule_resources(ctx, field, obj)
		case "resourceNames":
			out.Values[i] = ec._PolicyRule_resourceNames(ctx, field, obj)
		case "nonResourceURLs":
			out.Values[i] = ec._PolicyRule_nonResourceURLs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerImplementors = []string{"Provider", "Node", "KubernetesResource"}

func (ec *executionContext) _Provider(ctx context.Context, sel ast.SelectionSet, obj *model.Provider) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Provider")
		case "id":
			out.Values[i] = ec._Provider_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._Provider_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._Provider_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._Provider_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._Provider_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Provider_status(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._Provider_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._Provider_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Provider_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "revisions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Provider_revisions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "activeRevision":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Provider_activeRevision(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerConfigImplementors = []string{"ProviderConfig", "Node", "KubernetesResource"}

func (ec *executionContext) _ProviderConfig(ctx context.Context, sel ast.SelectionSet, obj *model.ProviderConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProviderConfig")
		case "id":
			out.Values[i] = ec._ProviderConfig_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._ProviderConfig_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._ProviderConfig_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._ProviderConfig_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._ProviderConfig_status(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._ProviderConfig_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._ProviderConfig_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProviderConfig_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "definition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProviderConfig_definition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerConfigReferenceImplementors = []string{"ProviderConfigReference"}

func (ec *executionContext) _ProviderConfigReference(ctx context.Context, sel ast.SelectionSet, obj *model.ProviderConfigReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerConfigReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProviderConfigReference")
		case "name":
			out.Values[i] = ec._ProviderConfigReference_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerConfigStatusImplementors = []string{"ProviderConfigStatus", "ConditionedStatus"}

func (ec *executionContext) _ProviderConfigStatus(ctx context.Context, sel ast.SelectionSet, obj *model.ProviderConfigStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerConfigStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProviderConfigStatus")
		case "conditions":
			out.Values[i] = ec._ProviderConfigStatus_conditions(ctx, field, obj)
		case "users":
			out.Values[i] = ec._ProviderConfigStatus_users(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerConnectionImplementors = []string{"ProviderConnection"}

func (ec *executionContext) _ProviderConnection(ctx context.Context, sel ast.SelectionSet, obj *model.ProviderConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProviderConnection")
		case "nodes":
			out.Values[i] = ec._ProviderConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._ProviderConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerRevisionImplementors = []string{"ProviderRevision", "Node", "KubernetesResource"}

func (ec *executionContext) _ProviderRevision(ctx context.Context, sel ast.SelectionSet, obj *model.ProviderRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProviderRevision")
		case "id":
			out.Values[i] = ec._ProviderRevision_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._ProviderRevision_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._ProviderRevision_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._ProviderRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._ProviderRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._ProviderRevision_status(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._ProviderRevision_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._ProviderRevision_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProviderRevision_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerRevisionConnectionImplementors = []string{"ProviderRevisionConnection"}

func (ec *executionContext) _ProviderRevisionConnection(ctx context.Context, sel ast.SelectionSet, obj *model.ProviderRevisionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerRevisionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProviderRevisionConnection")
		case "nodes":
			out.Values[i] = ec._ProviderRevisionConnection_nodes(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._ProviderRevisionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerRevisionSpecImplementors = []string{"ProviderRevisionSpec"}

func (ec *executionContext) _ProviderRevisionSpec(ctx context.Context, sel ast.SelectionSet, obj *model.ProviderRevisionSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerRevisionSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProviderRevisionSpec")
		case "desiredState":
			out.Values[i] = ec._ProviderRevisionSpec_desiredState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "package":
			out.Values[i] = ec._ProviderRevisionSpec_package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "packagePullPolicy":
			out.Values[i] = ec._ProviderRevisionSpec_packagePullPolicy(ctx, field, obj)
		case "revision":
			out.Values[i] = ec._ProviderRevisionSpec_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ignoreCrossplaneConstraints":
			out.Values[i] = ec._ProviderRevisionSpec_ignoreCrossplaneConstraints(ctx, field, obj)
		case "skipDependencyResolution":
			out.Values[i] = ec._ProviderRevisionSpec_skipDependencyResolution(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerRevisionStatusImplementors = []string{"ProviderRevisionStatus", "ConditionedStatus"}

func (ec *executionContext) _ProviderRevisionStatus(ctx context.Context, sel ast.SelectionSet, obj *model.ProviderRevisionStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerRevisionStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProviderRevisionStatus")
		case "conditions":
			out.Values[i] = ec._ProviderRevisionStatus_conditions(ctx, field, obj)
		case "foundDependencies":
			out.Values[i] = ec._ProviderRevisionStatus_foundDependencies(ctx, field, obj)
		case "installedDependencies":
			out.Values[i] = ec._ProviderRevisionStatus_installedDependencies(ctx, field, obj)
		case "invalidDependencies":
			out.Values[i] = ec._ProviderRevisionStatus_invalidDependencies(ctx, field, obj)
		case "permissionRequests":
			out.Values[i] = ec._ProviderRevisionStatus_permissionRequests(ctx, field, obj)
		case "objects":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProviderRevisionStatus_objects(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerSpecImplementors = []string{"ProviderSpec"}

func (ec *executionContext) _ProviderSpec(ctx context.Context, sel ast.SelectionSet, obj *model.ProviderSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProviderSpec")
		case "package":
			out.Values[i] = ec._ProviderSpec_package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revisionActivationPolicy":
			out.Values[i] = ec._ProviderSpec_revisionActivationPolicy(ctx, field, obj)
		case "revisionHistoryLimit":
			out.Values[i] = ec._ProviderSpec_revisionHistoryLimit(ctx, field, obj)
		case "packagePullPolicy":
			out.Values[i] = ec._ProviderSpec_packagePullPolicy(ctx, field, obj)
		case "ignoreCrossplaneConstraints":
			out.Values[i] = ec._ProviderSpec_ignoreCrossplaneConstraints(ctx, field, obj)
		case "skipDependencyResolution":
			out.Values[i] = ec._ProviderSpec_skipDependencyResolution(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerStatusImplementors = []string{"ProviderStatus", "ConditionedStatus"}

func (ec *executionContext) _ProviderStatus(ctx context.Context, sel ast.SelectionSet, obj *model.ProviderStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProviderStatus")
		case "conditions":
			out.Values[i] = ec._ProviderStatus_conditions(ctx, field, obj)
		case "currentRevision":
			out.Values[i] = ec._ProviderStatus_currentRevision(ctx, field, obj)
		case "currentIdentifier":
			out.Values[i] = ec._ProviderStatus_currentIdentifier(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "kubernetesResource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_kubernetesResource(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "kubernetesResources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_kubernetesResources(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_events(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "secret":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_secret(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "configMap":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_configMap(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "providers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_providers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "providerRevisions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_providerRevisions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "customResourceDefinitions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_customResourceDefinitions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "configurations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_configurations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "configurationRevisions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_configurationRevisions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "compositeResourceDefinitions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_compositeResourceDefinitions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "compositions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_compositions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "crossplaneResourceTree":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_crossplaneResourceTree(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretImplementors = []string{"Secret", "Node", "KubernetesResource"}

func (ec *executionContext) _Secret(ctx context.Context, sel ast.SelectionSet, obj *model.Secret) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Secret")
		case "id":
			out.Values[i] = ec._Secret_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiVersion":
			out.Values[i] = ec._Secret_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._Secret_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._Secret_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Secret_type(ctx, field, obj)
		case "data":
			out.Values[i] = ec._Secret_data(ctx, field, obj)
		case "unstructured":
			out.Values[i] = ec._Secret_unstructured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fieldPath":
			out.Values[i] = ec._Secret_fieldPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Secret_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretReferenceImplementors = []string{"SecretReference"}

func (ec *executionContext) _SecretReference(ctx context.Context, sel ast.SelectionSet, obj *model.SecretReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretReference")
		case "name":
			out.Values[i] = ec._SecretReference_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._SecretReference_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var typeReferenceImplementors = []string{"TypeReference"}

func (ec *executionContext) _TypeReference(ctx context.Context, sel ast.SelectionSet, obj *model.TypeReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeReference")
		case "apiVersion":
			out.Values[i] = ec._TypeReference_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "kind":
			out.Values[i] = ec._TypeReference_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateKubernetesResourcePayloadImplementors = []string{"UpdateKubernetesResourcePayload"}

func (ec *executionContext) _UpdateKubernetesResourcePayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateKubernetesResourcePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateKubernetesResourcePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateKubernetesResourcePayload")
		case "resource":
			out.Values[i] = ec._UpdateKubernetesResourcePayload_resource(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCompositeResource2githubcomupboundxgqlinternalgraphmodelCompositeResource(ctx context.Context, sel ast.SelectionSet, v model.CompositeResource) graphql.Marshaler {
	return ec._CompositeResource(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompositeResourceClaim2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaim(ctx context.Context, sel ast.SelectionSet, v model.CompositeResourceClaim) graphql.Marshaler {
	return ec._CompositeResourceClaim(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompositeResourceClaimConnection2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaimConnection(ctx context.Context, sel ast.SelectionSet, v model.CompositeResourceClaimConnection) graphql.Marshaler {
	return ec._CompositeResourceClaimConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompositeResourceClaimSpec2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaimSpec(ctx context.Context, sel ast.SelectionSet, v model.CompositeResourceClaimSpec) graphql.Marshaler {
	return ec._CompositeResourceClaimSpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompositeResourceConnection2githubcomupboundxgqlinternalgraphmodelCompositeResourceConnection(ctx context.Context, sel ast.SelectionSet, v model.CompositeResourceConnection) graphql.Marshaler {
	return ec._CompositeResourceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompositeResourceDefinition2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinition(ctx context.Context, sel ast.SelectionSet, v model.CompositeResourceDefinition) graphql.Marshaler {
	return ec._CompositeResourceDefinition(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompositeResourceDefinitionConnection2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionConnection(ctx context.Context, sel ast.SelectionSet, v model.CompositeResourceDefinitionConnection) graphql.Marshaler {
	return ec._CompositeResourceDefinitionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompositeResourceDefinitionNames2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionNames(ctx context.Context, sel ast.SelectionSet, v model.CompositeResourceDefinitionNames) graphql.Marshaler {
	return ec._CompositeResourceDefinitionNames(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompositeResourceDefinitionSpec2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionSpec(ctx context.Context, sel ast.SelectionSet, v model.CompositeResourceDefinitionSpec) graphql.Marshaler {
	return ec._CompositeResourceDefinitionSpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompositeResourceDefinitionVersion2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionVersion(ctx context.Context, sel ast.SelectionSet, v model.CompositeResourceDefinitionVersion) graphql.Marshaler {
	return ec._CompositeResourceDefinitionVersion(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompositeResourceSpec2githubcomupboundxgqlinternalgraphmodelCompositeResourceSpec(ctx context.Context, sel ast.SelectionSet, v model.CompositeResourceSpec) graphql.Marshaler {
	return ec._CompositeResourceSpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNComposition2githubcomupboundxgqlinternalgraphmodelComposition(ctx context.Context, sel ast.SelectionSet, v model.Composition) graphql.Marshaler {
	return ec._Composition(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompositionConnection2githubcomupboundxgqlinternalgraphmodelCompositionConnection(ctx context.Context, sel ast.SelectionSet, v model.CompositionConnection) graphql.Marshaler {
	return ec._CompositionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompositionSpec2githubcomupboundxgqlinternalgraphmodelCompositionSpec(ctx context.Context, sel ast.SelectionSet, v model.CompositionSpec) graphql.Marshaler {
	return ec._CompositionSpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx context.Context, sel ast.SelectionSet, v model.Condition) graphql.Marshaler {
	return ec._Condition(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNConditionStatus2githubcomupboundxgqlinternalgraphmodelConditionStatus(ctx context.Context, v interface{}) (model.ConditionStatus, error) {
	var res model.ConditionStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConditionStatus2githubcomupboundxgqlinternalgraphmodelConditionStatus(ctx context.Context, sel ast.SelectionSet, v model.ConditionStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNConfiguration2githubcomupboundxgqlinternalgraphmodelConfiguration(ctx context.Context, sel ast.SelectionSet, v model.Configuration) graphql.Marshaler {
	return ec._Configuration(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfigurationConnection2githubcomupboundxgqlinternalgraphmodelConfigurationConnection(ctx context.Context, sel ast.SelectionSet, v model.ConfigurationConnection) graphql.Marshaler {
	return ec._ConfigurationConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfigurationRevision2githubcomupboundxgqlinternalgraphmodelConfigurationRevision(ctx context.Context, sel ast.SelectionSet, v model.ConfigurationRevision) graphql.Marshaler {
	return ec._ConfigurationRevision(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfigurationRevisionConnection2githubcomupboundxgqlinternalgraphmodelConfigurationRevisionConnection(ctx context.Context, sel ast.SelectionSet, v model.ConfigurationRevisionConnection) graphql.Marshaler {
	return ec._ConfigurationRevisionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfigurationRevisionSpec2githubcomupboundxgqlinternalgraphmodelConfigurationRevisionSpec(ctx context.Context, sel ast.SelectionSet, v model.ConfigurationRevisionSpec) graphql.Marshaler {
	return ec._ConfigurationRevisionSpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfigurationSpec2githubcomupboundxgqlinternalgraphmodelConfigurationSpec(ctx context.Context, sel ast.SelectionSet, v model.ConfigurationSpec) graphql.Marshaler {
	return ec._ConfigurationSpec(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNCreateKubernetesResourceInput2githubcomupboundxgqlinternalgraphmodelCreateKubernetesResourceInput(ctx context.Context, v interface{}) (model.CreateKubernetesResourceInput, error) {
	res, err := ec.unmarshalInputCreateKubernetesResourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateKubernetesResourcePayload2githubcomupboundxgqlinternalgraphmodelCreateKubernetesResourcePayload(ctx context.Context, sel ast.SelectionSet, v model.CreateKubernetesResourcePayload) graphql.Marshaler {
	return ec._CreateKubernetesResourcePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCrossplaneResourceTreeConnection2githubcomupboundxgqlinternalgraphmodelCrossplaneResourceTreeConnection(ctx context.Context, sel ast.SelectionSet, v model.CrossplaneResourceTreeConnection) graphql.Marshaler {
	return ec._CrossplaneResourceTreeConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNCrossplaneResourceTreeNode2githubcomupboundxgqlinternalgraphmodelCrossplaneResourceTreeNode(ctx context.Context, sel ast.SelectionSet, v model.CrossplaneResourceTreeNode) graphql.Marshaler {
	return ec._CrossplaneResourceTreeNode(ctx, sel, &v)
}

func (ec *executionContext) marshalNCustomResourceDefinition2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinition(ctx context.Context, sel ast.SelectionSet, v model.CustomResourceDefinition) graphql.Marshaler {
	return ec._CustomResourceDefinition(ctx, sel, &v)
}

func (ec *executionContext) marshalNCustomResourceDefinitionConnection2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinitionConnection(ctx context.Context, sel ast.SelectionSet, v model.CustomResourceDefinitionConnection) graphql.Marshaler {
	return ec._CustomResourceDefinitionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNCustomResourceDefinitionNames2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinitionNames(ctx context.Context, sel ast.SelectionSet, v model.CustomResourceDefinitionNames) graphql.Marshaler {
	return ec._CustomResourceDefinitionNames(ctx, sel, &v)
}

func (ec *executionContext) marshalNCustomResourceDefinitionSpec2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinitionSpec(ctx context.Context, sel ast.SelectionSet, v model.CustomResourceDefinitionSpec) graphql.Marshaler {
	return ec._CustomResourceDefinitionSpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNCustomResourceDefinitionVersion2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinitionVersion(ctx context.Context, sel ast.SelectionSet, v model.CustomResourceDefinitionVersion) graphql.Marshaler {
	return ec._CustomResourceDefinitionVersion(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteKubernetesResourcePayload2githubcomupboundxgqlinternalgraphmodelDeleteKubernetesResourcePayload(ctx context.Context, sel ast.SelectionSet, v model.DeleteKubernetesResourcePayload) graphql.Marshaler {
	return ec._DeleteKubernetesResourcePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNEvent2githubcomupboundxgqlinternalgraphmodelEvent(ctx context.Context, sel ast.SelectionSet, v model.Event) graphql.Marshaler {
	return ec._Event(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventConnection2githubcomupboundxgqlinternalgraphmodelEventConnection(ctx context.Context, sel ast.SelectionSet, v model.EventConnection) graphql.Marshaler {
	return ec._EventConnection(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx context.Context, v interface{}) (model.ReferenceID, error) {
	var res model.ReferenceID
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx context.Context, sel ast.SelectionSet, v model.ReferenceID) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNJSON2byte(ctx context.Context, v interface{}) ([]byte, error) {
	res, err := model.UnmarshalJSON(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJSON2byte(ctx context.Context, sel ast.SelectionSet, v []byte) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := model.MarshalJSON(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx context.Context, sel ast.SelectionSet, v model.KubernetesResource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._KubernetesResource(ctx, sel, v)
}

func (ec *executionContext) marshalNKubernetesResourceConnection2githubcomupboundxgqlinternalgraphmodelKubernetesResourceConnection(ctx context.Context, sel ast.SelectionSet, v model.KubernetesResourceConnection) graphql.Marshaler {
	return ec._KubernetesResourceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNManagedResourceSpec2githubcomupboundxgqlinternalgraphmodelManagedResourceSpec(ctx context.Context, sel ast.SelectionSet, v model.ManagedResourceSpec) graphql.Marshaler {
	return ec._ManagedResourceSpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNObjectMeta2githubcomupboundxgqlinternalgraphmodelObjectMeta(ctx context.Context, sel ast.SelectionSet, v model.ObjectMeta) graphql.Marshaler {
	return ec._ObjectMeta(ctx, sel, &v)
}

func (ec *executionContext) marshalNObjectReference2githubcomupboundxgqlinternalgraphmodelObjectReference(ctx context.Context, sel ast.SelectionSet, v model.ObjectReference) graphql.Marshaler {
	return ec._ObjectReference(ctx, sel, &v)
}

func (ec *executionContext) marshalNObjectReference2githubcomupboundxgqlinternalgraphmodelObjectReference(ctx context.Context, sel ast.SelectionSet, v []model.ObjectReference) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNObjectReference2githubcomupboundxgqlinternalgraphmodelObjectReference(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOwner2githubcomupboundxgqlinternalgraphmodelOwner(ctx context.Context, sel ast.SelectionSet, v model.Owner) graphql.Marshaler {
	return ec._Owner(ctx, sel, &v)
}

func (ec *executionContext) marshalNOwnerConnection2githubcomupboundxgqlinternalgraphmodelOwnerConnection(ctx context.Context, sel ast.SelectionSet, v model.OwnerConnection) graphql.Marshaler {
	return ec._OwnerConnection(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNPackageRevisionDesiredState2githubcomupboundxgqlinternalgraphmodelPackageRevisionDesiredState(ctx context.Context, v interface{}) (model.PackageRevisionDesiredState, error) {
	var res model.PackageRevisionDesiredState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPackageRevisionDesiredState2githubcomupboundxgqlinternalgraphmodelPackageRevisionDesiredState(ctx context.Context, sel ast.SelectionSet, v model.PackageRevisionDesiredState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPatch2githubcomupboundxgqlinternalgraphmodelPatch(ctx context.Context, v interface{}) (model.Patch, error) {
	res, err := ec.unmarshalInputPatch(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPolicyRule2githubcomupboundxgqlinternalgraphmodelPolicyRule(ctx context.Context, sel ast.SelectionSet, v model.PolicyRule) graphql.Marshaler {
	return ec._PolicyRule(ctx, sel, &v)
}

func (ec *executionContext) marshalNProvider2githubcomupboundxgqlinternalgraphmodelProvider(ctx context.Context, sel ast.SelectionSet, v model.Provider) graphql.Marshaler {
	return ec._Provider(ctx, sel, &v)
}

func (ec *executionContext) marshalNProviderConnection2githubcomupboundxgqlinternalgraphmodelProviderConnection(ctx context.Context, sel ast.SelectionSet, v model.ProviderConnection) graphql.Marshaler {
	return ec._ProviderConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNProviderRevision2githubcomupboundxgqlinternalgraphmodelProviderRevision(ctx context.Context, sel ast.SelectionSet, v model.ProviderRevision) graphql.Marshaler {
	return ec._ProviderRevision(ctx, sel, &v)
}

func (ec *executionContext) marshalNProviderRevisionConnection2githubcomupboundxgqlinternalgraphmodelProviderRevisionConnection(ctx context.Context, sel ast.SelectionSet, v model.ProviderRevisionConnection) graphql.Marshaler {
	return ec._ProviderRevisionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNProviderRevisionSpec2githubcomupboundxgqlinternalgraphmodelProviderRevisionSpec(ctx context.Context, sel ast.SelectionSet, v model.ProviderRevisionSpec) graphql.Marshaler {
	return ec._ProviderRevisionSpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNProviderSpec2githubcomupboundxgqlinternalgraphmodelProviderSpec(ctx context.Context, sel ast.SelectionSet, v model.ProviderSpec) graphql.Marshaler {
	return ec._ProviderSpec(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNResourceScope2githubcomupboundxgqlinternalgraphmodelResourceScope(ctx context.Context, v interface{}) (model.ResourceScope, error) {
	var res model.ResourceScope
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResourceScope2githubcomupboundxgqlinternalgraphmodelResourceScope(ctx context.Context, sel ast.SelectionSet, v model.ResourceScope) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTypeReference2githubcomupboundxgqlinternalgraphmodelTypeReference(ctx context.Context, sel ast.SelectionSet, v model.TypeReference) graphql.Marshaler {
	return ec._TypeReference(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNUpdateKubernetesResourceInput2githubcomupboundxgqlinternalgraphmodelUpdateKubernetesResourceInput(ctx context.Context, v interface{}) (model.UpdateKubernetesResourceInput, error) {
	res, err := ec.unmarshalInputUpdateKubernetesResourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateKubernetesResourcePayload2githubcomupboundxgqlinternalgraphmodelUpdateKubernetesResourcePayload(ctx context.Context, sel ast.SelectionSet, v model.UpdateKubernetesResourcePayload) graphql.Marshaler {
	return ec._UpdateKubernetesResourcePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCompositeResource2githubcomupboundxgqlinternalgraphmodelCompositeResource(ctx context.Context, sel ast.SelectionSet, v []model.CompositeResource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCompositeResource2githubcomupboundxgqlinternalgraphmodelCompositeResource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCompositeResource2githubcomupboundxgqlinternalgraphmodelCompositeResource(ctx context.Context, sel ast.SelectionSet, v *model.CompositeResource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositeResource(ctx, sel, v)
}

func (ec *executionContext) marshalOCompositeResourceClaim2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaim(ctx context.Context, sel ast.SelectionSet, v []model.CompositeResourceClaim) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCompositeResourceClaim2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaim(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCompositeResourceClaim2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaim(ctx context.Context, sel ast.SelectionSet, v *model.CompositeResourceClaim) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositeResourceClaim(ctx, sel, v)
}

func (ec *executionContext) marshalOCompositeResourceClaimConnectionDetails2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaimConnectionDetails(ctx context.Context, sel ast.SelectionSet, v *model.CompositeResourceClaimConnectionDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositeResourceClaimConnectionDetails(ctx, sel, v)
}

func (ec *executionContext) marshalOCompositeResourceClaimStatus2githubcomupboundxgqlinternalgraphmodelCompositeResourceClaimStatus(ctx context.Context, sel ast.SelectionSet, v *model.CompositeResourceClaimStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositeResourceClaimStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOCompositeResourceConnectionDetails2githubcomupboundxgqlinternalgraphmodelCompositeResourceConnectionDetails(ctx context.Context, sel ast.SelectionSet, v *model.CompositeResourceConnectionDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositeResourceConnectionDetails(ctx, sel, v)
}

func (ec *executionContext) marshalOCompositeResourceDefinition2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinition(ctx context.Context, sel ast.SelectionSet, v []model.CompositeResourceDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCompositeResourceDefinition2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCompositeResourceDefinition2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinition(ctx context.Context, sel ast.SelectionSet, v *model.CompositeResourceDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositeResourceDefinition(ctx, sel, v)
}

func (ec *executionContext) marshalOCompositeResourceDefinitionControllerStatus2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionControllerStatus(ctx context.Context, sel ast.SelectionSet, v *model.CompositeResourceDefinitionControllerStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositeResourceDefinitionControllerStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOCompositeResourceDefinitionNames2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionNames(ctx context.Context, sel ast.SelectionSet, v *model.CompositeResourceDefinitionNames) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositeResourceDefinitionNames(ctx, sel, v)
}

func (ec *executionContext) marshalOCompositeResourceDefinitionStatus2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionStatus(ctx context.Context, sel ast.SelectionSet, v *model.CompositeResourceDefinitionStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositeResourceDefinitionStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOCompositeResourceDefinitionVersion2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionVersion(ctx context.Context, sel ast.SelectionSet, v []model.CompositeResourceDefinitionVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCompositeResourceDefinitionVersion2githubcomupboundxgqlinternalgraphmodelCompositeResourceDefinitionVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCompositeResourceStatus2githubcomupboundxgqlinternalgraphmodelCompositeResourceStatus(ctx context.Context, sel ast.SelectionSet, v *model.CompositeResourceStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositeResourceStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOCompositeResourceValidation2githubcomupboundxgqlinternalgraphmodelCompositeResourceValidation(ctx context.Context, sel ast.SelectionSet, v *model.CompositeResourceValidation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositeResourceValidation(ctx, sel, v)
}

func (ec *executionContext) marshalOComposition2githubcomupboundxgqlinternalgraphmodelComposition(ctx context.Context, sel ast.SelectionSet, v []model.Composition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNComposition2githubcomupboundxgqlinternalgraphmodelComposition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOComposition2githubcomupboundxgqlinternalgraphmodelComposition(ctx context.Context, sel ast.SelectionSet, v *model.Composition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Composition(ctx, sel, v)
}

func (ec *executionContext) marshalOCompositionStatus2githubcomupboundxgqlinternalgraphmodelCompositionStatus(ctx context.Context, sel ast.SelectionSet, v *model.CompositionStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositionStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx context.Context, sel ast.SelectionSet, v []model.Condition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCondition2githubcomupboundxgqlinternalgraphmodelCondition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOConfigMap2githubcomupboundxgqlinternalgraphmodelConfigMap(ctx context.Context, sel ast.SelectionSet, v *model.ConfigMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConfigMap(ctx, sel, v)
}

func (ec *executionContext) marshalOConfiguration2githubcomupboundxgqlinternalgraphmodelConfiguration(ctx context.Context, sel ast.SelectionSet, v []model.Configuration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNConfiguration2githubcomupboundxgqlinternalgraphmodelConfiguration(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOConfigurationRevision2githubcomupboundxgqlinternalgraphmodelConfigurationRevision(ctx context.Context, sel ast.SelectionSet, v []model.ConfigurationRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNConfigurationRevision2githubcomupboundxgqlinternalgraphmodelConfigurationRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOConfigurationRevision2githubcomupboundxgqlinternalgraphmodelConfigurationRevision(ctx context.Context, sel ast.SelectionSet, v *model.ConfigurationRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConfigurationRevision(ctx, sel, v)
}

func (ec *executionContext) marshalOConfigurationRevisionStatus2githubcomupboundxgqlinternalgraphmodelConfigurationRevisionStatus(ctx context.Context, sel ast.SelectionSet, v *model.ConfigurationRevisionStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConfigurationRevisionStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOConfigurationStatus2githubcomupboundxgqlinternalgraphmodelConfigurationStatus(ctx context.Context, sel ast.SelectionSet, v *model.ConfigurationStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConfigurationStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOCrossplaneResourceTreeNode2githubcomupboundxgqlinternalgraphmodelCrossplaneResourceTreeNode(ctx context.Context, sel ast.SelectionSet, v []model.CrossplaneResourceTreeNode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCrossplaneResourceTreeNode2githubcomupboundxgqlinternalgraphmodelCrossplaneResourceTreeNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCustomResourceDefinition2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinition(ctx context.Context, sel ast.SelectionSet, v []model.CustomResourceDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCustomResourceDefinition2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCustomResourceDefinition2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinition(ctx context.Context, sel ast.SelectionSet, v *model.CustomResourceDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CustomResourceDefinition(ctx, sel, v)
}

func (ec *executionContext) marshalOCustomResourceDefinitionStatus2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinitionStatus(ctx context.Context, sel ast.SelectionSet, v *model.CustomResourceDefinitionStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CustomResourceDefinitionStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOCustomResourceDefinitionVersion2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinitionVersion(ctx context.Context, sel ast.SelectionSet, v []model.CustomResourceDefinitionVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCustomResourceDefinitionVersion2githubcomupboundxgqlinternalgraphmodelCustomResourceDefinitionVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCustomResourceValidation2githubcomupboundxgqlinternalgraphmodelCustomResourceValidation(ctx context.Context, sel ast.SelectionSet, v *model.CustomResourceValidation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CustomResourceValidation(ctx, sel, v)
}

func (ec *executionContext) unmarshalODefinedCompositeResourceClaimOptionsInput2githubcomupboundxgqlinternalgraphmodelDefinedCompositeResourceClaimOptionsInput(ctx context.Context, v interface{}) (*model.DefinedCompositeResourceClaimOptionsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDefinedCompositeResourceClaimOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODefinedCompositeResourceOptionsInput2githubcomupboundxgqlinternalgraphmodelDefinedCompositeResourceOptionsInput(ctx context.Context, v interface{}) (*model.DefinedCompositeResourceOptionsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDefinedCompositeResourceOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODeletionPolicy2githubcomupboundxgqlinternalgraphmodelDeletionPolicy(ctx context.Context, v interface{}) (*model.DeletionPolicy, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.DeletionPolicy)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODeletionPolicy2githubcomupboundxgqlinternalgraphmodelDeletionPolicy(ctx context.Context, sel ast.SelectionSet, v *model.DeletionPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOEvent2githubcomupboundxgqlinternalgraphmodelEvent(ctx context.Context, sel ast.SelectionSet, v []model.Event) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvent2githubcomupboundxgqlinternalgraphmodelEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOEventSource2githubcomupboundxgqlinternalgraphmodelEventSource(ctx context.Context, sel ast.SelectionSet, v *model.EventSource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventSource(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventType2githubcomupboundxgqlinternalgraphmodelEventType(ctx context.Context, v interface{}) (*model.EventType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.EventType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventType2githubcomupboundxgqlinternalgraphmodelEventType(ctx context.Context, sel ast.SelectionSet, v *model.EventType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx context.Context, v interface{}) (*model.ReferenceID, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ReferenceID)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2githubcomupboundxgqlinternalgraphmodelReferenceID(ctx context.Context, sel ast.SelectionSet, v *model.ReferenceID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOJSON2byte(ctx context.Context, v interface{}) ([]byte, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalJSON(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJSON2byte(ctx context.Context, sel ast.SelectionSet, v []byte) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := model.MarshalJSON(v)
	return res
}

func (ec *executionContext) marshalOKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx context.Context, sel ast.SelectionSet, v model.KubernetesResource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KubernetesResource(ctx, sel, v)
}

func (ec *executionContext) marshalOKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx context.Context, sel ast.SelectionSet, v []model.KubernetesResource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKubernetesResource2githubcomupboundxgqlinternalgraphmodelKubernetesResource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLabelSelector2githubcomupboundxgqlinternalgraphmodelLabelSelector(ctx context.Context, sel ast.SelectionSet, v *model.LabelSelector) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LabelSelector(ctx, sel, v)
}

func (ec *executionContext) marshalOLocalObjectReference2githubcomupboundxgqlinternalgraphmodelLocalObjectReference(ctx context.Context, sel ast.SelectionSet, v *model.LocalObjectReference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LocalObjectReference(ctx, sel, v)
}

func (ec *executionContext) marshalOManagedResourceDefinition2githubcomupboundxgqlinternalgraphmodelManagedResourceDefinition(ctx context.Context, sel ast.SelectionSet, v model.ManagedResourceDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ManagedResourceDefinition(ctx, sel, v)
}

func (ec *executionContext) marshalOManagedResourceStatus2githubcomupboundxgqlinternalgraphmodelManagedResourceStatus(ctx context.Context, sel ast.SelectionSet, v *model.ManagedResourceStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ManagedResourceStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOObjectReference2githubcomupboundxgqlinternalgraphmodelObjectReference(ctx context.Context, sel ast.SelectionSet, v *model.ObjectReference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ObjectReference(ctx, sel, v)
}

func (ec *executionContext) marshalOOwner2githubcomupboundxgqlinternalgraphmodelOwner(ctx context.Context, sel ast.SelectionSet, v []model.Owner) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOwner2githubcomupboundxgqlinternalgraphmodelOwner(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPackagePullPolicy2githubcomupboundxgqlinternalgraphmodelPackagePullPolicy(ctx context.Context, v interface{}) (*model.PackagePullPolicy, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.PackagePullPolicy)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPackagePullPolicy2githubcomupboundxgqlinternalgraphmodelPackagePullPolicy(ctx context.Context, sel ast.SelectionSet, v *model.PackagePullPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPatch2githubcomupboundxgqlinternalgraphmodelPatch(ctx context.Context, v interface{}) ([]model.Patch, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.Patch, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPatch2githubcomupboundxgqlinternalgraphmodelPatch(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPolicyRule2githubcomupboundxgqlinternalgraphmodelPolicyRule(ctx context.Context, sel ast.SelectionSet, v []model.PolicyRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPolicyRule2githubcomupboundxgqlinternalgraphmodelPolicyRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOProvider2githubcomupboundxgqlinternalgraphmodelProvider(ctx context.Context, sel ast.SelectionSet, v []model.Provider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProvider2githubcomupboundxgqlinternalgraphmodelProvider(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOProviderConfigDefinition2githubcomupboundxgqlinternalgraphmodelProviderConfigDefinition(ctx context.Context, sel ast.SelectionSet, v model.ProviderConfigDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProviderConfigDefinition(ctx, sel, v)
}

func (ec *executionContext) marshalOProviderConfigReference2githubcomupboundxgqlinternalgraphmodelProviderConfigReference(ctx context.Context, sel ast.SelectionSet, v *model.ProviderConfigReference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProviderConfigReference(ctx, sel, v)
}

func (ec *executionContext) marshalOProviderConfigStatus2githubcomupboundxgqlinternalgraphmodelProviderConfigStatus(ctx context.Context, sel ast.SelectionSet, v *model.ProviderConfigStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProviderConfigStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOProviderRevision2githubcomupboundxgqlinternalgraphmodelProviderRevision(ctx context.Context, sel ast.SelectionSet, v []model.ProviderRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProviderRevision2githubcomupboundxgqlinternalgraphmodelProviderRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOProviderRevision2githubcomupboundxgqlinternalgraphmodelProviderRevision(ctx context.Context, sel ast.SelectionSet, v *model.ProviderRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProviderRevision(ctx, sel, v)
}

func (ec *executionContext) marshalOProviderRevisionStatus2githubcomupboundxgqlinternalgraphmodelProviderRevisionStatus(ctx context.Context, sel ast.SelectionSet, v *model.ProviderRevisionStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProviderRevisionStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOProviderStatus2githubcomupboundxgqlinternalgraphmodelProviderStatus(ctx context.Context, sel ast.SelectionSet, v *model.ProviderStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProviderStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOQuery2githubcom99designsgqlgengraphqlMarshaler(ctx context.Context, sel ast.SelectionSet, v graphql.Marshaler) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalORevisionActivationPolicy2githubcomupboundxgqlinternalgraphmodelRevisionActivationPolicy(ctx context.Context, v interface{}) (*model.RevisionActivationPolicy, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.RevisionActivationPolicy)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORevisionActivationPolicy2githubcomupboundxgqlinternalgraphmodelRevisionActivationPolicy(ctx context.Context, sel ast.SelectionSet, v *model.RevisionActivationPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOSecret2githubcomupboundxgqlinternalgraphmodelSecret(ctx context.Context, sel ast.SelectionSet, v *model.Secret) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Secret(ctx, sel, v)
}

func (ec *executionContext) marshalOSecretReference2githubcomupboundxgqlinternalgraphmodelSecretReference(ctx context.Context, sel ast.SelectionSet, v *model.SecretReference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SecretReference(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStringMap2map(ctx context.Context, v interface{}) (map[string]string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalStringMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStringMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := model.MarshalStringMap(v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTypeReference2githubcomupboundxgqlinternalgraphmodelTypeReference(ctx context.Context, sel ast.SelectionSet, v *model.TypeReference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TypeReference(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
